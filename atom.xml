<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TokeyRoad</title>
  
  <subtitle>Never underestimate your power to change yourself!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://TokeyRoad.github.io/"/>
  <updated>2021-06-29T14:02:03.966Z</updated>
  <id>http://TokeyRoad.github.io/</id>
  
  <author>
    <name>Tokey</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>go基础语法学习03</title>
    <link href="http://TokeyRoad.github.io/2021/06/28/go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A003/"/>
    <id>http://TokeyRoad.github.io/2021/06/28/go基础语法学习03/</id>
    <published>2021-06-28T14:39:04.000Z</published>
    <updated>2021-06-29T14:02:03.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="go基础语法学习03"><a href="#go基础语法学习03" class="headerlink" title="go基础语法学习03"></a>go基础语法学习03</h2><h4 id="1-类构建和成员函数"><a href="#1-类构建和成员函数" class="headerlink" title="1.类构建和成员函数"></a>1.类构建和成员函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(p.name, <span class="string">"is eating"</span>)</span><br><span class="line">p.name = <span class="string">"name1"</span><span class="comment">//这里p是对象的拷贝，修改p不会影响源对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Person)</span> <span class="title">Eat2</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(this.name, <span class="string">"is eating"</span>)</span><br><span class="line">this.name = <span class="string">"name2"</span><span class="comment">//这里this是指向源对象，修改this会影响源对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">tokey := Person&#123;<span class="string">"tokey"</span>, <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用指针绑定成员函数，可以直接修改成员变量。</span></span><br><span class="line"><span class="comment">//另一种方法绑定成员函数，用的是拷贝，修改之后不影响源对象。</span></span><br><span class="line">tokey.Eat()</span><br><span class="line">tokey.Eat2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>go没有class，但是可以用struct实现class的概念。</p></blockquote><h4 id="2-类继承"><a href="#2-类继承" class="headerlink" title="2.类继承"></a>2.类继承</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="keyword">type</span> Base <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Base)</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"this is base print"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">type</span> SubBase <span class="keyword">struct</span> &#123;</span><br><span class="line">Base    <span class="comment">//继承时，直接写基类类型，没有字段名</span></span><br><span class="line">address <span class="keyword">string</span></span><br><span class="line">name    <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//属于类嵌套，不是继承</span></span><br><span class="line"><span class="keyword">type</span> Other <span class="keyword">struct</span> &#123;</span><br><span class="line">base  Base</span><br><span class="line">other <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//证明Other不是继承，SubBase是继承</span></span><br><span class="line">o := Other&#123;&#125;</span><br><span class="line"><span class="comment">//o.print() 编译报错</span></span><br><span class="line">fmt.Println(o)</span><br><span class="line"></span><br><span class="line">sub := SubBase&#123;&#125;</span><br><span class="line">sub.<span class="built_in">print</span>()</span><br><span class="line">sub.name = <span class="string">"sub"</span> <span class="comment">//如果父类和子类出现同名字段，这样赋值是给子类中的字段赋值。</span></span><br><span class="line">sub.address = <span class="string">"address"</span></span><br><span class="line">sub.age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">fmt.Println(sub)</span><br><span class="line"></span><br><span class="line">sub.Base.name = <span class="string">"base"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(sub)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; 0&#125; &#125;</span><br><span class="line">this is base print</span><br><span class="line">&#123;&#123; 20&#125; address sub&#125;</span><br><span class="line">&#123;&#123;base 20&#125; address sub&#125;</span><br></pre></td></tr></table></figure><h4 id="3-类权限"><a href="#3-类权限" class="headerlink" title="3.类权限"></a>3.类权限</h4><ol><li>在go语言中，权限都是通过首字母大小写来控制的。</li><li>import中，如果包名不同，那么只有大写字母开头的才是public。</li><li>对于类中的成员、方法，只有大写开头的才能在其他包中使用。</li></ol><h4 id="4-接口interface"><a href="#4-接口interface" class="headerlink" title="4.接口interface"></a>4.接口interface</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//interface可以接受任意的数据类型，类似于void</span></span><br><span class="line"><span class="keyword">var</span> i, j, k <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">names := []<span class="keyword">string</span>&#123;<span class="string">"string"</span>, <span class="string">"name"</span>&#125;</span><br><span class="line">i = names</span><br><span class="line">fmt.Println(<span class="string">"i代表切片数组:"</span>, i)</span><br><span class="line"></span><br><span class="line">age := <span class="number">20</span></span><br><span class="line">j = age</span><br><span class="line">fmt.Println(<span class="string">"j代表整形:"</span>, j)</span><br><span class="line"></span><br><span class="line">str := <span class="string">"hello"</span></span><br><span class="line">k = str</span><br><span class="line">fmt.Println(<span class="string">"k代表字符串:"</span>, k)</span><br><span class="line"></span><br><span class="line"><span class="comment">//check</span></span><br><span class="line">val, ok := k.(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">fmt.Println(<span class="string">"k不是int"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"k是int，值:"</span>, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常用的场景：把interface当成一个函数的参数，使用switch来判断用户输入的不同类型</span></span><br><span class="line">array := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">array[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">array[<span class="number">1</span>] = <span class="string">"hello"</span></span><br><span class="line">array[<span class="number">2</span>] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, val := <span class="keyword">range</span> array &#123;</span><br><span class="line"><span class="keyword">switch</span> v := val.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">fmt.Printf(<span class="string">"int %d\n"</span>, v)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">fmt.Printf(<span class="string">"string %s\n"</span>, v)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">fmt.Printf(<span class="string">"bool %v\n"</span>, v)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">"error\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-多态"><a href="#5-多态" class="headerlink" title="5.多态"></a>5.多态</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现go多态，需要实现定义接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个接口，注意接口类型是interface</span></span><br><span class="line"><span class="keyword">type</span> IAttack <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">//接口函数可以有多个，但是只能有函数模型，不能有实现</span></span><br><span class="line">Attack()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PlayerObject <span class="keyword">struct</span> &#123;</span><br><span class="line">name  <span class="keyword">string</span></span><br><span class="line">level <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *PlayerObject)</span> <span class="title">Attack</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"PlayerObject"</span>, a.name, <span class="string">", level is"</span>, a.level)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BossObject <span class="keyword">struct</span> &#123;</span><br><span class="line">name  <span class="keyword">string</span></span><br><span class="line">level <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *BossObject)</span> <span class="title">Attack</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"BossObject"</span>, a.name, <span class="string">", level is"</span>, a.level)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个多态的通用接口，传入不同的类型，实现不同的功能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoAttack</span><span class="params">(a IAttack)</span></span> &#123;</span><br><span class="line">a.Attack()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//var player interface&#123;&#125; //空接口</span></span><br><span class="line"><span class="keyword">var</span> player IAttack <span class="comment">//定义一个包含Attack接口的变量</span></span><br><span class="line">playerObject := PlayerObject&#123;<span class="string">"player"</span>, <span class="number">1</span>&#125;</span><br><span class="line">playerObject.Attack()</span><br><span class="line"></span><br><span class="line">bossObject := BossObject&#123;<span class="string">"boss"</span>, <span class="number">10</span>&#125;</span><br><span class="line">bossObject.Attack()</span><br><span class="line"></span><br><span class="line"><span class="comment">//player 赋值为playerObject</span></span><br><span class="line"><span class="comment">//接口赋值必须使用指针类型</span></span><br><span class="line">player = &amp;playerObject</span><br><span class="line">player.Attack()</span><br><span class="line">player = &amp;bossObject</span><br><span class="line">player.Attack()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"---------------------------"</span>)</span><br><span class="line">DoAttack(&amp;playerObject)</span><br><span class="line">DoAttack(&amp;bossObject)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PlayerObject player , level is 1</span><br><span class="line">BossObject boss , level is 10</span><br><span class="line">PlayerObject player , level is 1</span><br><span class="line">BossObject boss , level is 10</span><br><span class="line">---------------------------</span><br><span class="line">PlayerObject player , level is 1</span><br><span class="line">BossObject boss , level is 10</span><br></pre></td></tr></table></figure><blockquote><p>go语言的多态不需要继承，只要实现相同的接口即可。</p><ol><li>定义一个接口，里面设计好需要的接口，可以有多个。</li><li>任何实现了这个接口的类型，都可以赋值给这个接口，从而实现多态。</li><li>多个类之间不需要有继承关系。</li><li>如果interface中定义了多个接口，那么实际的类必须全部实现接口函数，才可以赋值。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;go基础语法学习03&quot;&gt;&lt;a href=&quot;#go基础语法学习03&quot; class=&quot;headerlink&quot; title=&quot;go基础语法学习03&quot;&gt;&lt;/a&gt;go基础语法学习03&lt;/h2&gt;&lt;h4 id=&quot;1-类构建和成员函数&quot;&gt;&lt;a href=&quot;#1-类构建和成员函数&quot;
      
    
    </summary>
    
      <category term="go" scheme="http://TokeyRoad.github.io/categories/go/"/>
    
    
      <category term="go" scheme="http://TokeyRoad.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go基础语法学习02</title>
    <link href="http://TokeyRoad.github.io/2021/06/27/go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A002/"/>
    <id>http://TokeyRoad.github.io/2021/06/27/go基础语法学习02/</id>
    <published>2021-06-27T00:44:54.000Z</published>
    <updated>2021-06-27T01:16:33.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="go基础语法学习02"><a href="#go基础语法学习02" class="headerlink" title="go基础语法学习02"></a>go基础语法学习02</h2><h3 id="1-switch"><a href="#1-switch" class="headerlink" title="1. switch"></a>1. switch</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">cmds := os.Args</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, val := <span class="keyword">range</span> cmds &#123;</span><br><span class="line">fmt.Println(<span class="string">"key:"</span>, key, <span class="string">"val:"</span>, val, <span class="string">"cmds len:"</span>, <span class="built_in">len</span>(cmds))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> cmds[<span class="number">1</span>] &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"hello"</span>:</span><br><span class="line">fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"world"</span>:</span><br><span class="line">fmt.Println(<span class="string">"world"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"default"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>os.Args 表示获取程序的输入参数,类似于C++的 argv**</li><li>go的switch默认不需要加break，编译器会自动补上，如果使用fallthrough，编译器则不会给该case下补break </li></ol></blockquote><h3 id="2-标签-‘LABLE’"><a href="#2-标签-‘LABLE’" class="headerlink" title="2. 标签 ‘LABLE’"></a>2. 标签 ‘LABLE’</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">LABEL1:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">3</span> &#123;</span><br><span class="line">                <span class="comment">//break LABEL1</span></span><br><span class="line">                <span class="comment">//goto LABEL1</span></span><br><span class="line"><span class="keyword">continue</span> LABEL1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"i:"</span>, i, <span class="string">" j:"</span>, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"over"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>break+标签：表示跳出标签下的循环。</li><li>continue+标签：表示跳过标签下的当前循环</li><li>goto+标签：表示程序从标签位置重新执行</li></ol></blockquote><h3 id="3-枚举-iota"><a href="#3-枚举-iota" class="headerlink" title="3. 枚举-iota"></a>3. 枚举-iota</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在Go语言中没有枚举类型，通过const+iota(常量累加器)来进行模拟</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">MONDAY    = <span class="literal">iota</span> + <span class="number">2</span>   <span class="comment">//iota = 0</span></span><br><span class="line">TUESDAY                <span class="comment">// iota = 1</span></span><br><span class="line">WEDNESDAY              <span class="comment">// iota = 2</span></span><br><span class="line">THURSDAY               <span class="comment">// iota = 3</span></span><br><span class="line">FRIDAY                 <span class="comment">// iota = 4</span></span><br><span class="line">X, Y      = <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">// iota = 5</span></span><br><span class="line">SATURDAY  = <span class="number">1</span>          <span class="comment">// iota = 6</span></span><br><span class="line">SUNDAY                 <span class="comment">// iota = 7</span></span><br><span class="line">M, N      = <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">// iota = 8</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">first = <span class="number">1</span></span><br><span class="line">second</span><br><span class="line">third</span><br><span class="line">fourth = <span class="literal">iota</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(MONDAY)</span><br><span class="line">fmt.Println(TUESDAY)</span><br><span class="line">fmt.Println(WEDNESDAY)</span><br><span class="line">fmt.Println(THURSDAY)</span><br><span class="line">fmt.Println(FRIDAY)</span><br><span class="line">fmt.Println(SATURDAY)</span><br><span class="line">fmt.Println(SUNDAY)</span><br><span class="line">fmt.Println(X, Y)</span><br><span class="line">fmt.Println(M, N)</span><br><span class="line">fmt.Println(first, second, third, fourth)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">5 5</span><br><span class="line">8 8</span><br><span class="line">1 1 1 3</span><br></pre></td></tr></table></figure><blockquote><p>iota 常量累加器，遇到const就置 0，换行+1</p><p>iota只能在const作用域内使用</p><p>const之后每换一行iota+1，即使没有使用</p></blockquote><h3 id="4-结构体"><a href="#4-结构体" class="headerlink" title="4. 结构体"></a>4. 结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">name   <span class="keyword">string</span></span><br><span class="line">age    <span class="keyword">int</span></span><br><span class="line">gender <span class="keyword">string</span></span><br><span class="line">score  <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">tokey := Student&#123;</span><br><span class="line"><span class="string">"tokey"</span>,</span><br><span class="line"><span class="number">20</span>,</span><br><span class="line"><span class="string">"男"</span>,</span><br><span class="line"><span class="number">80.001</span>,</span><br><span class="line">&#125; <span class="comment">// 等价于 tokey := Student&#123;"tokey", 20, "男", 80.001&#125;注意结尾少了个逗号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// tokey := Student&#123;</span></span><br><span class="line"><span class="comment">// name:   "tokey",</span></span><br><span class="line"><span class="comment">// age:    20,</span></span><br><span class="line"><span class="comment">// gender: "男",</span></span><br><span class="line"><span class="comment">// score:  80.001,</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">fmt.Println(<span class="string">"tokey:"</span>, tokey.name, tokey.age, tokey.gender, tokey.score)</span><br><span class="line"></span><br><span class="line">s1 := &amp;tokey</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"指针 tokey:"</span>, s1.name, s1.age, s1.gender, (*s1).score)</span><br><span class="line">    <span class="comment">//go语言中没有-&gt;这种写法，指针也是使用.操作符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-init函数"><a href="#5-init函数" class="headerlink" title="5. init函数"></a>5. init函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//day02\05-init.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">ADD <span class="string">"day02/05-import/add"</span></span><br><span class="line"><span class="string">"day02/05-import/sub"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个包中有多个init函数时，都会调用，但是顺序不能保证</span></span><br><span class="line"><span class="comment">// _ "day02/05-import/sub" //这样只会调用init函数，其他函数无法调用</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"this is 05-init func"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"sub:"</span>, sub.Sub(<span class="number">40</span>, <span class="number">12</span>), <span class="string">"add:"</span>, ADD.Add(<span class="number">12</span>, <span class="number">12</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//day02\05-import\add\add.go</span></span><br><span class="line"><span class="keyword">package</span> add</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"this is init() in the package add"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"public:"</span>, a+b)</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Print(<span class="string">"protected:"</span>, a+b)</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//day02\05-import\sub\sub.go</span></span><br><span class="line"><span class="keyword">package</span> sub</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"this is first init() in package sub"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"this is second init() in package sub"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sub</span><span class="params">(first <span class="keyword">int</span>, second <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"public:"</span>, first-second)</span><br><span class="line"><span class="keyword">return</span> first - second</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(first, second <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"protected:"</span>, first-second)</span><br><span class="line"><span class="keyword">return</span> first - second</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">this is init() in the package add</span><br><span class="line">this is first init() in package sub</span><br><span class="line">this is second init() in package sub</span><br><span class="line">this is 05-init func</span><br><span class="line">public: 28</span><br><span class="line">public: 24</span><br><span class="line">sub: 28 add: 24</span><br></pre></td></tr></table></figure><h3 id="6-defer"><a href="#6-defer" class="headerlink" title="6. defer"></a>6. defer</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//资源清理</span></span><br><span class="line"><span class="comment">//在同一个函数中多次调用defer，执行时类似于栈的机制，先进后出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">readFile(<span class="string">"01-switch.go"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(fileName <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">f1, err := os.Open(fileName)</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(fileName <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"ready close file:"</span>, fileName)</span><br><span class="line">ret := f1.Close()</span><br><span class="line">fmt.Println(<span class="string">"close file ret:"</span>, ret)</span><br><span class="line">&#125;(fileName) <span class="comment">//最后的（）表示调用 之前表示声明</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"os.Open "</span>, fileName, <span class="string">" error:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">n, _ := f1.Read(buf)</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"11111"</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"22222"</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"read file real length:"</span>, n)</span><br><span class="line"><span class="comment">//fmt.Println("file content is:", buf)//buf是二进制数据</span></span><br><span class="line"><span class="comment">//fmt.Println("file content is:", string(buf))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read file real length: 343</span><br><span class="line">22222</span><br><span class="line">11111</span><br><span class="line">ready close file: 01-switch.go</span><br><span class="line">close file ret: &lt;nil&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;go基础语法学习02&quot;&gt;&lt;a href=&quot;#go基础语法学习02&quot; class=&quot;headerlink&quot; title=&quot;go基础语法学习02&quot;&gt;&lt;/a&gt;go基础语法学习02&lt;/h2&gt;&lt;h3 id=&quot;1-switch&quot;&gt;&lt;a href=&quot;#1-switch&quot; cla
      
    
    </summary>
    
      <category term="go" scheme="http://TokeyRoad.github.io/categories/go/"/>
    
    
      <category term="go" scheme="http://TokeyRoad.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go-vscode环境配置</title>
    <link href="http://TokeyRoad.github.io/2021/05/26/go-vscode%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://TokeyRoad.github.io/2021/05/26/go-vscode环境配置/</id>
    <published>2021-05-26T14:35:07.000Z</published>
    <updated>2021-05-26T15:01:50.364Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Windows下go-vscode的环境配置"><a href="#Windows下go-vscode的环境配置" class="headerlink" title="Windows下go+vscode的环境配置"></a>Windows下go+vscode的环境配置</h3><h4 id="1-下载安装vscode和-windows下go（https-golang-google-cn-）的默认安装"><a href="#1-下载安装vscode和-windows下go（https-golang-google-cn-）的默认安装" class="headerlink" title="1. 下载安装vscode和 windows下go（https://golang.google.cn/）的默认安装"></a>1. 下载安装vscode和 windows下go（<a href="https://golang.google.cn/）的默认安装" target="_blank" rel="noopener">https://golang.google.cn/）的默认安装</a></h4><p>略</p><h4 id="2-配置Go-Env"><a href="#2-配置Go-Env" class="headerlink" title="2. 配置Go Env"></a>2. 配置Go Env</h4><ol><li><p>创建go的工作目录</p><blockquote><p>GOPATH（工作目录）</p><p>——-bin（go的二进制包目录）</p><p>——-pkg （归档文件目录）</p><p>——-src （源码文件目录）</p><p>在用户环境变量中设置GoPath=工作目录</p></blockquote></li><li><p>CMD下配置go env</p><blockquote><ol><li>go env -w GO111MODULE=on   开启 GO111MODULE   </li><li>go env -w GOBIN=E:\GOPATH\bin   设置bin目录</li><li>go env -w GOPROXY=<a href="https://goproxy.cn/" target="_blank" rel="noopener">https://goproxy.cn</a>,direct  设置go国内代理(七牛云CDN)</li></ol></blockquote></li></ol><h4 id="3-vscode配置"><a href="#3-vscode配置" class="headerlink" title="3. vscode配置"></a>3. vscode配置</h4><ol><li>vscode中go插件安装。</li><li>按住Ctrl+Shift+P 输入Go:Install/Update Tools，然后勾选所有，并安装。（前一步如果设置了代理，这里应该会全部成功，否则就会失败）。</li><li>（可选）安装gocode插件，代码智能提示。go get github.com/stamblerre/gocode</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Windows下go-vscode的环境配置&quot;&gt;&lt;a href=&quot;#Windows下go-vscode的环境配置&quot; class=&quot;headerlink&quot; title=&quot;Windows下go+vscode的环境配置&quot;&gt;&lt;/a&gt;Windows下go+vscode的环境
      
    
    </summary>
    
      <category term="go" scheme="http://TokeyRoad.github.io/categories/go/"/>
    
    
      <category term="环境配置" scheme="http://TokeyRoad.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>优先队列priority_queue</title>
    <link href="http://TokeyRoad.github.io/2020/12/30/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97priority-queue/"/>
    <id>http://TokeyRoad.github.io/2020/12/30/优先队列priority-queue/</id>
    <published>2020-12-30T01:40:48.000Z</published>
    <updated>2020-12-30T03:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><p>priority_queue是个大顶堆容器适配器，提供常数时间级的最大元素查找，对数代价的插入与删除。</p><p>成员函数有 判空(empty)、容量(size)、栈顶元素(top)、压栈(push)、出栈(pop)等。</p><p><strong>头文件</strong> </p><p>#include<queue></queue></p><p><strong>声明方式</strong></p><ol><li><p>默认</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;<span class="comment">//添加元素之后，元素从大到小的顺序出队</span></span><br><span class="line">   <span class="comment">//等价于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; q; </span></span><br><span class="line">   priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;<span class="comment">//元素从小到大的顺序出队</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>自定义优先级：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较函数return true 表示前者的优先级低于后者</span></span><br><span class="line"><span class="comment">//第一种写法：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">bool</span> <span class="params">()</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &gt; y;<span class="comment">//最小值优先</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, cmp&gt; q;</span><br><span class="line"><span class="comment">//第二种写法：</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x &gt; y; &#125;;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">decltype</span>(cmp)&gt; q(cmp);</span><br></pre></td></tr></table></figure></li><li><p>结构体声明方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">string</span> data;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> node&amp; a) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.x &gt; a.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; q;<span class="comment">//排序规则由 operator&lt; 中的实现决定</span></span><br></pre></td></tr></table></figure></li><li><p>注意：</p><p>结构体比较时通过自定义operator&lt; 操作符来比较元素中的优先级。</p><p>比较函数return true 表示前者的优先级低于后者</p></li></ol><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">print_queue</span><span class="params">(T&amp;q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; q.top() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">q.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">node(<span class="keyword">int</span> sid) &#123;</span><br><span class="line">id = sid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> data;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> node&amp; a) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;id &gt; a.id;<span class="comment">//最小值优先</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp_int1</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b;<span class="comment">//最小值优先</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp_int2</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; b;<span class="comment">//最大值优先</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_Priority_queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>&gt; q;<span class="comment">//从大到小</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>&#125;) &#123;</span><br><span class="line">q.push(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default: "</span>;</span><br><span class="line">print_queue(q);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt; &gt; q2;<span class="comment">//从小到大</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>&#125;) &#123;</span><br><span class="line">q2.push(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"greater: "</span>;</span><br><span class="line">print_queue(q2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较函数return true 表示前者的优先级低于后者</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](<span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123; <span class="keyword">return</span> left &gt; right; &#125;;</span><br><span class="line"><span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">decltype</span>(cmp)&gt; q3(cmp);<span class="comment">//从小到大</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>&#125;) &#123;</span><br><span class="line">q3.push(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lambda: "</span>;</span><br><span class="line">print_queue(q3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义比较函数</span></span><br><span class="line"><span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, cmp_int1&gt; q4;<span class="comment">//从小到大</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>&#125;) &#123;</span><br><span class="line">q4.push(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"cmp_int1: "</span>;</span><br><span class="line">print_queue(q4);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, cmp_int2&gt; q5;<span class="comment">//从小到大</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>&#125;) &#123;</span><br><span class="line">q5.push(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"cmp_int2: "</span>;</span><br><span class="line">print_queue(q5);</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义结构体</span></span><br><span class="line"><span class="built_in">std</span>::priority_queue&lt;node&gt; q6;</span><br><span class="line">node n1(4), n2(7), n3(1), n4(9);</span><br><span class="line">q6.push(n1);</span><br><span class="line">q6.push(n2);</span><br><span class="line">q6.push(n3);</span><br><span class="line">q6.push(n4);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"node operator&lt;: "</span>;</span><br><span class="line"><span class="keyword">while</span> (!q6.empty()) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; q6.top().id &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">q6.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output</span></span><br><span class="line"><span class="comment">default: 8 6 5 3 1</span></span><br><span class="line"><span class="comment">greater: 1 3 5 6 8</span></span><br><span class="line"><span class="comment">lambda: 1 3 5 6 8</span></span><br><span class="line"><span class="comment">cmp_int1: 1 3 5 6 8</span></span><br><span class="line"><span class="comment">cmp_int2: 8 6 5 3 1</span></span><br><span class="line"><span class="comment">node operator&lt;: 1 4 7 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;priority-queue&quot;&gt;&lt;a href=&quot;#priority-queue&quot; class=&quot;headerlink&quot; title=&quot;priority_queue&quot;&gt;&lt;/a&gt;priority_queue&lt;/h3&gt;&lt;p&gt;priority_queue是个大顶堆容器适
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="priority_queue" scheme="http://TokeyRoad.github.io/tags/priority-queue/"/>
    
  </entry>
  
  <entry>
    <title>设计模式六大原则</title>
    <link href="http://TokeyRoad.github.io/2020/12/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>http://TokeyRoad.github.io/2020/12/24/设计模式六大原则/</id>
    <published>2020-12-24T02:10:27.000Z</published>
    <updated>2020-12-24T02:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h3><h4 id="1-单一原则-Single-Responsibility-Principle"><a href="#1-单一原则-Single-Responsibility-Principle" class="headerlink" title="1. 单一原则(Single Responsibility Principle)"></a>1. 单一原则(Single Responsibility Principle)</h4><p>一个类或者一个方法只负责一项职责，尽量做到 类的只有一个行为原因引起变化；</p><p>业务对象（BO business object）、业务逻辑（BL business logic）拆分；</p><h4 id="2-里氏替换原则-LSP-liskov-substitution-principle"><a href="#2-里氏替换原则-LSP-liskov-substitution-principle" class="headerlink" title="2. 里氏替换原则(LSP liskov substitution principle)"></a>2. 里氏替换原则(LSP liskov substitution principle)</h4><p>子类可以扩展父类的功能，但不能改变原有父类的功能(C++的多态)；</p><p>为了增强程序的健壮性，在实际项目中，每个子类对应不同的业务含义，使父类作为参数，传递不同的子类完成不同的业务逻辑。</p><h4 id="3-依赖倒置原则-dependence-inversion-principle"><a href="#3-依赖倒置原则-dependence-inversion-principle" class="headerlink" title="3. 依赖倒置原则(dependence inversion principle)"></a>3. 依赖倒置原则(dependence inversion principle)</h4><p>面向接口编程；（通过接口作为参数实现应用场景）</p><p>抽象就是接口或者抽象类，细节就是实现类；</p><blockquote><p>上层模块不应该依赖下层模块，两者应该依赖其抽象；</p><p>抽象不应该依赖细节，细节应该依赖抽象；</p></blockquote><p>变量或者传参，尽量使用抽象类或者接口；</p><p>接口负责定义public属性和方法，并且申明与其他对象依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑；</p><h4 id="4-接口隔离-interface-segregation-principle"><a href="#4-接口隔离-interface-segregation-principle" class="headerlink" title="4. 接口隔离(interface segregation principle)"></a>4. 接口隔离(interface segregation principle)</h4><p>建立单一接口；（扩展为类也是一种接口，一切皆接口）</p><blockquote><p>a. 客户端不应该依赖它不需要的接口；</p><p>b. 类之间依赖关系应该建立在最小的接口上；</p></blockquote><p>复杂的接口，根据业务拆分成多个简单接口；</p><p>接口的设计粒度越小，系统越灵活，但是灵活的同时结构复杂性提高，开发难度大，维护性降低；</p><h4 id="5-迪米特原则-law-of-demeter-LOD"><a href="#5-迪米特原则-law-of-demeter-LOD" class="headerlink" title="5. 迪米特原则(law of demeter LOD)"></a>5. 迪米特原则(law of demeter LOD)</h4><p>最少知道原则，尽量降低类与类之间的耦合；</p><p>一个对象应该对其他对象有最少的了解；</p><h4 id="6-开闭原则-open-closed-principle"><a href="#6-开闭原则-open-closed-principle" class="headerlink" title="6. 开闭原则(open closed principle)"></a>6. 开闭原则(open closed principle)</h4><p>用抽象构建架构，用实现扩展原则；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;设计模式六大原则&quot;&gt;&lt;a href=&quot;#设计模式六大原则&quot; class=&quot;headerlink&quot; title=&quot;设计模式六大原则&quot;&gt;&lt;/a&gt;设计模式六大原则&lt;/h3&gt;&lt;h4 id=&quot;1-单一原则-Single-Responsibility-Principle&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="文档" scheme="http://TokeyRoad.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="设计模式" scheme="http://TokeyRoad.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>敏捷开发</title>
    <link href="http://TokeyRoad.github.io/2020/12/23/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    <id>http://TokeyRoad.github.io/2020/12/23/敏捷开发/</id>
    <published>2020-12-23T01:46:04.000Z</published>
    <updated>2020-12-23T02:43:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="敏捷开发步骤"><a href="#敏捷开发步骤" class="headerlink" title="敏捷开发步骤:"></a>敏捷开发步骤:</h3><h4 id="1-用户需求分析转化为产品BACKLOG"><a href="#1-用户需求分析转化为产品BACKLOG" class="headerlink" title="1. 用户需求分析转化为产品BACKLOG"></a>1. 用户需求分析转化为产品BACKLOG</h4><p>这部分主要由PM负责。</p><p>主要内容：用户调研，需求分析，确定产品迭代功能，出具产品BACKLOG，决定产品发布日期以及发布内容，给迭代计划预设目标，并排序优先级，考虑相应的风险。</p><h4 id="2-Sprint计划会议生成Sprint-BACKLOG"><a href="#2-Sprint计划会议生成Sprint-BACKLOG" class="headerlink" title="2. Sprint计划会议生成Sprint BACKLOG"></a>2. Sprint计划会议生成Sprint BACKLOG</h4><p>这部分主要由开发经理负责。</p><p>将产品BACKLOG拆分细化为Sprint BACKLOG。根据开发优先级管理Sprint BACKLOG，随时更新状态，每个团队成员可以自主挑选任务，修改Sprint BACKLOG。</p><h3 id="3-迭代开发周期，每日例会，交付迭代版本"><a href="#3-迭代开发周期，每日例会，交付迭代版本" class="headerlink" title="3. 迭代开发周期，每日例会，交付迭代版本"></a>3. 迭代开发周期，每日例会，交付迭代版本</h3><p>这部分由开发团队共同推进。</p><p>根据Sprint BACKLOG，开始开发工作，更新任务面板，参加每日例会，根据昨日进度，今日安排，所遇困难等快速梳理一遍面板上的工作任务，在会后对所遇困难进行讨论解决，保证整体开发进度。</p><p>优先级排序：一般分为三级。</p><blockquote><p>Must 必须做的</p><p>Should 应该做的</p><p>Could 可以做的</p></blockquote><p>要保证Must和Should必须完成，Could尽量去完成。在完不成时需要及时沟通，变更任务状态。</p><h3 id="4-验收发布版本，评审回顾会议，周期数据报表"><a href="#4-验收发布版本，评审回顾会议，周期数据报表" class="headerlink" title="4. 验收发布版本，评审回顾会议，周期数据报表"></a>4. 验收发布版本，评审回顾会议，周期数据报表</h3><p>这部分由开发团队共同完成。</p><p>开发团队通过操作演示的方式展示Sprint中完成的功能与架构。PM根据产品BACKLOG，验收开发交付的迭代版本，发布产品迭代版本。后续问题反馈，改善Sprint过程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;敏捷开发步骤&quot;&gt;&lt;a href=&quot;#敏捷开发步骤&quot; class=&quot;headerlink&quot; title=&quot;敏捷开发步骤:&quot;&gt;&lt;/a&gt;敏捷开发步骤:&lt;/h3&gt;&lt;h4 id=&quot;1-用户需求分析转化为产品BACKLOG&quot;&gt;&lt;a href=&quot;#1-用户需求分析转化为产品BA
      
    
    </summary>
    
      <category term="文档" scheme="http://TokeyRoad.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="敏捷开发" scheme="http://TokeyRoad.github.io/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>解决git每次推送都要输入用户名密码的方案</title>
    <link href="http://TokeyRoad.github.io/2020/11/22/%E8%A7%A3%E5%86%B3git%E6%AF%8F%E6%AC%A1%E6%8E%A8%E9%80%81%E9%83%BD%E8%A6%81%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E7%9A%84%E6%96%B9%E6%A1%88/"/>
    <id>http://TokeyRoad.github.io/2020/11/22/解决git每次推送都要输入用户名密码的方案/</id>
    <published>2020-11-22T15:08:41.000Z</published>
    <updated>2020-11-22T15:11:41.567Z</updated>
    
    <content type="html"><![CDATA[<p>打开命令行，输入以下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><p>执行完毕会在在当前系统用户文件夹下生成一个名为.git-credentials的文件，如：C:\Users\Administrator\ .git-credentials，再次提交代码时，输入密码后会将用户名密码以明文的方式保存在其中。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;打开命令行，输入以下命令:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=
      
    
    </summary>
    
      <category term="环境配置" scheme="http://TokeyRoad.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="git" scheme="http://TokeyRoad.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>重装系统之后hexo博客恢复</title>
    <link href="http://TokeyRoad.github.io/2020/11/22/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%90%8Ehexo%E5%8D%9A%E5%AE%A2%E6%81%A2%E5%A4%8D/"/>
    <id>http://TokeyRoad.github.io/2020/11/22/重装系统之后hexo博客恢复/</id>
    <published>2020-11-22T13:57:11.000Z</published>
    <updated>2020-12-21T08:03:12.611Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-安装node-js和git"><a href="#1-安装node-js和git" class="headerlink" title="1.安装node.js和git"></a>1.安装node.js和git</h3><p>这个不用多说，直接下载安装就行了。</p><h3 id="2-配置-git-个人信息，生成新的-ssh-密钥："><a href="#2-配置-git-个人信息，生成新的-ssh-密钥：" class="headerlink" title="2.配置 git 个人信息，生成新的 ssh 密钥："></a>2.配置 git 个人信息，生成新的 ssh 密钥：</h3><p>git config –global user.name “xxxxxx”<br> git config –global user.email “xxxxxx”<br> ssh-keygen -t rsa -C “xxxxxxxx(邮箱)”</p><h3 id="3-添加公钥"><a href="#3-添加公钥" class="headerlink" title="3.添加公钥"></a>3.添加公钥</h3><p>在用户文件夹.ssh 文件里面把公钥复制出来粘贴到github个人设置的ssh位置。</p><h3 id="4-安装hexo"><a href="#4-安装hexo" class="headerlink" title="4.安装hexo"></a>4.安装hexo</h3><p> npm install hexo-cli -g</p><h3 id="5-删除博客文件夹文件，保留部分"><a href="#5-删除博客文件夹文件，保留部分" class="headerlink" title="5.删除博客文件夹文件，保留部分"></a>5.删除博客文件夹文件，保留部分</h3><p>必须拷贝文件：<br> ├──_config.yml<br> ├── theme<br> ├── scaffolds #文章模板<br> ├── package.json #说明使用哪些包<br> ├── .gitignore #限定在提交的时候哪些文件可以忽略<br> └── source</p><p>（1）讨论下哪些文件是必须拷贝的：首先是之前自己修改的文件，像站点配置_config.yml，theme文件夹里面的主题，以及source里面自己写的博客文件，这些肯定要拷贝的。除此之外，还有三个文件需要有，就是scaffolds文件夹（文章的模板）、package.json（说明使用哪些包）和.gitignore（限定在提交的时候哪些文件可以忽略）。其实，这三个文件不是我们修改的，所以即使丢失了，也没有关系，我们可以建立一个新的文件夹，然后在里面执行hexo init，就会生成这三个文件，我们只需要将它们拷贝过来使用即可。总结：_config.yml，theme/，source/，scaffolds/，package.json，.gitignore，是需要拷贝的。</p><p>（2）再讨论下哪些文件是不必拷贝的，或者说可以删除的：首先是.git文件，无论是在站点根目录下，还是主题目录下的.git文件，都可以删掉。然后是文件夹node_modules（在用npm install会重新生成），public（这个在用hexo g时会重新生成），.deploy_git文件夹（在使用hexo d时也会重新生成），db.json文件。其实上面这些文件也就是是.gitignore文件里面记载的可以忽略的内容。总结：.git/，node_modules/，public/，.deploy_git/，db.json文件需要删除。</p><h3 id="6-git-bash"><a href="#6-git-bash" class="headerlink" title="6.git bash"></a>6.git bash</h3><p>在本文件夹下git bash,运行npm install</p><h3 id="7-安装部署插件-可选"><a href="#7-安装部署插件-可选" class="headerlink" title="7.安装部署插件(可选)"></a>7.安装部署插件(可选)</h3><p>npm install hexo-deployer-git –save</p><h3 id="8-测试"><a href="#8-测试" class="headerlink" title="8.测试"></a>8.测试</h3><p>此时就可以hexo g &amp;&amp; hexo d 测试是否成功了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-安装node-js和git&quot;&gt;&lt;a href=&quot;#1-安装node-js和git&quot; class=&quot;headerlink&quot; title=&quot;1.安装node.js和git&quot;&gt;&lt;/a&gt;1.安装node.js和git&lt;/h3&gt;&lt;p&gt;这个不用多说，直接下载安装就行了。&lt;
      
    
    </summary>
    
      <category term="环境配置" scheme="http://TokeyRoad.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="git" scheme="http://TokeyRoad.github.io/tags/git/"/>
    
      <category term="hexo" scheme="http://TokeyRoad.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>智能指针类</title>
    <link href="http://TokeyRoad.github.io/2020/05/29/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%B1%BB/"/>
    <id>http://TokeyRoad.github.io/2020/05/29/智能指针类/</id>
    <published>2020-05-29T02:00:55.000Z</published>
    <updated>2020-06-01T09:42:53.915Z</updated>
    
    <content type="html"><![CDATA[<h4 id="std-auto-ptr"><a href="#std-auto-ptr" class="headerlink" title="std::auto_ptr"></a>std::auto_ptr</h4><p>基本用法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种形式</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; ap1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//第二种形式</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; ap2;</span><br><span class="line">ap2.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>智能指针对象ap1和ap2均持有一个在堆上分配int对象，这两块堆内存在对象释放时得以释放。</p><p>std::auto_ptr 经常误用的是复制操作，当复制auto_ptr对象时(拷贝复制或operator=复制)，原对象的堆内存会转移到复制的对象上，原指针就空了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; ap1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//拷贝复制</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; ap2(ap1);</span><br><span class="line"><span class="keyword">if</span> (ap1.get()!= <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ap1 is not NULL"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ap1 is NULL"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ap2.get() != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ap2 is not NULL"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ap2 is NULL"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//operator=复制</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; ap3(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; ap4 = ap3;</span><br><span class="line"><span class="keyword">if</span> (ap3.get() != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ap3 is not NULL"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ap3 is NULL"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ap4.get() != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ap4 is not NULL"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ap4 is NULL"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">ap1 is <span class="literal">NULL</span></span><br><span class="line">ap2 is <span class="keyword">not</span> <span class="literal">NULL</span></span><br><span class="line">ap3 is <span class="literal">NULL</span></span><br><span class="line">ap4 is <span class="keyword">not</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p>ap1的堆内存转移到了ap2，ap3的堆内存转移到了ap4</p><p>因此在使用中，应尽量避免使用std::auto_ptr（C++11之后 该指针已被弃用，不应该再使用它）</p><h4 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h4><p>std::unique_ptr对指向的堆内存具有唯一控制权，引用计数永远为1，对象销毁时释放对应的堆内存。</p><p>基本使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种形式</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//第二种形式</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up2;</span><br><span class="line">up2.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//第三种形式</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up3 = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>注</p><blockquote><p>std::unique_ptr禁止复制操作</p><p>std::unique_ptr类的拷贝构造函数和赋值operator=函数 都被标记为=delete</p></blockquote><p>禁止复制操作存在特例，即可以通过一个函数返回一个std::unique_ptr：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; func(<span class="keyword">int</span> val) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up(<span class="keyword">new</span> <span class="keyword">int</span>(val));</span><br><span class="line"><span class="keyword">return</span> up;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up4 = func(<span class="number">3</span>);<span class="comment">//std::move</span></span><br></pre></td></tr></table></figure><p>实现方法：使用移动构造，即std::move</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up5(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up6(<span class="built_in">std</span>::move(up5));</span><br></pre></td></tr></table></figure><p>std::move将up5持有的堆内存转移给了up6，最后up5不再持有堆内存，即是一个空的智能指针对象。</p><p>std::move操作是否有意义，取决于是否实现了移动构造(Move Constructor)和移动赋值(operator=)运算符，而unique_ptr正好实现了这两个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Deletor&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unique_ptr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unique_ptr</span>(<span class="built_in">unique_ptr</span>&amp;&amp; rhs)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_pT = ths.m_pT;</span><br><span class="line">        rhs.m_pT = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unique_ptr</span>&amp; <span class="keyword">operator</span>=(<span class="built_in">unique_ptr</span>&amp;&amp; rhs)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_pT = rhs.m_pT;</span><br><span class="line">        rhs.m_pT = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* m_pT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::unique_ptr不仅可以持有一个堆对象，也可以持有一组堆对象，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>[]&gt; up7(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">up7[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; up7[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//std::unique_ptr&lt;int&gt; up8(std::move(up7[2]));//错误</span></span><br></pre></td></tr></table></figure><p>std::shared_ptr和std::weak_ptr也可以持有一组堆对象，用法与std::unique_ptr一致。</p><h5 id="自定义-智能指针对象持有的资源的释放函数"><a href="#自定义-智能指针对象持有的资源的释放函数" class="headerlink" title="自定义 智能指针对象持有的资源的释放函数"></a>自定义 智能指针对象持有的资源的释放函数</h5><p>默认情况下，智能指针对象在析构时只会释放其持有的堆内存，调用delete或delete[]，但是有些时候，不止要回收指针对象，还需要回收与该指针相关的其他内存，这时，就需要自定义智能指针的资源释放函数了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Student() &#123;</span><br><span class="line">name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(name, <span class="string">"abc"</span>);</span><br><span class="line">&#125;</span><br><span class="line">~Student() &#123;&#125;</span><br><span class="line">    <span class="comment">//这里应该把delete放入析构中，这里只是为了说明智能指针的相关用法才这么写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">delete</span>[] name;</span><br><span class="line">name = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span>* name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> releaseFunc = [](Student* ps)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ps-&gt;getName() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        ps-&gt;release();</span><br><span class="line">        <span class="keyword">delete</span> ps;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Student, <span class="keyword">void</span>(*)(Student* ps)&gt; pStudent(<span class="keyword">new</span> Student(), releaseFunc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义std::unique_ptr的资源释放函数规则是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T,DeletorFuncPtr&gt;</span><br></pre></td></tr></table></figure><p>其中T是要释放的对象类型，DeletorFuncPtr是自定义函数指针，这里可以使用decltype(releaseFunc)让编译器自行推导releaseFunc的类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Student, <span class="keyword">void</span>(*)(Student* ps)&gt; pStudent(<span class="keyword">new</span> Student(), releaseFunc);</span><br><span class="line">可改为</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Student, <span class="keyword">decltype</span>(releaseFunc))&gt; pStudent(<span class="keyword">new</span> Student(), releaseFunc);</span><br></pre></td></tr></table></figure><h4 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h4><p>std::unique_ptr对持有的资源具有独占性，而std::shared_ptr对持有的资源具有共享性，即多个shared_ptr可以同时持有同一个资源对象，每增加一个shared_ptr指向该对象，该对象的引用计数就+1，每析构一个，引用计数-1，当引用计数为0时，该对象被释放回收，多个线程之间，递增或者递减引用计数是安全的，但并不意味着，多个线程之间同时操作引用对象时安全的。std::shared_ptr提供一个use_count()方法来获取当前持有资源的引用计数。除此之外，其余的用法与std::unique_ptr基本相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//初始化2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2;</span><br><span class="line">sp2.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//初始化3</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp3 = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>优先使用std::make_shared去初始化std::shared_ptr对象。</p><h5 id="std-enable-shared-from-this"><a href="#std-enable-shared-from-this" class="headerlink" title="std::enable_shared_from_this"></a>std::enable_shared_from_this</h5><p>在开发中，有时候需要在类中返回包裹当前对象（this）的std::shared_ptr对象给外部使用，有此需求的类只要继承自己的std::enable_shared_from_this<t>模板对象即可。</t></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;A&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A()&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~A() &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A destructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; getSelf() &#123;</span><br><span class="line"><span class="keyword">return</span> shared_from_this();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; sp4(<span class="keyword">new</span> A());</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; sp5 = sp4-&gt;getSelf();</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"use_count:"</span> &lt;&lt; sp4.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getSelf方法返回自身的std::shared_ptr对象，方法中直接返回shared_from_this()。</p><h5 id="陷阱一：不应该共享栈对象的this给智能指针对象"><a href="#陷阱一：不应该共享栈对象的this给智能指针对象" class="headerlink" title="陷阱一：不应该共享栈对象的this给智能指针对象"></a>陷阱一：不应该共享栈对象的this给智能指针对象</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与上文代码相同</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; sp5 = a.getSelf();</span><br><span class="line">    <span class="comment">//程序在该行崩溃</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"use_count:"</span> &lt;&lt; sp4.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>崩溃原因：智能指针是为了管理堆对象的，而a是栈对象，栈对象会在函数调用结束时自行销毁，不能通过shared_from_this交给智能指针管理。</p><p>智能指针最初的设计目的就是为了管理不会自动回收的堆内存的。</p><h5 id="陷阱二：避免std-enable-shared-from-this的循环引用问题"><a href="#陷阱二：避免std-enable-shared-from-this的循环引用问题" class="headerlink" title="陷阱二：避免std::enable_shared_from_this的循环引用问题"></a>陷阱二：避免std::enable_shared_from_this的循环引用问题</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;B&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B() &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~B() &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B destructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">m_mySelf = shared_from_this();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;B&gt; m_mySelf;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;B&gt; sp6(<span class="keyword">new</span> B());</span><br><span class="line">sp6-&gt;func();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">B constructor</span><br></pre></td></tr></table></figure><p>根据输出可以发现对象B没有被回收，发生了内存泄漏，那么这是为什么呢？</p><p>sp6创建的时候 对象引用计数为1，之后调用func函数把自身的shared_ptr赋值给了类变量m_mySelf,此时引用计数为2，之后sp6对象被销毁，此时B的引用计数为1，不会被销毁，这时就出现了矛盾，B想要销毁就要引用计数减为0，就需要销毁m_mySelf，那么就必须要销毁B对象，这样B对象就无法销毁了。因此我们实际开发中应该避免出现这样的逻辑。</p><h5 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h5><p>std::weak_ptr是一个不控制资源生命周期的智能指针，是对对象的一种弱引用，只是提供了对其管理对象的一个访问手段，引入的目的是为了辅助shared_ptr工作。</p><p>std::weak_ptr可以从一个std::shared_ptr或另一个std::weak_ptr对象构造，std::shared_ptr可以直接复制给std::weak_ptr，weak_ptr可以通过lock()方法获取shared_ptr，它的构造和析构不会引起引用计数的变化，weak_ptr可用于解决shared_ptr引用计数循环的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp1 = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"use_count:"</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; wp2(sp1);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"use_count:"</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; wp3 = sp1;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"use_count:"</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; wp4(wp3);</span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; wp5 = wp3;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"use_count:"</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过lock()方法获得shared_ptr会增加引用计数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp6 = wp5.lock();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"use_count:"</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">use count: <span class="number">1</span></span><br><span class="line">use count: <span class="number">1</span></span><br><span class="line">use count: <span class="number">1</span></span><br><span class="line">use count: <span class="number">1</span></span><br><span class="line">use count: <span class="number">2</span></span><br></pre></td></tr></table></figure><p>weak_ptr不管对象的生命周期，当对象被销毁时，通过expired()方法来检测，返回true，表示对象已经不存在了；false表示对象还存在，此时可以通过lock()方法获取shared_ptr继续操作对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tmpPoint  ----&gt;std::weak_ptr&lt;Point&gt;</span></span><br><span class="line"><span class="keyword">if</span>(tmpPoint.expired())&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Point&gt; p = tmpPoint.lock();</span><br><span class="line"><span class="keyword">if</span>(p)&#123;</span><br><span class="line">    <span class="comment">//数据处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>weak_ptr没有重写operator-&gt;和operator*方法，所以不能直接操作对象，也没有重写operator!操作，所以也不能判断引用的资源是否存在。</p><p>weak_ptr不增加引用资源的引用计数来管理资源的生命周期，是因为，即使它实现了以上几个方法，调用他们是不安全的，因为在调用期间，引用的资源可能已经被销毁了。</p><p>weak_ptr的正确使用场景是那些资源如果可用就使用，不可用就不用的场景，它不参与资源的生命周期管理。</p><p>例如：在网络分层中，Session对象：利用Connection对象提供的服务工作，但是Session对象不管理Connection对象的生命周期，因为网络底层会有各种原因导致Connection对象销毁，如果Session强行持有Connection对象,会与事实矛盾。</p><p>经典示例：（订阅者模式 或者 观察者模式）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subscriber</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubscribeManager</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">publish</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; iter : m_subscirbers)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!iter.expired())&#123;</span><br><span class="line">                <span class="comment">//<span class="doctag">TODO:</span>Send Message to Subscriber</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::weak_ptr&lt;Subscriber&gt;&gt; m_subscirbers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="智能指针对象的大小"><a href="#智能指针对象的大小" class="headerlink" title="智能指针对象的大小"></a>智能指针对象的大小</h4><p>一个<strong>std::unique_ptr</strong>对象大小与一个裸指针大小相同，而<strong>std::shared_ptr</strong>对象的大小是<strong>std::unique_ptr</strong>大小的一倍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp0;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; sp1;</span><br><span class="line">sp1.reset(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>());</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2;</span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; sp3;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sp0 size: "</span> &lt;&lt; <span class="keyword">sizeof</span>(sp0) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sp1 size: "</span> &lt;&lt; <span class="keyword">sizeof</span>(sp1) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sp2 size: "</span> &lt;&lt; <span class="keyword">sizeof</span>(sp2) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sp3 size: "</span> &lt;&lt; <span class="keyword">sizeof</span>(sp3) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">sp0 size: <span class="number">8</span></span><br><span class="line">sp1 size: <span class="number">8</span></span><br><span class="line">sp2 size: <span class="number">4</span></span><br><span class="line">sp3 size: <span class="number">8</span></span><br></pre></td></tr></table></figure><h4 id="智能指针使用注意事项"><a href="#智能指针使用注意事项" class="headerlink" title="智能指针使用注意事项"></a>智能指针使用注意事项</h4><blockquote><ul><li>一旦一个对象使用智能指针管理后，就不该再使用原始裸指针去操作。</li><li>分清楚场合应该使用哪种类型的智能指针。</li><li>认真考虑，避免操作某个引用资源已经释放的智能指针。</li><li>作为类成员变量时，应该优先使用前置声明（forward declarations）。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;std-auto-ptr&quot;&gt;&lt;a href=&quot;#std-auto-ptr&quot; class=&quot;headerlink&quot; title=&quot;std::auto_ptr&quot;&gt;&lt;/a&gt;std::auto_ptr&lt;/h4&gt;&lt;p&gt;基本用法&lt;/p&gt;
&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="unique_ptr" scheme="http://TokeyRoad.github.io/tags/unique-ptr/"/>
    
      <category term="shared_ptr" scheme="http://TokeyRoad.github.io/tags/shared-ptr/"/>
    
  </entry>
  
  <entry>
    <title>原子操作类-atomic</title>
    <link href="http://TokeyRoad.github.io/2020/05/22/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB-atomic/"/>
    <id>http://TokeyRoad.github.io/2020/05/22/原子操作类-atomic/</id>
    <published>2020-05-22T03:29:15.000Z</published>
    <updated>2020-05-23T02:59:50.146Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 11 新标准中提供了对整形变量原子操作的相关库，即std::atomic,这是个模板类型：（同时支持跨平台）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">atomic</span>;</span></span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; ato_int;</span><br><span class="line">ato_int = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::atomic&lt;int&gt; ato_int = 1;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d \n"</span>, (<span class="keyword">int</span>)ato_int);</span><br><span class="line"></span><br><span class="line">++ato_int;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d \n"</span>, (<span class="keyword">int</span>)ato_int);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码在win和linux中都可以运行，但是如果这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//std::atomic&lt;int&gt; ato_int;</span></span><br><span class="line"><span class="comment">//ato_int = 1;</span></span><br><span class="line">   <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; ato_int = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>就只能在win下运行，linux编译无法通过。</p><p>错误原因是std::atomic的拷贝构造函数是默认=delete 禁止编译器生成的 g++遵循了，但是win上的vc++没有遵循。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atomic&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> atomic&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">方法说明</th></tr></thead><tbody><tr><td style="text-align:center">operator=</td><td style="text-align:center">存储值到对象</td></tr><tr><td style="text-align:center">store</td><td style="text-align:center">原子的以非原子对象替换原子对象的值</td></tr><tr><td style="text-align:center">load</td><td style="text-align:center">原子的获取原子对象的值</td></tr><tr><td style="text-align:center">exchange</td><td style="text-align:center">原子的替换原子对象的值并获得它先前替换的值</td></tr><tr><td style="text-align:center">compare_exchange_weak<br>compare_exchange_strong</td><td style="text-align:center">原子的比较原子对象非原子参数的值。若相等则交换，不相等则加载</td></tr><tr><td style="text-align:center">fetch_add</td><td style="text-align:center">原子的将参数加到原子对象的值，并返回先前的值</td></tr><tr><td style="text-align:center">fetch_sub</td><td style="text-align:center">原子的将原子对象的值减去参数，并返回先前的值</td></tr><tr><td style="text-align:center">fetch_and</td><td style="text-align:center">原子的进行参数和原子对象逐位与，并获得先前保存的值</td></tr><tr><td style="text-align:center">fetch_or</td><td style="text-align:center">原子的进行参数和原子对象逐位或，并获得先前保存的值</td></tr><tr><td style="text-align:center">fetch_xor</td><td style="text-align:center">原子的进行参数和原子对象逐位异或，并获得先前保存的值</td></tr><tr><td style="text-align:center">operator++ operator++(int) operator- operator-(int</td><td style="text-align:center">原子值增加或者减一</td></tr><tr><td style="text-align:center">operator+= operator-= operator&amp;= operator\</td><td style="text-align:center">= operator^=</td><td>=加减，=与原子值进行逐位与或异或</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C++ 11 新标准中提供了对整形变量原子操作的相关库，即std::atomic,这是个模板类型：（同时支持跨平台）&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="atomic" scheme="http://TokeyRoad.github.io/tags/atomic/"/>
    
  </entry>
  
  <entry>
    <title>线程资源同步对象-condition_variable</title>
    <link href="http://TokeyRoad.github.io/2020/05/20/%E7%BA%BF%E7%A8%8B%E8%B5%84%E6%BA%90%E5%90%8C%E6%AD%A5%E5%AF%B9%E8%B1%A1-condition-variable/"/>
    <id>http://TokeyRoad.github.io/2020/05/20/线程资源同步对象-condition-variable/</id>
    <published>2020-05-20T06:41:58.000Z</published>
    <updated>2020-05-21T08:23:41.093Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 11提供了std::condition_variable这个类 代表条件变量，与Linux系统原生的条件变量一样，同时还提供了等待条件变量的一系列wait方法(wait/wait_for/wait_until)，发送信号使用notify方法(notify_one/notify_all)，使用std::condition_variable时需要绑定到std::unique_lock或std::lock_guard对象。</p><blockquote><p>C++ 11中 std::condition_variable 不再需要显示调用方法初始化和销毁</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Task(<span class="keyword">int</span> id) &#123;</span><br><span class="line">m_taskID = id;</span><br><span class="line">&#125;</span><br><span class="line">~Task() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"do task,taskID:"</span> &lt;&lt; m_taskID &lt;&lt; <span class="string">", threadID:"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_taskID;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mutex;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;Task*&gt; tasks;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">produce_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Task* pTask = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> taskID = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">pTask = <span class="keyword">new</span> Task(taskID);</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lg(mutex);</span><br><span class="line">tasks.push_back(pTask);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"produce a task,taskID:"</span> &lt;&lt; taskID &lt;&lt; <span class="string">",threadID:"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">cv.notify_all();</span><br><span class="line">taskID++;</span><br><span class="line"><span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consume_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Task* pTask = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> taskID = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; guard(mutex);</span><br><span class="line"><span class="keyword">while</span> (tasks.empty()) &#123;</span><br><span class="line">cv.wait(guard);</span><br><span class="line">&#125;</span><br><span class="line">pTask = tasks.front();</span><br><span class="line">tasks.pop_front();</span><br><span class="line"><span class="keyword">if</span> (pTask == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">pTask-&gt;DoTask();</span><br><span class="line"><span class="keyword">delete</span> pTask;</span><br><span class="line">pTask = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::thread consume1 = <span class="built_in">std</span>::thread(consume_thread);</span><br><span class="line"><span class="built_in">std</span>::thread consume2 = <span class="built_in">std</span>::thread(consume_thread);</span><br><span class="line"><span class="built_in">std</span>::thread consume3 = <span class="built_in">std</span>::thread(consume_thread);</span><br><span class="line"><span class="built_in">std</span>::thread consume4 = <span class="built_in">std</span>::thread(consume_thread);</span><br><span class="line"><span class="built_in">std</span>::thread consume5 = <span class="built_in">std</span>::thread(consume_thread);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::thread produce1 = <span class="built_in">std</span>::thread(produce_thread);</span><br><span class="line"><span class="comment">//std::thread produce2 = std::thread(produce_thread);</span></span><br><span class="line"><span class="comment">//std::thread produce3 = std::thread(produce_thread);</span></span><br><span class="line"></span><br><span class="line">consume1.join();</span><br><span class="line">consume2.join();</span><br><span class="line">consume3.join();</span><br><span class="line">consume4.join();</span><br><span class="line">consume5.join();</span><br><span class="line">produce1.join();</span><br><span class="line"><span class="comment">//produce2.join();</span></span><br><span class="line"><span class="comment">//produce3.join();</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line">produce a task,taskID:<span class="number">0</span>,threadID:<span class="number">19444</span></span><br><span class="line"><span class="keyword">do</span> task,taskID:<span class="number">0</span>, threadID:<span class="number">6344</span></span><br><span class="line">produce a task,taskID:<span class="number">1</span>,threadID:<span class="number">19444</span></span><br><span class="line"><span class="keyword">do</span> task,taskID:<span class="number">1</span>, threadID:<span class="number">6352</span></span><br><span class="line">produce a task,taskID:<span class="number">2</span>,threadID:<span class="number">19444</span></span><br><span class="line"><span class="keyword">do</span> task,taskID:<span class="number">2</span>, threadID:<span class="number">4836</span></span><br><span class="line">produce a task,taskID:<span class="number">3</span>,threadID:<span class="number">19444</span></span><br><span class="line"><span class="keyword">do</span> task,taskID:<span class="number">3</span>, threadID:<span class="number">6352</span></span><br><span class="line">produce a task,taskID:<span class="number">4</span>,threadID:<span class="number">19444</span></span><br><span class="line"><span class="keyword">do</span> task,taskID:<span class="number">4</span>, threadID:<span class="number">6344</span></span><br><span class="line">produce a task,taskID:<span class="number">5</span>,threadID:<span class="number">19444</span></span><br><span class="line"><span class="keyword">do</span> task,taskID:<span class="number">5</span>, threadID:<span class="number">4836</span></span><br><span class="line">produce a task,taskID:<span class="number">6</span>,threadID:<span class="number">19444</span></span><br><span class="line"><span class="keyword">do</span> task,taskID:<span class="number">6</span>, threadID:<span class="number">13436</span></span><br><span class="line">produce a task,taskID:<span class="number">7</span>,threadID:<span class="number">19444</span></span><br><span class="line"><span class="keyword">do</span> task,taskID:<span class="number">7</span>, threadID:<span class="number">4836</span></span><br><span class="line">    .........</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C++ 11提供了std::condition_variable这个类 代表条件变量，与Linux系统原生的条件变量一样，同时还提供了等待条件变量的一系列wait方法(wait/wait_for/wait_until)，发送信号使用notify方法(notify_one/n
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="condition_variable" scheme="http://TokeyRoad.github.io/tags/condition-variable/"/>
    
  </entry>
  
  <entry>
    <title>线程资源同步对象-mutex</title>
    <link href="http://TokeyRoad.github.io/2020/05/20/%E7%BA%BF%E7%A8%8B%E8%B5%84%E6%BA%90%E5%90%8C%E6%AD%A5%E5%AF%B9%E8%B1%A1-mutex/"/>
    <id>http://TokeyRoad.github.io/2020/05/20/线程资源同步对象-mutex/</id>
    <published>2020-05-20T01:34:48.000Z</published>
    <updated>2020-05-20T06:43:30.233Z</updated>
    
    <content type="html"><![CDATA[<p>在C++ 11新标准中新增了线程资源同步对象：std::mutex 和 std::condition_variable 。</p><h5 id="std-mutex-系列"><a href="#std-mutex-系列" class="headerlink" title="std::mutex 系列"></a>std::mutex 系列</h5><p>C++ 11/14/17中提供了如下mutex系列类型：</p><table><thead><tr><th style="text-align:center">互斥量</th><th style="text-align:center">版本</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">mutex</td><td style="text-align:center">C++ 11</td><td style="text-align:center">最基本的互斥量</td></tr><tr><td style="text-align:center">timed_mutex</td><td style="text-align:center">C++ 11</td><td style="text-align:center">有超时机制的互斥量</td></tr><tr><td style="text-align:center">recursive_mutex</td><td style="text-align:center">C++ 11</td><td style="text-align:center">可重入的互斥量</td></tr><tr><td style="text-align:center">recursive_timed_mutex</td><td style="text-align:center">C++ 11</td><td style="text-align:center">结合timed_mutex和recursive_mutex特点的互斥量</td></tr><tr><td style="text-align:center">shared_timed_mutex</td><td style="text-align:center">C++ 14</td><td style="text-align:center">具有超时机制的可共享互斥量</td></tr><tr><td style="text-align:center">shared_mutex</td><td style="text-align:center">C++ 17</td><td style="text-align:center">共享的互斥量</td></tr></tbody></table><p>这个系列的对象均提供了加锁(lock)、尝试加锁(trylock) 和 解锁(unlock) 的方法。</p><p>为了避免死锁， std::mutex.lock() 和 std::mutex.unlock() 需要成对使用，同时C++11提供了一些互斥量管理的封装方法，避免忘记unlock而造成死锁。</p><table><thead><tr><th style="text-align:center">互斥量管理</th><th style="text-align:center">版本</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">lock_guard</td><td style="text-align:center">C++ 11</td><td style="text-align:center">基于作用域的互斥量管理</td></tr><tr><td style="text-align:center">unique_lock</td><td style="text-align:center">C++ 11</td><td style="text-align:center">更加灵活的互斥量管理</td></tr><tr><td style="text-align:center">shared_lock</td><td style="text-align:center">C++ 14</td><td style="text-align:center">共享互斥量的管理</td></tr><tr><td style="text-align:center">scope_lock</td><td style="text-align:center">C++ 17</td><td style="text-align:center">多互斥量避免死锁的管理</td></tr></tbody></table><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lg(mymutex);</span><br><span class="line"><span class="comment">//保护的资源操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：mymutex的声明周期必须比函数func的作用域长。</p><p>错误示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误写法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lg(mymutex);</span><br><span class="line"><span class="comment">//保护的资源操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写是错误的，当跳出func作用域时，m已经失效，这时lg析构解锁的时候，会出现未定义的行为。</p><p>此外，如果一个std::mutex对象已经调用lock()方法，再次调用时,会出现未定义的行为(Windows)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line">m.lock();</span><br><span class="line">m.lock();<span class="comment">//程序在这里崩溃</span></span><br><span class="line"><span class="comment">//bool re = m.try_lock();</span></span><br><span class="line"><span class="comment">//std::cout &lt;&lt; re &lt;&lt; std::endl;//output 0</span></span><br><span class="line">m.unlock();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，对于一个已经调用lock()方法再次调用lock()方法的做法是错误的。</p><h5 id="std-shared-mutex"><a href="#std-shared-mutex" class="headerlink" title="std::shared_mutex"></a>std::shared_mutex</h5><p>std::shared_mutex底层实现主要原理是操作系统提供的读写锁，在存在多个线程对公共资源读，少部分线程对公共资源写的情况下，std::shared_mutex 比 std::mutex效率更高。</p><p>std::shared_mutex提供了lock_shared()和unlock_shared()方法 获取读锁和写锁，写锁通常被称为 排他锁(Exclusive Locking)，读锁常被称为 共享锁(Shared Locking)。</p><p>同时C++ 新标准中引入了 std::unique_lock 和 std::shared_lock 用于进入作用域自动加锁，离开作用域自动解锁，前者用于写锁，后者用于读锁。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_mutex_counter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">shared_mutex_counter() = <span class="keyword">default</span>;</span><br><span class="line">~shared_mutex_counter() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::shared_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; sl(_shared_mutex);</span><br><span class="line"><span class="keyword">return</span> _value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increse</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; sl(_shared_mutex);</span><br><span class="line">++_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; sl(_shared_mutex);</span><br><span class="line">_value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::shared_mutex _shared_mutex;</span><br><span class="line"><span class="comment">//共享数据</span></span><br><span class="line"><span class="keyword">int</span> _value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOOP_COUNT 5000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_COUNT 8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_shared_mutex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">shared_mutex_counter shared_counter;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> readr = [&amp;shared_counter, &amp;result]() &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LOOP_COUNT; ++i) &#123;</span><br><span class="line">result = shared_counter.get();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> start = clock();</span><br><span class="line"><span class="keyword">auto</span> writer = [&amp;shared_counter]() &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LOOP_COUNT; ++i) &#123;</span><br><span class="line">shared_counter.increse();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::thread** tarray = <span class="keyword">new</span> <span class="built_in">std</span>::thread*[THREAD_COUNT];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; ++i) &#123;</span><br><span class="line">tarray[i] = <span class="keyword">new</span> <span class="built_in">std</span>::thread(readr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::thread* tw = <span class="keyword">new</span> <span class="built_in">std</span>::thread(writer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; ++i) &#123;</span><br><span class="line">tarray[i]-&gt;join();</span><br><span class="line">&#125;</span><br><span class="line">tw-&gt;join();</span><br><span class="line"><span class="keyword">clock_t</span> end = clock();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[test_shared_mutex] thread_count:%d\n"</span>, THREAD_COUNT);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"count_value:%d, cost:%dms, result:%d"</span>, shared_counter.get(), end - start, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">test_shared_mutex();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">[test_shared_mutex] thread_count:<span class="number">8</span></span><br><span class="line">count_value:<span class="number">5000000</span>, cost:<span class="number">5030</span>ms, result:<span class="number">2522449</span></span><br></pre></td></tr></table></figure><p>另外一个mutex的测试案例不再列出，跟shared_mutex类似。但是两者效率差距较大。</p><p>如果条件允许，可以根据使用场景，用shared_mutex替换mutex，可以提高很大的效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在C++ 11新标准中新增了线程资源同步对象：std::mutex 和 std::condition_variable 。&lt;/p&gt;
&lt;h5 id=&quot;std-mutex-系列&quot;&gt;&lt;a href=&quot;#std-mutex-系列&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="mutex" scheme="http://TokeyRoad.github.io/tags/mutex/"/>
    
  </entry>
  
  <entry>
    <title>stl容器新增的实用方法</title>
    <link href="http://TokeyRoad.github.io/2020/05/19/stl%E5%AE%B9%E5%99%A8%E6%96%B0%E5%A2%9E%E7%9A%84%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://TokeyRoad.github.io/2020/05/19/stl容器新增的实用方法/</id>
    <published>2020-05-19T03:44:34.000Z</published>
    <updated>2020-05-19T09:33:43.909Z</updated>
    
    <content type="html"><![CDATA[<h4 id="emplace系列函数"><a href="#emplace系列函数" class="headerlink" title="emplace系列函数"></a>emplace系列函数</h4><p>先上一段常用的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Test(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">m_a = a;</span><br><span class="line">m_b = b;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Test constructed"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Test() &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_a &lt;&lt; <span class="string">" Test destructed"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test(<span class="keyword">const</span> Test&amp; t) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;t) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = t.m_a;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_b = t.m_b;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_a &lt;&lt; <span class="string">" Test copy-constructed"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_a;</span><br><span class="line"><span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Test&gt; vec;</span><br><span class="line">vec.reserve(<span class="number">20</span>);<span class="comment">//，提前分好内存 避免vector的内存重分配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line"><span class="function">Test <span class="title">t</span><span class="params">(i, i + <span class="number">1</span>)</span></span>;</span><br><span class="line">vec.push_back(t);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">Test constructed</span><br><span class="line"><span class="number">0</span> Test copy-constructed</span><br><span class="line"><span class="number">0</span> Test destructed</span><br><span class="line">Test constructed</span><br><span class="line"><span class="number">1</span> Test copy-constructed</span><br><span class="line"><span class="number">1</span> Test destructed</span><br><span class="line">Test constructed</span><br><span class="line"><span class="number">2</span> Test copy-constructed</span><br><span class="line"><span class="number">2</span> Test destructed</span><br></pre></td></tr></table></figure><p>在这个过程中，我们的目的是为了产生一个对象数组，为了产生3个对象,调用了3*3次，这个过程执行过程：创建对象t调用构造函数—&gt;调用对象t的拷贝构造函数放入集合—&gt;调用析构函数。</p><p>C++11 提供了一个新的方法代替emplace_back</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Test&gt; vec;</span><br><span class="line">vec.reserve(<span class="number">20</span>);<span class="comment">//，提前分好内存 避免vector的内存重分配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">vec.emplace_back(i, i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">Test constructed</span><br><span class="line">Test constructed</span><br><span class="line">Test constructed</span><br></pre></td></tr></table></figure><p>emplace操作被称为 “原位构造元素”</p><p>同理的方法 如下:</p><table><thead><tr><th style="text-align:center">原方法</th><th style="text-align:center">C++11 改进方法</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">push/insert</td><td style="text-align:center">emplace</td><td style="text-align:center">指定位置原位构造元素</td></tr><tr><td style="text-align:center">push_front</td><td style="text-align:center">emplace_front</td><td style="text-align:center">首部原位构造元素</td></tr><tr><td style="text-align:center">push_back</td><td style="text-align:center">emplace_back</td><td style="text-align:center">尾部原位构造元素</td></tr></tbody></table><h4 id="std-map的try-emplace-与-insert-or-assign方法"><a href="#std-map的try-emplace-与-insert-or-assign方法" class="headerlink" title="std::map的try_emplace 与 insert_or_assign方法"></a>std::map的try_emplace 与 insert_or_assign方法</h4><p>由于map中的key是唯一的，因此在开发中经常遇到往map中插入数据之前需要先验证key是否存在，C++17中map提供了一个try_emplace方法，该方法会检测指定的key是否存在，函数签名如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;iterator, bool&gt; <span class="title">try_emplace</span>(<span class="title">const</span> <span class="title">key_type</span>&amp; <span class="title">k</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;iterator, bool&gt; <span class="title">try_emplace</span>(<span class="title">key_type</span>&amp;&amp; <span class="title">k</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">iterator</span> <span class="title">try_emplace</span>(<span class="title">const_iterator</span> <span class="title">hint</span>, <span class="title">const</span> <span class="title">key_type</span>&amp; <span class="title">k</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">iterator</span> <span class="title">try_emplace</span>(<span class="title">const_iterator</span> <span class="title">hint</span>, <span class="title">key_type</span>&amp;&amp; <span class="title">k</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure><p>其中k表示需要插入的key，args不定参数表示构造value对象所需的参数列表，hint表示插入位置。</p><p>前两种形式中，返回值是std::pair&lt;T1,T2&gt;，其中T2是个bool表示，当前插入操作成功与否，T1是一个迭代器，如果插入成功，则指向插入位置的元素迭代器，如果失败，则指向相同key元素的迭代器。 </p><p>后两种不常用，在map中插入时很少关心插入位置。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; m;</span><br><span class="line">m.emplace(<span class="string">"aaa"</span>, <span class="string">"ONE"</span>);</span><br><span class="line">m.emplace(<span class="string">"bbb"</span>, <span class="string">"TWO"</span>);</span><br><span class="line">m.emplace(<span class="string">"ccc"</span>, <span class="string">"THREE"</span>);</span><br><span class="line">m.emplace(<span class="string">"ddd"</span>, <span class="string">"FOUR"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> res = m.try_emplace(<span class="string">"eee"</span>, <span class="string">"FIVE"</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; res.first-&gt;second.c_str() &lt;&lt; <span class="string">" "</span> &lt;&lt; res.second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"map size:"</span> &lt;&lt; m.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : m) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter.first &lt;&lt; iter.second &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> resf = m.try_emplace(<span class="string">"aaa"</span>, <span class="string">"SIX"</span>);<span class="comment">//auto -&gt; std::pair&lt;std::map&lt;std::string, std::string&gt;::iterator, bool&gt;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; resf.first-&gt;second.c_str() &lt;&lt; <span class="string">" "</span> &lt;&lt; resf.second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : m) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter.first &lt;&lt; iter.second &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = m.try_emplace(m.begin(), <span class="string">"fff"</span>, <span class="string">"SEVEN"</span>);<span class="comment">////auto -&gt; std::map&lt;std::string, std::string&gt;::iterator</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : m) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter.first &lt;&lt; iter.second &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">FIVE <span class="number">1</span></span><br><span class="line"><span class="built_in">map</span> size:<span class="number">5</span></span><br><span class="line">aaaONE bbbTWO cccTHREE dddFOUR eeeFIVE</span><br><span class="line">ONE <span class="number">0</span></span><br><span class="line">aaaONE bbbTWO cccTHREE dddFOUR eeeFIVE</span><br><span class="line">fffSEVEN</span><br><span class="line">aaaONE bbbTWO cccTHREE dddFOUR eeeFIVE fffSEVEN</span><br></pre></td></tr></table></figure><p>try_emplace是map中指定的key存在就失败，不存在就插入，还有另一个方法insert_or_assign 当key存在时就更新value，不存在时就插入。</p><p>insert_or_assign函数签名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">M</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;iterator, bool&gt; <span class="title">insert_or_assign</span>(<span class="title">const</span> <span class="title">key_type</span>&amp; <span class="title">k</span>, <span class="title">M</span>&amp;&amp; <span class="title">obj</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">M</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;iterator, bool&gt; <span class="title">insert_or_assign</span>(<span class="title">key_type</span>&amp;&amp; <span class="title">k</span>, <span class="title">M</span>&amp;&amp; <span class="title">obj</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">M</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">iterator</span> <span class="title">insert_or_assign</span>(<span class="title">const_iterator</span> <span class="title">hint</span>, <span class="title">const</span> <span class="title">key_type</span>&amp; <span class="title">k</span>, <span class="title">M</span>&amp;&amp; <span class="title">obj</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">M</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">iterator</span> <span class="title">insert_or_assign</span>(<span class="title">const_iterator</span> <span class="title">hint</span>, <span class="title">key_type</span>&amp;&amp; <span class="title">k</span>, <span class="title">M</span>&amp;&amp; <span class="title">obj</span>);</span></span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; m;</span><br><span class="line">m.emplace(<span class="string">"aaa"</span>, <span class="string">"ONE"</span>);</span><br><span class="line">m.emplace(<span class="string">"bbb"</span>, <span class="string">"TWO"</span>);</span><br><span class="line">m.emplace(<span class="string">"ccc"</span>, <span class="string">"THREE"</span>);</span><br><span class="line">m.emplace(<span class="string">"ddd"</span>, <span class="string">"FOUR"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : m) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter.first &lt;&lt; iter.second &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">m.insert_or_assign(<span class="string">"aaa"</span>, <span class="string">"EIGHT"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : m) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter.first &lt;&lt; iter.second &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">aaaONE bbbTWO cccTHREE dddFOUR</span><br><span class="line">aaaEIGHT bbbTWO cccTHREE dddFOUR</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;emplace系列函数&quot;&gt;&lt;a href=&quot;#emplace系列函数&quot; class=&quot;headerlink&quot; title=&quot;emplace系列函数&quot;&gt;&lt;/a&gt;emplace系列函数&lt;/h4&gt;&lt;p&gt;先上一段常用的代码：&lt;/p&gt;
&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="stl" scheme="http://TokeyRoad.github.io/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>foreach循环</title>
    <link href="http://TokeyRoad.github.io/2020/05/18/foreach%E5%BE%AA%E7%8E%AF/"/>
    <id>http://TokeyRoad.github.io/2020/05/18/foreach循环/</id>
    <published>2020-05-18T06:36:54.000Z</published>
    <updated>2020-05-18T07:21:15.419Z</updated>
    
    <content type="html"><![CDATA[<h4 id="for-each"><a href="#for-each" class="headerlink" title="for-each"></a>for-each</h4><p>C++ 11之后才开始支持for-each语法。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; v_str;</span><br><span class="line">v_str.push_back(<span class="string">"aaa"</span>);</span><br><span class="line">v_str.push_back(<span class="string">"bbb"</span>);</span><br><span class="line">v_str.push_back(<span class="string">"ccc"</span>);</span><br><span class="line">v_str.push_back(<span class="string">"ddd"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : v_str) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter.c_str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><blockquote><ol><li>for-each中的迭代器类型与数组或集合中的元素类型完全一致，而stl容器中的迭代器是类型的取地址类型即指针，因此对于上面的例子中，iter是string类型；如果用stl迭代器，那就是指向string的指针。</li><li>for-each对于复杂数据类型，迭代器是原始数据的拷贝，而不是引用，在这个过程中会额外调用构造函数的开销，必要的时候可以使用<code>auto&amp; iter</code> 而不是 <code>auto iter</code> 这样就是原始数据的引用了。</li></ol></blockquote><p>示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; v_str;</span><br><span class="line">v_str.push_back(<span class="string">"aaa"</span>);</span><br><span class="line">v_str.push_back(<span class="string">"bbb"</span>);</span><br><span class="line">v_str.push_back(<span class="string">"ccc"</span>);</span><br><span class="line">v_str.push_back(<span class="string">"ddd"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : v_str) &#123;</span><br><span class="line">iter = <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : v_str) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter.c_str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br><span class="line">ddd</span><br></pre></td></tr></table></figure><p>修改后</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; v_str;</span><br><span class="line">v_str.push_back(<span class="string">"aaa"</span>);</span><br><span class="line">v_str.push_back(<span class="string">"bbb"</span>);</span><br><span class="line">v_str.push_back(<span class="string">"ccc"</span>);</span><br><span class="line">v_str.push_back(<span class="string">"ddd"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; iter : v_str) &#123;</span><br><span class="line">iter = <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : v_str) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter.c_str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><h4 id="自定义对象使用for-each（Range-based）"><a href="#自定义对象使用for-each（Range-based）" class="headerlink" title="自定义对象使用for-each（Range-based）"></a>自定义对象使用for-each（Range-based）</h4><p>for-each的lterator类型必须支持如下三种操作:</p><blockquote><p>operator++操作，即自增，可以自增返回下一个迭代子的位置</p><p>operator!=操作，即判不等</p><p>operator* 操作，即解引用</p></blockquote><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A() &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">m_elements[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~A() &#123;&#125;</span><br><span class="line"><span class="function">T* <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_elements + <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">T* <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_elements + N;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T m_elements[N];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里迭代子的类型是T* 本身就支持operator++ 和 operator!=操作，这里就不再实现</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A&lt;<span class="keyword">int</span>, <span class="number">10</span>&gt; arr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : arr) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;for-each&quot;&gt;&lt;a href=&quot;#for-each&quot; class=&quot;headerlink&quot; title=&quot;for-each&quot;&gt;&lt;/a&gt;for-each&lt;/h4&gt;&lt;p&gt;C++ 11之后才开始支持for-each语法。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="foreach" scheme="http://TokeyRoad.github.io/tags/foreach/"/>
    
  </entry>
  
  <entry>
    <title>在一个类中重载另一个类的构造函数</title>
    <link href="http://TokeyRoad.github.io/2020/05/12/%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%AD%E9%87%8D%E8%BD%BD%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>http://TokeyRoad.github.io/2020/05/12/在一个类中重载另一个类的构造函数/</id>
    <published>2020-05-12T02:51:53.000Z</published>
    <updated>2020-05-12T03:08:18.126Z</updated>
    
    <content type="html"><![CDATA[<h5 id="构造函数是一个特殊的操作符"><a href="#构造函数是一个特殊的操作符" class="headerlink" title="构造函数是一个特殊的操作符"></a>构造函数是一个特殊的操作符</h5><p>假如我们有两个类point 和 Cpoint</p><p>现在我们需要用类point去构造Cpoint对象，一般实现方式是在Cpoint中定义如下构造：</p><blockquote><p>Cpoint(point);</p></blockquote><a id="more"></a><p>但有些情况下，这个构造是无法定义的：</p><blockquote><ol><li>用point的私有成员给Cpoint赋值（可以添加get方法解决），point没有定义Cpoint为友元类；</li><li>没有权限修改Cpoint，只能修改point；</li></ol></blockquote><p>这里我们可以在point重载Cpoint的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Cpoint &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">Cpoint(int a) &#123;</span></span><br><span class="line"><span class="comment">_p = a;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">private:</span></span><br><span class="line"><span class="comment">int _p;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">Cpoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Cpoint(_c_point);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> _c_point;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>重载后，在需要point构造Cpoint时都会隐式的调用point中的重载构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">point p1;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Cpoint&gt; vec;</span><br><span class="line">vec.push_back(p1);<span class="comment">//这个过程就是 由p1隐式构造Cpoint对象存入vec</span></span><br></pre></td></tr></table></figure><p>完整测试源代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cpoint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Cpoint() &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cpoint:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">_p = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Cpoint(<span class="keyword">int</span> a) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cpoint_a:"</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">_p = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> _p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">point() &#123;</span><br><span class="line">_c_point = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"point::point:"</span> &lt;&lt; _c_point &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">Cpoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">_c_point = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"point::Cpoint:"</span> &lt;&lt; _c_point &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> _c_point;<span class="comment">//等价于 Cpoint(_c_point)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> _c_point;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">point p;</span><br><span class="line"><span class="function">Cpoint <span class="title">cp</span><span class="params">(p)</span></span>;</span><br><span class="line"></span><br><span class="line">point p1;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Cpoint&gt; vec;</span><br><span class="line">vec.push_back(p1);</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output：</span></span><br><span class="line"><span class="comment">point::point:1</span></span><br><span class="line"><span class="comment">point::Cpoint:3</span></span><br><span class="line"><span class="comment">Cpoint_a:3</span></span><br><span class="line"><span class="comment">point::point:1</span></span><br><span class="line"><span class="comment">point::Cpoint:3</span></span><br><span class="line"><span class="comment">Cpoint_a:3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;构造函数是一个特殊的操作符&quot;&gt;&lt;a href=&quot;#构造函数是一个特殊的操作符&quot; class=&quot;headerlink&quot; title=&quot;构造函数是一个特殊的操作符&quot;&gt;&lt;/a&gt;构造函数是一个特殊的操作符&lt;/h5&gt;&lt;p&gt;假如我们有两个类point 和 Cpoint&lt;/p&gt;
&lt;p&gt;现在我们需要用类point去构造Cpoint对象，一般实现方式是在Cpoint中定义如下构造：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Cpoint(point);&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="construct" scheme="http://TokeyRoad.github.io/tags/construct/"/>
    
      <category term="operator" scheme="http://TokeyRoad.github.io/tags/operator/"/>
    
  </entry>
  
  <entry>
    <title>可变参数 省略号的使用</title>
    <link href="http://TokeyRoad.github.io/2020/05/11/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0-%E7%9C%81%E7%95%A5%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://TokeyRoad.github.io/2020/05/11/可变参数-省略号的使用/</id>
    <published>2020-05-11T02:00:20.000Z</published>
    <updated>2020-05-11T03:14:27.490Z</updated>
    
    <content type="html"><![CDATA[<h4 id="函数参数的传递原理"><a href="#函数参数的传递原理" class="headerlink" title="函数参数的传递原理"></a>函数参数的传递原理</h4><p>函数参数是以数据结构：栈的形式存取，从右至左入栈。</p><p>首先是参数的内存存放格式：参数存放在内存的堆栈段，在执行函数的时候，从最后一个开始入栈。因此栈底高地址，栈顶低地址。</p><p>理论上来说，只要获取到一个参数的地址，就可以通过地址偏移获取到其他参数的地址。</p><a id="more"></a><h4 id="stdarg-h"><a href="#stdarg-h" class="headerlink" title="stdarg.h"></a>stdarg.h</h4><p>下面是&lt;stdarg.h&gt;里重要的几个宏定义：</p><blockquote><p>typedef char* va_list;</p><p>void va_start(va_list ap, prev_param);</p><p>void va_arg(va_list ap, type);</p><p>void va_end(va_list ap);</p></blockquote><p>va_list 是一个字符指针，指向当前参数，取参需要用这个指针进行。</p><blockquote><ol><li>在调用参数表之前，定义一个va_list类型的变量ap;</li><li>对ap初始化，使用va_start初始化，第一个参数就是ap，第二个参数是省略号前的那个已知参数；</li><li>获取参数值，使用va_arg获取对应的参数值，第一个参数就是ap，第二个参数是你要获取值的类型，返回对应的值，获取之后该函数会把ap指向下一个参数的地址；</li><li>获取完毕之后，需要关闭指针，使用va_end关闭，参数就是ap，会把ap置空，一般va_end和va_start成对使用。</li></ol></blockquote><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">argMax</span><span class="params">(<span class="keyword">int</span> count, ...)</span> </span>&#123;</span><br><span class="line">va_list ap;</span><br><span class="line">va_start(ap, count);</span><br><span class="line"><span class="keyword">int</span> cur_max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> t = va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, t);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == i) &#123;</span><br><span class="line">cur_max = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cur_max = t &gt; cur_max ? t : cur_max;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cur_max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>, d = <span class="number">4</span>, e = <span class="number">-2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n %d \n"</span>, argMax(<span class="number">5</span>, a, b, c, d, e));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1 2 3 4 -2</span></span><br><span class="line"><span class="comment"> 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;函数参数的传递原理&quot;&gt;&lt;a href=&quot;#函数参数的传递原理&quot; class=&quot;headerlink&quot; title=&quot;函数参数的传递原理&quot;&gt;&lt;/a&gt;函数参数的传递原理&lt;/h4&gt;&lt;p&gt;函数参数是以数据结构：栈的形式存取，从右至左入栈。&lt;/p&gt;
&lt;p&gt;首先是参数的内存存放格式：参数存放在内存的堆栈段，在执行函数的时候，从最后一个开始入栈。因此栈底高地址，栈顶低地址。&lt;/p&gt;
&lt;p&gt;理论上来说，只要获取到一个参数的地址，就可以通过地址偏移获取到其他参数的地址。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="args" scheme="http://TokeyRoad.github.io/tags/args/"/>
    
  </entry>
  
  <entry>
    <title>char*赋值给std::string的陷阱</title>
    <link href="http://TokeyRoad.github.io/2020/04/29/char%E8%B5%8B%E5%80%BC%E7%BB%99string%E7%9A%84%E9%99%B7%E9%98%B1/"/>
    <id>http://TokeyRoad.github.io/2020/04/29/char赋值给string的陷阱/</id>
    <published>2020-04-29T02:47:31.000Z</published>
    <updated>2020-05-06T01:28:48.443Z</updated>
    
    <content type="html"><![CDATA[<h5 id="char-赋值给std-string的一些陷阱"><a href="#char-赋值给std-string的一些陷阱" class="headerlink" title="char*赋值给std::string的一些陷阱"></a>char*赋值给std::string的一些陷阱</h5><ol><li><p>将char <em> 赋值给std::string如果不指定长度，则会默认以\0截断（ASCII码值为0）；如果指定长度超过char</em> 的长度，用std::cout系列的函数输出时，会把不属于char*之后的内存值打印出来，而对于printf系列的函数打印时，遇到\0会被截断，因而不能完全显示。这点在打印日志时，这类字符串需要注意。</p></li><li><p>如果是单个字符和一个字符串赋值给std::string 写法是有区别的：对于char，数目是第一个参数，对于char*，数目是第二个参数。</p><blockquote><p>string(const char* s, size_t n);</p><p>string(size_t n, char c);</p></blockquote><p>假定pstr是一个字符串，那么要写成string(pstr,n)；如果pstr是一个字符，那么要写成string(n,pstr)，而此时string(pstr, n)是一个错误的写法，可能会导致你的程序产生莫名其妙的问题，因为如果pstr是一个负值，负值转换成无符号整数size_t类型，n将非常大，会导致构造字符串时length非常大导致std::string 构造时抛出异常。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;char-赋值给std-string的一些陷阱&quot;&gt;&lt;a href=&quot;#char-赋值给std-string的一些陷阱&quot; class=&quot;headerlink&quot; title=&quot;char*赋值给std::string的一些陷阱&quot;&gt;&lt;/a&gt;char*赋值给std::str
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://TokeyRoad.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>strcmp实现</title>
    <link href="http://TokeyRoad.github.io/2020/04/28/strcmp%E5%AE%9E%E7%8E%B0/"/>
    <id>http://TokeyRoad.github.io/2020/04/28/strcmp实现/</id>
    <published>2020-04-28T01:54:39.000Z</published>
    <updated>2020-04-28T07:02:45.340Z</updated>
    
    <content type="html"><![CDATA[<h4 id="strcmp函数实现以及分析"><a href="#strcmp函数实现以及分析" class="headerlink" title="strcmp函数实现以及分析"></a>strcmp函数实现以及分析</h4><h5 id="strcmp函数原型"><a href="#strcmp函数原型" class="headerlink" title="strcmp函数原型"></a>strcmp函数原型</h5><blockquote><p>int strcmp(const char<em> str1, const char</em> str2);</p><p>str1 &lt; str2 返回负值或-1</p><p>str1 == str2 返回0</p><p>str1 &gt; str2 返回正值或1</p></blockquote><h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>该函数实际上是对字符的ASCII码进行比较，实现方案：从前往后依次比较两个字符串的字符，如果不相等，就停止比较并返回结果，如果相等就继续，直到其中一个字符串遇到结束符’\0’为止。</p><h5 id="Linux源码"><a href="#Linux源码" class="headerlink" title="Linux源码"></a>Linux源码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str1, <span class="keyword">const</span> <span class="keyword">char</span>* str2)</span></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c1, c2;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">c1 = *str1++;</span><br><span class="line">c2 = *str2++;</span><br><span class="line"><span class="keyword">if</span>(c1 != c2)<span class="keyword">return</span> (c1 &lt; c2) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!c1)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己用减法实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmpNew2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str1, <span class="keyword">const</span> <span class="keyword">char</span>* str2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!(ret = *(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)str1 - *(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)str2) &amp;&amp; *str1) &#123;</span><br><span class="line">str1++;</span><br><span class="line">str2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//if (ret &lt; 0)&#123;</span></span><br><span class="line"><span class="comment">//return -1;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//else if (ret &gt; 0)&#123;</span></span><br><span class="line"><span class="comment">//return 1;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//return 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>这个函数体内没有判断参数为NULL时的情况，所以当传入NULL时程序会崩溃，<string>中的strcmp也会崩溃</string></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;strcmp函数实现以及分析&quot;&gt;&lt;a href=&quot;#strcmp函数实现以及分析&quot; class=&quot;headerlink&quot; title=&quot;strcmp函数实现以及分析&quot;&gt;&lt;/a&gt;strcmp函数实现以及分析&lt;/h4&gt;&lt;h5 id=&quot;strcmp函数原型&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://TokeyRoad.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>产生dump文件</title>
    <link href="http://TokeyRoad.github.io/2020/04/28/%E4%BA%A7%E7%94%9Fdump%E6%96%87%E4%BB%B6/"/>
    <id>http://TokeyRoad.github.io/2020/04/28/产生dump文件/</id>
    <published>2020-04-28T01:31:07.000Z</published>
    <updated>2020-04-28T01:47:49.197Z</updated>
    
    <content type="html"><![CDATA[<h4 id="程序崩溃或发生异常时产生dump文件"><a href="#程序崩溃或发生异常时产生dump文件" class="headerlink" title="程序崩溃或发生异常时产生dump文件"></a>程序崩溃或发生异常时产生dump文件</h4><p>核心API是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CreateFile()</span><br><span class="line">MinDumpWriteDump()</span><br></pre></td></tr></table></figure><p>需要包含的头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;DbgHelp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"dbghelp.lib"</span>)</span></span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;DbgHelp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"dbghelp.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LONG WINAPI <span class="title">MyCustomUnhandledFilter</span><span class="params">(struct _EXCEPTION_POINTERS *lpExceptionInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LONG iRet = EXCEPTION_EXECUTE_HANDLER;</span><br><span class="line"></span><br><span class="line">TCHAR szDumpFileName[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">SYSTEMTIME st = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">GetLocalTime(&amp;st);</span><br><span class="line">wsprintf(szDumpFileName, <span class="string">"%04d-%02d-%02d-%02d-%02d-%02d.dmp"</span>, st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wMinute);</span><br><span class="line"></span><br><span class="line">HANDLE hDumpFile = CreateFile(szDumpFileName, GENERIC_WRITE, FILE_SHARE_READ, <span class="literal">NULL</span>, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hDumpFile == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">DWORD dwErrorID = GetLastError();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to create dump file, error ID: %d\n"</span>, dwErrorID);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> iRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MINIDUMP_EXCEPTION_INFORMATION MindumpExceptionInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">MindumpExceptionInfo.ThreadId = GetCurrentThreadId();</span><br><span class="line">MindumpExceptionInfo.ExceptionPointers = lpExceptionInfo;</span><br><span class="line">MindumpExceptionInfo.ClientPointers = FALSE;</span><br><span class="line"></span><br><span class="line">BOOL bRet = MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), hDumpFile, MiniDumpNormal, &amp;MindumpExceptionInfo, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Succeeded to create dump file!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to create dump file!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CloseHandle(hDumpFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> iRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crash</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = a;</span><br><span class="line"><span class="comment">//！！程序崩溃的地方</span></span><br><span class="line">i /= j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SetUnhandledExceptionFilter(MyCustomUnhandledFilter);</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">crash(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(buf, <span class="string">"123456789"</span>);</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;程序崩溃或发生异常时产生dump文件&quot;&gt;&lt;a href=&quot;#程序崩溃或发生异常时产生dump文件&quot; class=&quot;headerlink&quot; title=&quot;程序崩溃或发生异常时产生dump文件&quot;&gt;&lt;/a&gt;程序崩溃或发生异常时产生dump文件&lt;/h4&gt;&lt;p&gt;核心API是
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://TokeyRoad.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>vector resize与reserve区别</title>
    <link href="http://TokeyRoad.github.io/2020/04/27/vector-resize%E4%B8%8Ereserve%E5%8C%BA%E5%88%AB/"/>
    <id>http://TokeyRoad.github.io/2020/04/27/vector-resize与reserve区别/</id>
    <published>2020-04-27T06:43:13.000Z</published>
    <updated>2020-04-27T07:20:13.433Z</updated>
    
    <content type="html"><![CDATA[<p>std::vector的reserve和resize的区别</p><blockquote><ol><li>reserve：分配空间，更改capacity但不改变size。</li><li>resize：分配空间，更改capacity也改变size。</li></ol></blockquote><h4 id="函数作用"><a href="#函数作用" class="headerlink" title="函数作用"></a>函数作用</h4><p>reserve是容器预留空间，不会真正的去创建数组对象，在创建对象之前，不能引用容器内的元素，当加入新元素的时候使用push_bakc()/insert()函数。</p><p>resize是改变容器大小，并且创建对象，因此调用这个函数之后，就可以引用容器内的对象，加入新元素的时候可以使用operator[]操作符，或者引用迭代器来引用元素对象。</p><h4 id="函数形式"><a href="#函数形式" class="headerlink" title="函数形式"></a>函数形式</h4><p>reserve：一个参数，即需要预留的容器的空间；</p><p>resize：两个参数，第一个是容器新的大小，第二个是要加入容器中的新元素，如果这个参数被省略，                那么就调用元素对象的默认构造函数。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span> vec;</span><br><span class="line"><span class="comment">/*****reserve*****/</span></span><br><span class="line">vec.reserve(<span class="number">10</span>);<span class="comment">//新元素还没有构造</span></span><br><span class="line"><span class="comment">//此时不能用[]访问元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">vec.push_back(i);<span class="comment">//新元素这时才构造</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****resize****/</span></span><br><span class="line">vec.resize(<span class="number">12</span>);</span><br><span class="line">vec[<span class="number">10</span>] = <span class="number">1</span>;<span class="comment">//直接操作新元素</span></span><br><span class="line">vec[<span class="number">11</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>vector在内存中是连续分布的，所以设计的时候会在所有元素外预留一部分空间，否则每次新增元素都需要重新分配，那么效率将会很低。</p><p>假如vector中存在1000个元素，两种做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="built_in">std</span>::<span class="built_in">vector</span>， 循环调用<span class="number">1000</span>次push_back(将会进行大量次数的内存分配)</span><br><span class="line"><span class="number">2.</span> <span class="built_in">std</span>::<span class="built_in">vector</span>(<span class="number">1000</span>), 循环调用<span class="number">1000</span>次push_back(就只会进行几次内存分配)</span><br></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li>当前容器预留了多大的空间？（不进行内存重分配的情况下，可以容纳多少元素）</li><li>怎么重设容器的预留大小？</li></ol><p>获取预留空间capacity()</p><p>重设预留空间大小reserve()</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>resize()和reserve()是两回事，前者影响容器中元素个数，后者影响容器预留空间。</p><blockquote><p>假设vector vec;  size() = 50 capacity() = 100 那么：</p><ol><li>resize(10);//size() == 10  10–49下标的元素被删除,capacity()=100不变，没有内存重分配。</li><li>resize(60);//size()==60    50–59下标用默认构造函数填充,capacity()=100不变，没有内存重分配。</li><li>resize(60,999);//size()==60    50–59下标用999填充,capacity()=100不变，没有内存重分配。</li><li>resize(200);//size()==200    50–199下标用默认构造函数填充,capacity()=200,自动扩容，内存重分配。</li><li>reserve(10);//size()==50  不变，没有元素被删除，capacity()=100，不变，即reserve调用不起作用。</li><li>reserve(60);//size()==50  元素不变，capacity()=100，不变，即reserve调用不起作用。</li><li>reserve(200);//size()==50  元素不变，capacity()=200，扩容，内存重分配。</li></ol><p>vector vec(10); //size()==10;capacity()==10;</p><p>vec.push_back(999);//size()=11;capacity()=15;//自动扩容，capacity()的结果是不定的，也不一定是15。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;std::vector的reserve和resize的区别&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;reserve：分配空间，更改capacity但不改变size。&lt;/li&gt;
&lt;li&gt;resize：分配空间，更改capacity也改变size。&lt;/li&gt;
&lt;/o
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://TokeyRoad.github.io/tags/C/"/>
    
      <category term="STL" scheme="http://TokeyRoad.github.io/tags/STL/"/>
    
      <category term="vector" scheme="http://TokeyRoad.github.io/tags/vector/"/>
    
  </entry>
  
</feed>
