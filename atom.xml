<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TokeyRoad</title>
  
  <subtitle>Never underestimate your power to change yourself!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://TokeyRoad.github.io/"/>
  <updated>2020-12-30T03:33:00.000Z</updated>
  <id>http://TokeyRoad.github.io/</id>
  
  <author>
    <name>Tokey</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>优先队列priority_queue</title>
    <link href="http://TokeyRoad.github.io/2020/12/30/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97priority-queue/"/>
    <id>http://TokeyRoad.github.io/2020/12/30/优先队列priority-queue/</id>
    <published>2020-12-30T01:40:48.000Z</published>
    <updated>2020-12-30T03:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><p>priority_queue是个大顶堆容器适配器，提供常数时间级的最大元素查找，对数代价的插入与删除。</p><p>成员函数有 判空(empty)、容量(size)、栈顶元素(top)、压栈(push)、出栈(pop)等。</p><p><strong>头文件</strong> </p><p>#include<queue></queue></p><p><strong>声明方式</strong></p><ol><li><p>默认</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;<span class="comment">//添加元素之后，元素从大到小的顺序出队</span></span><br><span class="line">   <span class="comment">//等价于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; q; </span></span><br><span class="line">   priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;<span class="comment">//元素从小到大的顺序出队</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>自定义优先级：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较函数return true 表示前者的优先级低于后者</span></span><br><span class="line"><span class="comment">//第一种写法：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">bool</span> <span class="params">()</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &gt; y;<span class="comment">//最小值优先</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, cmp&gt; q;</span><br><span class="line"><span class="comment">//第二种写法：</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x &gt; y; &#125;;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">decltype</span>(cmp)&gt; q(cmp);</span><br></pre></td></tr></table></figure></li><li><p>结构体声明方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">string</span> data;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> node&amp; a) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.x &gt; a.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; q;<span class="comment">//排序规则由 operator&lt; 中的实现决定</span></span><br></pre></td></tr></table></figure></li><li><p>注意：</p><p>结构体比较时通过自定义operator&lt; 操作符来比较元素中的优先级。</p><p>比较函数return true 表示前者的优先级低于后者</p></li></ol><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">print_queue</span><span class="params">(T&amp;q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; q.top() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">q.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">node(<span class="keyword">int</span> sid) &#123;</span><br><span class="line">id = sid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> data;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> node&amp; a) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;id &gt; a.id;<span class="comment">//最小值优先</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp_int1</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b;<span class="comment">//最小值优先</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp_int2</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; b;<span class="comment">//最大值优先</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_Priority_queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>&gt; q;<span class="comment">//从大到小</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>&#125;) &#123;</span><br><span class="line">q.push(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default: "</span>;</span><br><span class="line">print_queue(q);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt; &gt; q2;<span class="comment">//从小到大</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>&#125;) &#123;</span><br><span class="line">q2.push(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"greater: "</span>;</span><br><span class="line">print_queue(q2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较函数return true 表示前者的优先级低于后者</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](<span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123; <span class="keyword">return</span> left &gt; right; &#125;;</span><br><span class="line"><span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">decltype</span>(cmp)&gt; q3(cmp);<span class="comment">//从小到大</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>&#125;) &#123;</span><br><span class="line">q3.push(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lambda: "</span>;</span><br><span class="line">print_queue(q3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义比较函数</span></span><br><span class="line"><span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, cmp_int1&gt; q4;<span class="comment">//从小到大</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>&#125;) &#123;</span><br><span class="line">q4.push(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"cmp_int1: "</span>;</span><br><span class="line">print_queue(q4);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, cmp_int2&gt; q5;<span class="comment">//从小到大</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>&#125;) &#123;</span><br><span class="line">q5.push(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"cmp_int2: "</span>;</span><br><span class="line">print_queue(q5);</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义结构体</span></span><br><span class="line"><span class="built_in">std</span>::priority_queue&lt;node&gt; q6;</span><br><span class="line">node n1(4), n2(7), n3(1), n4(9);</span><br><span class="line">q6.push(n1);</span><br><span class="line">q6.push(n2);</span><br><span class="line">q6.push(n3);</span><br><span class="line">q6.push(n4);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"node operator&lt;: "</span>;</span><br><span class="line"><span class="keyword">while</span> (!q6.empty()) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; q6.top().id &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">q6.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output</span></span><br><span class="line"><span class="comment">default: 8 6 5 3 1</span></span><br><span class="line"><span class="comment">greater: 1 3 5 6 8</span></span><br><span class="line"><span class="comment">lambda: 1 3 5 6 8</span></span><br><span class="line"><span class="comment">cmp_int1: 1 3 5 6 8</span></span><br><span class="line"><span class="comment">cmp_int2: 8 6 5 3 1</span></span><br><span class="line"><span class="comment">node operator&lt;: 1 4 7 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;priority-queue&quot;&gt;&lt;a href=&quot;#priority-queue&quot; class=&quot;headerlink&quot; title=&quot;priority_queue&quot;&gt;&lt;/a&gt;priority_queue&lt;/h3&gt;&lt;p&gt;priority_queue是个大顶堆容器适
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="priority_queue" scheme="http://TokeyRoad.github.io/tags/priority-queue/"/>
    
  </entry>
  
  <entry>
    <title>设计模式六大原则</title>
    <link href="http://TokeyRoad.github.io/2020/12/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>http://TokeyRoad.github.io/2020/12/24/设计模式六大原则/</id>
    <published>2020-12-24T02:10:27.000Z</published>
    <updated>2020-12-24T02:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h3><h4 id="1-单一原则-Single-Responsibility-Principle"><a href="#1-单一原则-Single-Responsibility-Principle" class="headerlink" title="1. 单一原则(Single Responsibility Principle)"></a>1. 单一原则(Single Responsibility Principle)</h4><p>一个类或者一个方法只负责一项职责，尽量做到 类的只有一个行为原因引起变化；</p><p>业务对象（BO business object）、业务逻辑（BL business logic）拆分；</p><h4 id="2-里氏替换原则-LSP-liskov-substitution-principle"><a href="#2-里氏替换原则-LSP-liskov-substitution-principle" class="headerlink" title="2. 里氏替换原则(LSP liskov substitution principle)"></a>2. 里氏替换原则(LSP liskov substitution principle)</h4><p>子类可以扩展父类的功能，但不能改变原有父类的功能(C++的多态)；</p><p>为了增强程序的健壮性，在实际项目中，每个子类对应不同的业务含义，使父类作为参数，传递不同的子类完成不同的业务逻辑。</p><h4 id="3-依赖倒置原则-dependence-inversion-principle"><a href="#3-依赖倒置原则-dependence-inversion-principle" class="headerlink" title="3. 依赖倒置原则(dependence inversion principle)"></a>3. 依赖倒置原则(dependence inversion principle)</h4><p>面向接口编程；（通过接口作为参数实现应用场景）</p><p>抽象就是接口或者抽象类，细节就是实现类；</p><blockquote><p>上层模块不应该依赖下层模块，两者应该依赖其抽象；</p><p>抽象不应该依赖细节，细节应该依赖抽象；</p></blockquote><p>变量或者传参，尽量使用抽象类或者接口；</p><p>接口负责定义public属性和方法，并且申明与其他对象依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑；</p><h4 id="4-接口隔离-interface-segregation-principle"><a href="#4-接口隔离-interface-segregation-principle" class="headerlink" title="4. 接口隔离(interface segregation principle)"></a>4. 接口隔离(interface segregation principle)</h4><p>建立单一接口；（扩展为类也是一种接口，一切皆接口）</p><blockquote><p>a. 客户端不应该依赖它不需要的接口；</p><p>b. 类之间依赖关系应该建立在最小的接口上；</p></blockquote><p>复杂的接口，根据业务拆分成多个简单接口；</p><p>接口的设计粒度越小，系统越灵活，但是灵活的同时结构复杂性提高，开发难度大，维护性降低；</p><h4 id="5-迪米特原则-law-of-demeter-LOD"><a href="#5-迪米特原则-law-of-demeter-LOD" class="headerlink" title="5. 迪米特原则(law of demeter LOD)"></a>5. 迪米特原则(law of demeter LOD)</h4><p>最少知道原则，尽量降低类与类之间的耦合；</p><p>一个对象应该对其他对象有最少的了解；</p><h4 id="6-开闭原则-open-closed-principle"><a href="#6-开闭原则-open-closed-principle" class="headerlink" title="6. 开闭原则(open closed principle)"></a>6. 开闭原则(open closed principle)</h4><p>用抽象构建架构，用实现扩展原则；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;设计模式六大原则&quot;&gt;&lt;a href=&quot;#设计模式六大原则&quot; class=&quot;headerlink&quot; title=&quot;设计模式六大原则&quot;&gt;&lt;/a&gt;设计模式六大原则&lt;/h3&gt;&lt;h4 id=&quot;1-单一原则-Single-Responsibility-Principle&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="文档" scheme="http://TokeyRoad.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="设计模式" scheme="http://TokeyRoad.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>敏捷开发</title>
    <link href="http://TokeyRoad.github.io/2020/12/23/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    <id>http://TokeyRoad.github.io/2020/12/23/敏捷开发/</id>
    <published>2020-12-23T01:46:04.000Z</published>
    <updated>2020-12-23T02:43:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="敏捷开发步骤"><a href="#敏捷开发步骤" class="headerlink" title="敏捷开发步骤:"></a>敏捷开发步骤:</h3><h4 id="1-用户需求分析转化为产品BACKLOG"><a href="#1-用户需求分析转化为产品BACKLOG" class="headerlink" title="1. 用户需求分析转化为产品BACKLOG"></a>1. 用户需求分析转化为产品BACKLOG</h4><p>这部分主要由PM负责。</p><p>主要内容：用户调研，需求分析，确定产品迭代功能，出具产品BACKLOG，决定产品发布日期以及发布内容，给迭代计划预设目标，并排序优先级，考虑相应的风险。</p><h4 id="2-Sprint计划会议生成Sprint-BACKLOG"><a href="#2-Sprint计划会议生成Sprint-BACKLOG" class="headerlink" title="2. Sprint计划会议生成Sprint BACKLOG"></a>2. Sprint计划会议生成Sprint BACKLOG</h4><p>这部分主要由开发经理负责。</p><p>将产品BACKLOG拆分细化为Sprint BACKLOG。根据开发优先级管理Sprint BACKLOG，随时更新状态，每个团队成员可以自主挑选任务，修改Sprint BACKLOG。</p><h3 id="3-迭代开发周期，每日例会，交付迭代版本"><a href="#3-迭代开发周期，每日例会，交付迭代版本" class="headerlink" title="3. 迭代开发周期，每日例会，交付迭代版本"></a>3. 迭代开发周期，每日例会，交付迭代版本</h3><p>这部分由开发团队共同推进。</p><p>根据Sprint BACKLOG，开始开发工作，更新任务面板，参加每日例会，根据昨日进度，今日安排，所遇困难等快速梳理一遍面板上的工作任务，在会后对所遇困难进行讨论解决，保证整体开发进度。</p><p>优先级排序：一般分为三级。</p><blockquote><p>Must 必须做的</p><p>Should 应该做的</p><p>Could 可以做的</p></blockquote><p>要保证Must和Should必须完成，Could尽量去完成。在完不成时需要及时沟通，变更任务状态。</p><h3 id="4-验收发布版本，评审回顾会议，周期数据报表"><a href="#4-验收发布版本，评审回顾会议，周期数据报表" class="headerlink" title="4. 验收发布版本，评审回顾会议，周期数据报表"></a>4. 验收发布版本，评审回顾会议，周期数据报表</h3><p>这部分由开发团队共同完成。</p><p>开发团队通过操作演示的方式展示Sprint中完成的功能与架构。PM根据产品BACKLOG，验收开发交付的迭代版本，发布产品迭代版本。后续问题反馈，改善Sprint过程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;敏捷开发步骤&quot;&gt;&lt;a href=&quot;#敏捷开发步骤&quot; class=&quot;headerlink&quot; title=&quot;敏捷开发步骤:&quot;&gt;&lt;/a&gt;敏捷开发步骤:&lt;/h3&gt;&lt;h4 id=&quot;1-用户需求分析转化为产品BACKLOG&quot;&gt;&lt;a href=&quot;#1-用户需求分析转化为产品BA
      
    
    </summary>
    
      <category term="文档" scheme="http://TokeyRoad.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="敏捷开发" scheme="http://TokeyRoad.github.io/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>解决git每次推送都要输入用户名密码的方案</title>
    <link href="http://TokeyRoad.github.io/2020/11/22/%E8%A7%A3%E5%86%B3git%E6%AF%8F%E6%AC%A1%E6%8E%A8%E9%80%81%E9%83%BD%E8%A6%81%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E7%9A%84%E6%96%B9%E6%A1%88/"/>
    <id>http://TokeyRoad.github.io/2020/11/22/解决git每次推送都要输入用户名密码的方案/</id>
    <published>2020-11-22T15:08:41.000Z</published>
    <updated>2020-11-22T15:11:41.567Z</updated>
    
    <content type="html"><![CDATA[<p>打开命令行，输入以下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><p>执行完毕会在在当前系统用户文件夹下生成一个名为.git-credentials的文件，如：C:\Users\Administrator\ .git-credentials，再次提交代码时，输入密码后会将用户名密码以明文的方式保存在其中。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;打开命令行，输入以下命令:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=
      
    
    </summary>
    
      <category term="环境配置" scheme="http://TokeyRoad.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="git" scheme="http://TokeyRoad.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>重装系统之后hexo博客恢复</title>
    <link href="http://TokeyRoad.github.io/2020/11/22/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%90%8Ehexo%E5%8D%9A%E5%AE%A2%E6%81%A2%E5%A4%8D/"/>
    <id>http://TokeyRoad.github.io/2020/11/22/重装系统之后hexo博客恢复/</id>
    <published>2020-11-22T13:57:11.000Z</published>
    <updated>2020-12-21T08:03:12.611Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-安装node-js和git"><a href="#1-安装node-js和git" class="headerlink" title="1.安装node.js和git"></a>1.安装node.js和git</h3><p>这个不用多说，直接下载安装就行了。</p><h3 id="2-配置-git-个人信息，生成新的-ssh-密钥："><a href="#2-配置-git-个人信息，生成新的-ssh-密钥：" class="headerlink" title="2.配置 git 个人信息，生成新的 ssh 密钥："></a>2.配置 git 个人信息，生成新的 ssh 密钥：</h3><p>git config –global user.name “xxxxxx”<br> git config –global user.email “xxxxxx”<br> ssh-keygen -t rsa -C “xxxxxxxx(邮箱)”</p><h3 id="3-添加公钥"><a href="#3-添加公钥" class="headerlink" title="3.添加公钥"></a>3.添加公钥</h3><p>在用户文件夹.ssh 文件里面把公钥复制出来粘贴到github个人设置的ssh位置。</p><h3 id="4-安装hexo"><a href="#4-安装hexo" class="headerlink" title="4.安装hexo"></a>4.安装hexo</h3><p> npm install hexo-cli -g</p><h3 id="5-删除博客文件夹文件，保留部分"><a href="#5-删除博客文件夹文件，保留部分" class="headerlink" title="5.删除博客文件夹文件，保留部分"></a>5.删除博客文件夹文件，保留部分</h3><p>必须拷贝文件：<br> ├──_config.yml<br> ├── theme<br> ├── scaffolds #文章模板<br> ├── package.json #说明使用哪些包<br> ├── .gitignore #限定在提交的时候哪些文件可以忽略<br> └── source</p><p>（1）讨论下哪些文件是必须拷贝的：首先是之前自己修改的文件，像站点配置_config.yml，theme文件夹里面的主题，以及source里面自己写的博客文件，这些肯定要拷贝的。除此之外，还有三个文件需要有，就是scaffolds文件夹（文章的模板）、package.json（说明使用哪些包）和.gitignore（限定在提交的时候哪些文件可以忽略）。其实，这三个文件不是我们修改的，所以即使丢失了，也没有关系，我们可以建立一个新的文件夹，然后在里面执行hexo init，就会生成这三个文件，我们只需要将它们拷贝过来使用即可。总结：_config.yml，theme/，source/，scaffolds/，package.json，.gitignore，是需要拷贝的。</p><p>（2）再讨论下哪些文件是不必拷贝的，或者说可以删除的：首先是.git文件，无论是在站点根目录下，还是主题目录下的.git文件，都可以删掉。然后是文件夹node_modules（在用npm install会重新生成），public（这个在用hexo g时会重新生成），.deploy_git文件夹（在使用hexo d时也会重新生成），db.json文件。其实上面这些文件也就是是.gitignore文件里面记载的可以忽略的内容。总结：.git/，node_modules/，public/，.deploy_git/，db.json文件需要删除。</p><h3 id="6-git-bash"><a href="#6-git-bash" class="headerlink" title="6.git bash"></a>6.git bash</h3><p>在本文件夹下git bash,运行npm install</p><h3 id="7-安装部署插件-可选"><a href="#7-安装部署插件-可选" class="headerlink" title="7.安装部署插件(可选)"></a>7.安装部署插件(可选)</h3><p>npm install hexo-deployer-git –save</p><h3 id="8-测试"><a href="#8-测试" class="headerlink" title="8.测试"></a>8.测试</h3><p>此时就可以hexo g &amp;&amp; hexo d 测试是否成功了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-安装node-js和git&quot;&gt;&lt;a href=&quot;#1-安装node-js和git&quot; class=&quot;headerlink&quot; title=&quot;1.安装node.js和git&quot;&gt;&lt;/a&gt;1.安装node.js和git&lt;/h3&gt;&lt;p&gt;这个不用多说，直接下载安装就行了。&lt;
      
    
    </summary>
    
      <category term="环境配置" scheme="http://TokeyRoad.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="git" scheme="http://TokeyRoad.github.io/tags/git/"/>
    
      <category term="hexo" scheme="http://TokeyRoad.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>智能指针类</title>
    <link href="http://TokeyRoad.github.io/2020/05/29/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%B1%BB/"/>
    <id>http://TokeyRoad.github.io/2020/05/29/智能指针类/</id>
    <published>2020-05-29T02:00:55.000Z</published>
    <updated>2020-06-01T09:42:53.915Z</updated>
    
    <content type="html"><![CDATA[<h4 id="std-auto-ptr"><a href="#std-auto-ptr" class="headerlink" title="std::auto_ptr"></a>std::auto_ptr</h4><p>基本用法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种形式</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; ap1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//第二种形式</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; ap2;</span><br><span class="line">ap2.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>智能指针对象ap1和ap2均持有一个在堆上分配int对象，这两块堆内存在对象释放时得以释放。</p><p>std::auto_ptr 经常误用的是复制操作，当复制auto_ptr对象时(拷贝复制或operator=复制)，原对象的堆内存会转移到复制的对象上，原指针就空了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; ap1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//拷贝复制</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; ap2(ap1);</span><br><span class="line"><span class="keyword">if</span> (ap1.get()!= <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ap1 is not NULL"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ap1 is NULL"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ap2.get() != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ap2 is not NULL"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ap2 is NULL"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//operator=复制</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; ap3(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; ap4 = ap3;</span><br><span class="line"><span class="keyword">if</span> (ap3.get() != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ap3 is not NULL"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ap3 is NULL"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ap4.get() != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ap4 is not NULL"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ap4 is NULL"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">ap1 is <span class="literal">NULL</span></span><br><span class="line">ap2 is <span class="keyword">not</span> <span class="literal">NULL</span></span><br><span class="line">ap3 is <span class="literal">NULL</span></span><br><span class="line">ap4 is <span class="keyword">not</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p>ap1的堆内存转移到了ap2，ap3的堆内存转移到了ap4</p><p>因此在使用中，应尽量避免使用std::auto_ptr（C++11之后 该指针已被弃用，不应该再使用它）</p><h4 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h4><p>std::unique_ptr对指向的堆内存具有唯一控制权，引用计数永远为1，对象销毁时释放对应的堆内存。</p><p>基本使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种形式</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//第二种形式</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up2;</span><br><span class="line">up2.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//第三种形式</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up3 = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>注</p><blockquote><p>std::unique_ptr禁止复制操作</p><p>std::unique_ptr类的拷贝构造函数和赋值operator=函数 都被标记为=delete</p></blockquote><p>禁止复制操作存在特例，即可以通过一个函数返回一个std::unique_ptr：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; func(<span class="keyword">int</span> val) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up(<span class="keyword">new</span> <span class="keyword">int</span>(val));</span><br><span class="line"><span class="keyword">return</span> up;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up4 = func(<span class="number">3</span>);<span class="comment">//std::move</span></span><br></pre></td></tr></table></figure><p>实现方法：使用移动构造，即std::move</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up5(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up6(<span class="built_in">std</span>::move(up5));</span><br></pre></td></tr></table></figure><p>std::move将up5持有的堆内存转移给了up6，最后up5不再持有堆内存，即是一个空的智能指针对象。</p><p>std::move操作是否有意义，取决于是否实现了移动构造(Move Constructor)和移动赋值(operator=)运算符，而unique_ptr正好实现了这两个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Deletor&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unique_ptr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unique_ptr</span>(<span class="built_in">unique_ptr</span>&amp;&amp; rhs)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_pT = ths.m_pT;</span><br><span class="line">        rhs.m_pT = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unique_ptr</span>&amp; <span class="keyword">operator</span>=(<span class="built_in">unique_ptr</span>&amp;&amp; rhs)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_pT = rhs.m_pT;</span><br><span class="line">        rhs.m_pT = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* m_pT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::unique_ptr不仅可以持有一个堆对象，也可以持有一组堆对象，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>[]&gt; up7(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">up7[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; up7[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//std::unique_ptr&lt;int&gt; up8(std::move(up7[2]));//错误</span></span><br></pre></td></tr></table></figure><p>std::shared_ptr和std::weak_ptr也可以持有一组堆对象，用法与std::unique_ptr一致。</p><h5 id="自定义-智能指针对象持有的资源的释放函数"><a href="#自定义-智能指针对象持有的资源的释放函数" class="headerlink" title="自定义 智能指针对象持有的资源的释放函数"></a>自定义 智能指针对象持有的资源的释放函数</h5><p>默认情况下，智能指针对象在析构时只会释放其持有的堆内存，调用delete或delete[]，但是有些时候，不止要回收指针对象，还需要回收与该指针相关的其他内存，这时，就需要自定义智能指针的资源释放函数了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Student() &#123;</span><br><span class="line">name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(name, <span class="string">"abc"</span>);</span><br><span class="line">&#125;</span><br><span class="line">~Student() &#123;&#125;</span><br><span class="line">    <span class="comment">//这里应该把delete放入析构中，这里只是为了说明智能指针的相关用法才这么写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">delete</span>[] name;</span><br><span class="line">name = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span>* name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> releaseFunc = [](Student* ps)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ps-&gt;getName() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        ps-&gt;release();</span><br><span class="line">        <span class="keyword">delete</span> ps;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Student, <span class="keyword">void</span>(*)(Student* ps)&gt; pStudent(<span class="keyword">new</span> Student(), releaseFunc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义std::unique_ptr的资源释放函数规则是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T,DeletorFuncPtr&gt;</span><br></pre></td></tr></table></figure><p>其中T是要释放的对象类型，DeletorFuncPtr是自定义函数指针，这里可以使用decltype(releaseFunc)让编译器自行推导releaseFunc的类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Student, <span class="keyword">void</span>(*)(Student* ps)&gt; pStudent(<span class="keyword">new</span> Student(), releaseFunc);</span><br><span class="line">可改为</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Student, <span class="keyword">decltype</span>(releaseFunc))&gt; pStudent(<span class="keyword">new</span> Student(), releaseFunc);</span><br></pre></td></tr></table></figure><h4 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h4><p>std::unique_ptr对持有的资源具有独占性，而std::shared_ptr对持有的资源具有共享性，即多个shared_ptr可以同时持有同一个资源对象，每增加一个shared_ptr指向该对象，该对象的引用计数就+1，每析构一个，引用计数-1，当引用计数为0时，该对象被释放回收，多个线程之间，递增或者递减引用计数是安全的，但并不意味着，多个线程之间同时操作引用对象时安全的。std::shared_ptr提供一个use_count()方法来获取当前持有资源的引用计数。除此之外，其余的用法与std::unique_ptr基本相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//初始化2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2;</span><br><span class="line">sp2.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//初始化3</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp3 = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>优先使用std::make_shared去初始化std::shared_ptr对象。</p><h5 id="std-enable-shared-from-this"><a href="#std-enable-shared-from-this" class="headerlink" title="std::enable_shared_from_this"></a>std::enable_shared_from_this</h5><p>在开发中，有时候需要在类中返回包裹当前对象（this）的std::shared_ptr对象给外部使用，有此需求的类只要继承自己的std::enable_shared_from_this<t>模板对象即可。</t></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;A&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A()&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~A() &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A destructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; getSelf() &#123;</span><br><span class="line"><span class="keyword">return</span> shared_from_this();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; sp4(<span class="keyword">new</span> A());</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; sp5 = sp4-&gt;getSelf();</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"use_count:"</span> &lt;&lt; sp4.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getSelf方法返回自身的std::shared_ptr对象，方法中直接返回shared_from_this()。</p><h5 id="陷阱一：不应该共享栈对象的this给智能指针对象"><a href="#陷阱一：不应该共享栈对象的this给智能指针对象" class="headerlink" title="陷阱一：不应该共享栈对象的this给智能指针对象"></a>陷阱一：不应该共享栈对象的this给智能指针对象</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与上文代码相同</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; sp5 = a.getSelf();</span><br><span class="line">    <span class="comment">//程序在该行崩溃</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"use_count:"</span> &lt;&lt; sp4.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>崩溃原因：智能指针是为了管理堆对象的，而a是栈对象，栈对象会在函数调用结束时自行销毁，不能通过shared_from_this交给智能指针管理。</p><p>智能指针最初的设计目的就是为了管理不会自动回收的堆内存的。</p><h5 id="陷阱二：避免std-enable-shared-from-this的循环引用问题"><a href="#陷阱二：避免std-enable-shared-from-this的循环引用问题" class="headerlink" title="陷阱二：避免std::enable_shared_from_this的循环引用问题"></a>陷阱二：避免std::enable_shared_from_this的循环引用问题</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;B&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B() &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~B() &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B destructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">m_mySelf = shared_from_this();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;B&gt; m_mySelf;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;B&gt; sp6(<span class="keyword">new</span> B());</span><br><span class="line">sp6-&gt;func();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">B constructor</span><br></pre></td></tr></table></figure><p>根据输出可以发现对象B没有被回收，发生了内存泄漏，那么这是为什么呢？</p><p>sp6创建的时候 对象引用计数为1，之后调用func函数把自身的shared_ptr赋值给了类变量m_mySelf,此时引用计数为2，之后sp6对象被销毁，此时B的引用计数为1，不会被销毁，这时就出现了矛盾，B想要销毁就要引用计数减为0，就需要销毁m_mySelf，那么就必须要销毁B对象，这样B对象就无法销毁了。因此我们实际开发中应该避免出现这样的逻辑。</p><h5 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h5><p>std::weak_ptr是一个不控制资源生命周期的智能指针，是对对象的一种弱引用，只是提供了对其管理对象的一个访问手段，引入的目的是为了辅助shared_ptr工作。</p><p>std::weak_ptr可以从一个std::shared_ptr或另一个std::weak_ptr对象构造，std::shared_ptr可以直接复制给std::weak_ptr，weak_ptr可以通过lock()方法获取shared_ptr，它的构造和析构不会引起引用计数的变化，weak_ptr可用于解决shared_ptr引用计数循环的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp1 = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"use_count:"</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; wp2(sp1);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"use_count:"</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; wp3 = sp1;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"use_count:"</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; wp4(wp3);</span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; wp5 = wp3;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"use_count:"</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过lock()方法获得shared_ptr会增加引用计数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp6 = wp5.lock();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"use_count:"</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">use count: <span class="number">1</span></span><br><span class="line">use count: <span class="number">1</span></span><br><span class="line">use count: <span class="number">1</span></span><br><span class="line">use count: <span class="number">1</span></span><br><span class="line">use count: <span class="number">2</span></span><br></pre></td></tr></table></figure><p>weak_ptr不管对象的生命周期，当对象被销毁时，通过expired()方法来检测，返回true，表示对象已经不存在了；false表示对象还存在，此时可以通过lock()方法获取shared_ptr继续操作对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tmpPoint  ----&gt;std::weak_ptr&lt;Point&gt;</span></span><br><span class="line"><span class="keyword">if</span>(tmpPoint.expired())&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Point&gt; p = tmpPoint.lock();</span><br><span class="line"><span class="keyword">if</span>(p)&#123;</span><br><span class="line">    <span class="comment">//数据处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>weak_ptr没有重写operator-&gt;和operator*方法，所以不能直接操作对象，也没有重写operator!操作，所以也不能判断引用的资源是否存在。</p><p>weak_ptr不增加引用资源的引用计数来管理资源的生命周期，是因为，即使它实现了以上几个方法，调用他们是不安全的，因为在调用期间，引用的资源可能已经被销毁了。</p><p>weak_ptr的正确使用场景是那些资源如果可用就使用，不可用就不用的场景，它不参与资源的生命周期管理。</p><p>例如：在网络分层中，Session对象：利用Connection对象提供的服务工作，但是Session对象不管理Connection对象的生命周期，因为网络底层会有各种原因导致Connection对象销毁，如果Session强行持有Connection对象,会与事实矛盾。</p><p>经典示例：（订阅者模式 或者 观察者模式）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subscriber</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubscribeManager</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">publish</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; iter : m_subscirbers)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!iter.expired())&#123;</span><br><span class="line">                <span class="comment">//<span class="doctag">TODO:</span>Send Message to Subscriber</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::weak_ptr&lt;Subscriber&gt;&gt; m_subscirbers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="智能指针对象的大小"><a href="#智能指针对象的大小" class="headerlink" title="智能指针对象的大小"></a>智能指针对象的大小</h4><p>一个<strong>std::unique_ptr</strong>对象大小与一个裸指针大小相同，而<strong>std::shared_ptr</strong>对象的大小是<strong>std::unique_ptr</strong>大小的一倍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp0;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; sp1;</span><br><span class="line">sp1.reset(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>());</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2;</span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; sp3;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sp0 size: "</span> &lt;&lt; <span class="keyword">sizeof</span>(sp0) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sp1 size: "</span> &lt;&lt; <span class="keyword">sizeof</span>(sp1) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sp2 size: "</span> &lt;&lt; <span class="keyword">sizeof</span>(sp2) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sp3 size: "</span> &lt;&lt; <span class="keyword">sizeof</span>(sp3) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">sp0 size: <span class="number">8</span></span><br><span class="line">sp1 size: <span class="number">8</span></span><br><span class="line">sp2 size: <span class="number">4</span></span><br><span class="line">sp3 size: <span class="number">8</span></span><br></pre></td></tr></table></figure><h4 id="智能指针使用注意事项"><a href="#智能指针使用注意事项" class="headerlink" title="智能指针使用注意事项"></a>智能指针使用注意事项</h4><blockquote><ul><li>一旦一个对象使用智能指针管理后，就不该再使用原始裸指针去操作。</li><li>分清楚场合应该使用哪种类型的智能指针。</li><li>认真考虑，避免操作某个引用资源已经释放的智能指针。</li><li>作为类成员变量时，应该优先使用前置声明（forward declarations）。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;std-auto-ptr&quot;&gt;&lt;a href=&quot;#std-auto-ptr&quot; class=&quot;headerlink&quot; title=&quot;std::auto_ptr&quot;&gt;&lt;/a&gt;std::auto_ptr&lt;/h4&gt;&lt;p&gt;基本用法&lt;/p&gt;
&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="unique_ptr" scheme="http://TokeyRoad.github.io/tags/unique-ptr/"/>
    
      <category term="shared_ptr" scheme="http://TokeyRoad.github.io/tags/shared-ptr/"/>
    
  </entry>
  
  <entry>
    <title>原子操作类-atomic</title>
    <link href="http://TokeyRoad.github.io/2020/05/22/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB-atomic/"/>
    <id>http://TokeyRoad.github.io/2020/05/22/原子操作类-atomic/</id>
    <published>2020-05-22T03:29:15.000Z</published>
    <updated>2020-05-23T02:59:50.146Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 11 新标准中提供了对整形变量原子操作的相关库，即std::atomic,这是个模板类型：（同时支持跨平台）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">atomic</span>;</span></span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; ato_int;</span><br><span class="line">ato_int = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::atomic&lt;int&gt; ato_int = 1;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d \n"</span>, (<span class="keyword">int</span>)ato_int);</span><br><span class="line"></span><br><span class="line">++ato_int;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d \n"</span>, (<span class="keyword">int</span>)ato_int);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码在win和linux中都可以运行，但是如果这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//std::atomic&lt;int&gt; ato_int;</span></span><br><span class="line"><span class="comment">//ato_int = 1;</span></span><br><span class="line">   <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; ato_int = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>就只能在win下运行，linux编译无法通过。</p><p>错误原因是std::atomic的拷贝构造函数是默认=delete 禁止编译器生成的 g++遵循了，但是win上的vc++没有遵循。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atomic&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> atomic&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">方法说明</th></tr></thead><tbody><tr><td style="text-align:center">operator=</td><td style="text-align:center">存储值到对象</td></tr><tr><td style="text-align:center">store</td><td style="text-align:center">原子的以非原子对象替换原子对象的值</td></tr><tr><td style="text-align:center">load</td><td style="text-align:center">原子的获取原子对象的值</td></tr><tr><td style="text-align:center">exchange</td><td style="text-align:center">原子的替换原子对象的值并获得它先前替换的值</td></tr><tr><td style="text-align:center">compare_exchange_weak<br>compare_exchange_strong</td><td style="text-align:center">原子的比较原子对象非原子参数的值。若相等则交换，不相等则加载</td></tr><tr><td style="text-align:center">fetch_add</td><td style="text-align:center">原子的将参数加到原子对象的值，并返回先前的值</td></tr><tr><td style="text-align:center">fetch_sub</td><td style="text-align:center">原子的将原子对象的值减去参数，并返回先前的值</td></tr><tr><td style="text-align:center">fetch_and</td><td style="text-align:center">原子的进行参数和原子对象逐位与，并获得先前保存的值</td></tr><tr><td style="text-align:center">fetch_or</td><td style="text-align:center">原子的进行参数和原子对象逐位或，并获得先前保存的值</td></tr><tr><td style="text-align:center">fetch_xor</td><td style="text-align:center">原子的进行参数和原子对象逐位异或，并获得先前保存的值</td></tr><tr><td style="text-align:center">operator++ operator++(int) operator- operator-(int</td><td style="text-align:center">原子值增加或者减一</td></tr><tr><td style="text-align:center">operator+= operator-= operator&amp;= operator\</td><td style="text-align:center">= operator^=</td><td>=加减，=与原子值进行逐位与或异或</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C++ 11 新标准中提供了对整形变量原子操作的相关库，即std::atomic,这是个模板类型：（同时支持跨平台）&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="atomic" scheme="http://TokeyRoad.github.io/tags/atomic/"/>
    
  </entry>
  
  <entry>
    <title>线程资源同步对象-condition_variable</title>
    <link href="http://TokeyRoad.github.io/2020/05/20/%E7%BA%BF%E7%A8%8B%E8%B5%84%E6%BA%90%E5%90%8C%E6%AD%A5%E5%AF%B9%E8%B1%A1-condition-variable/"/>
    <id>http://TokeyRoad.github.io/2020/05/20/线程资源同步对象-condition-variable/</id>
    <published>2020-05-20T06:41:58.000Z</published>
    <updated>2020-05-21T08:23:41.093Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 11提供了std::condition_variable这个类 代表条件变量，与Linux系统原生的条件变量一样，同时还提供了等待条件变量的一系列wait方法(wait/wait_for/wait_until)，发送信号使用notify方法(notify_one/notify_all)，使用std::condition_variable时需要绑定到std::unique_lock或std::lock_guard对象。</p><blockquote><p>C++ 11中 std::condition_variable 不再需要显示调用方法初始化和销毁</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Task(<span class="keyword">int</span> id) &#123;</span><br><span class="line">m_taskID = id;</span><br><span class="line">&#125;</span><br><span class="line">~Task() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"do task,taskID:"</span> &lt;&lt; m_taskID &lt;&lt; <span class="string">", threadID:"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_taskID;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mutex;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;Task*&gt; tasks;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">produce_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Task* pTask = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> taskID = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">pTask = <span class="keyword">new</span> Task(taskID);</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lg(mutex);</span><br><span class="line">tasks.push_back(pTask);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"produce a task,taskID:"</span> &lt;&lt; taskID &lt;&lt; <span class="string">",threadID:"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">cv.notify_all();</span><br><span class="line">taskID++;</span><br><span class="line"><span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consume_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Task* pTask = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> taskID = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; guard(mutex);</span><br><span class="line"><span class="keyword">while</span> (tasks.empty()) &#123;</span><br><span class="line">cv.wait(guard);</span><br><span class="line">&#125;</span><br><span class="line">pTask = tasks.front();</span><br><span class="line">tasks.pop_front();</span><br><span class="line"><span class="keyword">if</span> (pTask == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">pTask-&gt;DoTask();</span><br><span class="line"><span class="keyword">delete</span> pTask;</span><br><span class="line">pTask = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::thread consume1 = <span class="built_in">std</span>::thread(consume_thread);</span><br><span class="line"><span class="built_in">std</span>::thread consume2 = <span class="built_in">std</span>::thread(consume_thread);</span><br><span class="line"><span class="built_in">std</span>::thread consume3 = <span class="built_in">std</span>::thread(consume_thread);</span><br><span class="line"><span class="built_in">std</span>::thread consume4 = <span class="built_in">std</span>::thread(consume_thread);</span><br><span class="line"><span class="built_in">std</span>::thread consume5 = <span class="built_in">std</span>::thread(consume_thread);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::thread produce1 = <span class="built_in">std</span>::thread(produce_thread);</span><br><span class="line"><span class="comment">//std::thread produce2 = std::thread(produce_thread);</span></span><br><span class="line"><span class="comment">//std::thread produce3 = std::thread(produce_thread);</span></span><br><span class="line"></span><br><span class="line">consume1.join();</span><br><span class="line">consume2.join();</span><br><span class="line">consume3.join();</span><br><span class="line">consume4.join();</span><br><span class="line">consume5.join();</span><br><span class="line">produce1.join();</span><br><span class="line"><span class="comment">//produce2.join();</span></span><br><span class="line"><span class="comment">//produce3.join();</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line">produce a task,taskID:<span class="number">0</span>,threadID:<span class="number">19444</span></span><br><span class="line"><span class="keyword">do</span> task,taskID:<span class="number">0</span>, threadID:<span class="number">6344</span></span><br><span class="line">produce a task,taskID:<span class="number">1</span>,threadID:<span class="number">19444</span></span><br><span class="line"><span class="keyword">do</span> task,taskID:<span class="number">1</span>, threadID:<span class="number">6352</span></span><br><span class="line">produce a task,taskID:<span class="number">2</span>,threadID:<span class="number">19444</span></span><br><span class="line"><span class="keyword">do</span> task,taskID:<span class="number">2</span>, threadID:<span class="number">4836</span></span><br><span class="line">produce a task,taskID:<span class="number">3</span>,threadID:<span class="number">19444</span></span><br><span class="line"><span class="keyword">do</span> task,taskID:<span class="number">3</span>, threadID:<span class="number">6352</span></span><br><span class="line">produce a task,taskID:<span class="number">4</span>,threadID:<span class="number">19444</span></span><br><span class="line"><span class="keyword">do</span> task,taskID:<span class="number">4</span>, threadID:<span class="number">6344</span></span><br><span class="line">produce a task,taskID:<span class="number">5</span>,threadID:<span class="number">19444</span></span><br><span class="line"><span class="keyword">do</span> task,taskID:<span class="number">5</span>, threadID:<span class="number">4836</span></span><br><span class="line">produce a task,taskID:<span class="number">6</span>,threadID:<span class="number">19444</span></span><br><span class="line"><span class="keyword">do</span> task,taskID:<span class="number">6</span>, threadID:<span class="number">13436</span></span><br><span class="line">produce a task,taskID:<span class="number">7</span>,threadID:<span class="number">19444</span></span><br><span class="line"><span class="keyword">do</span> task,taskID:<span class="number">7</span>, threadID:<span class="number">4836</span></span><br><span class="line">    .........</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C++ 11提供了std::condition_variable这个类 代表条件变量，与Linux系统原生的条件变量一样，同时还提供了等待条件变量的一系列wait方法(wait/wait_for/wait_until)，发送信号使用notify方法(notify_one/n
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="condition_variable" scheme="http://TokeyRoad.github.io/tags/condition-variable/"/>
    
  </entry>
  
  <entry>
    <title>线程资源同步对象-mutex</title>
    <link href="http://TokeyRoad.github.io/2020/05/20/%E7%BA%BF%E7%A8%8B%E8%B5%84%E6%BA%90%E5%90%8C%E6%AD%A5%E5%AF%B9%E8%B1%A1-mutex/"/>
    <id>http://TokeyRoad.github.io/2020/05/20/线程资源同步对象-mutex/</id>
    <published>2020-05-20T01:34:48.000Z</published>
    <updated>2020-05-20T06:43:30.233Z</updated>
    
    <content type="html"><![CDATA[<p>在C++ 11新标准中新增了线程资源同步对象：std::mutex 和 std::condition_variable 。</p><h5 id="std-mutex-系列"><a href="#std-mutex-系列" class="headerlink" title="std::mutex 系列"></a>std::mutex 系列</h5><p>C++ 11/14/17中提供了如下mutex系列类型：</p><table><thead><tr><th style="text-align:center">互斥量</th><th style="text-align:center">版本</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">mutex</td><td style="text-align:center">C++ 11</td><td style="text-align:center">最基本的互斥量</td></tr><tr><td style="text-align:center">timed_mutex</td><td style="text-align:center">C++ 11</td><td style="text-align:center">有超时机制的互斥量</td></tr><tr><td style="text-align:center">recursive_mutex</td><td style="text-align:center">C++ 11</td><td style="text-align:center">可重入的互斥量</td></tr><tr><td style="text-align:center">recursive_timed_mutex</td><td style="text-align:center">C++ 11</td><td style="text-align:center">结合timed_mutex和recursive_mutex特点的互斥量</td></tr><tr><td style="text-align:center">shared_timed_mutex</td><td style="text-align:center">C++ 14</td><td style="text-align:center">具有超时机制的可共享互斥量</td></tr><tr><td style="text-align:center">shared_mutex</td><td style="text-align:center">C++ 17</td><td style="text-align:center">共享的互斥量</td></tr></tbody></table><p>这个系列的对象均提供了加锁(lock)、尝试加锁(trylock) 和 解锁(unlock) 的方法。</p><p>为了避免死锁， std::mutex.lock() 和 std::mutex.unlock() 需要成对使用，同时C++11提供了一些互斥量管理的封装方法，避免忘记unlock而造成死锁。</p><table><thead><tr><th style="text-align:center">互斥量管理</th><th style="text-align:center">版本</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">lock_guard</td><td style="text-align:center">C++ 11</td><td style="text-align:center">基于作用域的互斥量管理</td></tr><tr><td style="text-align:center">unique_lock</td><td style="text-align:center">C++ 11</td><td style="text-align:center">更加灵活的互斥量管理</td></tr><tr><td style="text-align:center">shared_lock</td><td style="text-align:center">C++ 14</td><td style="text-align:center">共享互斥量的管理</td></tr><tr><td style="text-align:center">scope_lock</td><td style="text-align:center">C++ 17</td><td style="text-align:center">多互斥量避免死锁的管理</td></tr></tbody></table><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lg(mymutex);</span><br><span class="line"><span class="comment">//保护的资源操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：mymutex的声明周期必须比函数func的作用域长。</p><p>错误示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误写法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lg(mymutex);</span><br><span class="line"><span class="comment">//保护的资源操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写是错误的，当跳出func作用域时，m已经失效，这时lg析构解锁的时候，会出现未定义的行为。</p><p>此外，如果一个std::mutex对象已经调用lock()方法，再次调用时,会出现未定义的行为(Windows)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line">m.lock();</span><br><span class="line">m.lock();<span class="comment">//程序在这里崩溃</span></span><br><span class="line"><span class="comment">//bool re = m.try_lock();</span></span><br><span class="line"><span class="comment">//std::cout &lt;&lt; re &lt;&lt; std::endl;//output 0</span></span><br><span class="line">m.unlock();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，对于一个已经调用lock()方法再次调用lock()方法的做法是错误的。</p><h5 id="std-shared-mutex"><a href="#std-shared-mutex" class="headerlink" title="std::shared_mutex"></a>std::shared_mutex</h5><p>std::shared_mutex底层实现主要原理是操作系统提供的读写锁，在存在多个线程对公共资源读，少部分线程对公共资源写的情况下，std::shared_mutex 比 std::mutex效率更高。</p><p>std::shared_mutex提供了lock_shared()和unlock_shared()方法 获取读锁和写锁，写锁通常被称为 排他锁(Exclusive Locking)，读锁常被称为 共享锁(Shared Locking)。</p><p>同时C++ 新标准中引入了 std::unique_lock 和 std::shared_lock 用于进入作用域自动加锁，离开作用域自动解锁，前者用于写锁，后者用于读锁。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_mutex_counter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">shared_mutex_counter() = <span class="keyword">default</span>;</span><br><span class="line">~shared_mutex_counter() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::shared_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; sl(_shared_mutex);</span><br><span class="line"><span class="keyword">return</span> _value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increse</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; sl(_shared_mutex);</span><br><span class="line">++_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; sl(_shared_mutex);</span><br><span class="line">_value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::shared_mutex _shared_mutex;</span><br><span class="line"><span class="comment">//共享数据</span></span><br><span class="line"><span class="keyword">int</span> _value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOOP_COUNT 5000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_COUNT 8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_shared_mutex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">shared_mutex_counter shared_counter;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> readr = [&amp;shared_counter, &amp;result]() &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LOOP_COUNT; ++i) &#123;</span><br><span class="line">result = shared_counter.get();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> start = clock();</span><br><span class="line"><span class="keyword">auto</span> writer = [&amp;shared_counter]() &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LOOP_COUNT; ++i) &#123;</span><br><span class="line">shared_counter.increse();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::thread** tarray = <span class="keyword">new</span> <span class="built_in">std</span>::thread*[THREAD_COUNT];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; ++i) &#123;</span><br><span class="line">tarray[i] = <span class="keyword">new</span> <span class="built_in">std</span>::thread(readr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::thread* tw = <span class="keyword">new</span> <span class="built_in">std</span>::thread(writer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; ++i) &#123;</span><br><span class="line">tarray[i]-&gt;join();</span><br><span class="line">&#125;</span><br><span class="line">tw-&gt;join();</span><br><span class="line"><span class="keyword">clock_t</span> end = clock();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[test_shared_mutex] thread_count:%d\n"</span>, THREAD_COUNT);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"count_value:%d, cost:%dms, result:%d"</span>, shared_counter.get(), end - start, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">test_shared_mutex();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">[test_shared_mutex] thread_count:<span class="number">8</span></span><br><span class="line">count_value:<span class="number">5000000</span>, cost:<span class="number">5030</span>ms, result:<span class="number">2522449</span></span><br></pre></td></tr></table></figure><p>另外一个mutex的测试案例不再列出，跟shared_mutex类似。但是两者效率差距较大。</p><p>如果条件允许，可以根据使用场景，用shared_mutex替换mutex，可以提高很大的效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在C++ 11新标准中新增了线程资源同步对象：std::mutex 和 std::condition_variable 。&lt;/p&gt;
&lt;h5 id=&quot;std-mutex-系列&quot;&gt;&lt;a href=&quot;#std-mutex-系列&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="mutex" scheme="http://TokeyRoad.github.io/tags/mutex/"/>
    
  </entry>
  
  <entry>
    <title>stl容器新增的实用方法</title>
    <link href="http://TokeyRoad.github.io/2020/05/19/stl%E5%AE%B9%E5%99%A8%E6%96%B0%E5%A2%9E%E7%9A%84%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://TokeyRoad.github.io/2020/05/19/stl容器新增的实用方法/</id>
    <published>2020-05-19T03:44:34.000Z</published>
    <updated>2020-05-19T09:33:43.909Z</updated>
    
    <content type="html"><![CDATA[<h4 id="emplace系列函数"><a href="#emplace系列函数" class="headerlink" title="emplace系列函数"></a>emplace系列函数</h4><p>先上一段常用的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Test(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">m_a = a;</span><br><span class="line">m_b = b;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Test constructed"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Test() &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_a &lt;&lt; <span class="string">" Test destructed"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test(<span class="keyword">const</span> Test&amp; t) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;t) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = t.m_a;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_b = t.m_b;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_a &lt;&lt; <span class="string">" Test copy-constructed"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_a;</span><br><span class="line"><span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Test&gt; vec;</span><br><span class="line">vec.reserve(<span class="number">20</span>);<span class="comment">//，提前分好内存 避免vector的内存重分配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line"><span class="function">Test <span class="title">t</span><span class="params">(i, i + <span class="number">1</span>)</span></span>;</span><br><span class="line">vec.push_back(t);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">Test constructed</span><br><span class="line"><span class="number">0</span> Test copy-constructed</span><br><span class="line"><span class="number">0</span> Test destructed</span><br><span class="line">Test constructed</span><br><span class="line"><span class="number">1</span> Test copy-constructed</span><br><span class="line"><span class="number">1</span> Test destructed</span><br><span class="line">Test constructed</span><br><span class="line"><span class="number">2</span> Test copy-constructed</span><br><span class="line"><span class="number">2</span> Test destructed</span><br></pre></td></tr></table></figure><p>在这个过程中，我们的目的是为了产生一个对象数组，为了产生3个对象,调用了3*3次，这个过程执行过程：创建对象t调用构造函数—&gt;调用对象t的拷贝构造函数放入集合—&gt;调用析构函数。</p><p>C++11 提供了一个新的方法代替emplace_back</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Test&gt; vec;</span><br><span class="line">vec.reserve(<span class="number">20</span>);<span class="comment">//，提前分好内存 避免vector的内存重分配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">vec.emplace_back(i, i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">Test constructed</span><br><span class="line">Test constructed</span><br><span class="line">Test constructed</span><br></pre></td></tr></table></figure><p>emplace操作被称为 “原位构造元素”</p><p>同理的方法 如下:</p><table><thead><tr><th style="text-align:center">原方法</th><th style="text-align:center">C++11 改进方法</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">push/insert</td><td style="text-align:center">emplace</td><td style="text-align:center">指定位置原位构造元素</td></tr><tr><td style="text-align:center">push_front</td><td style="text-align:center">emplace_front</td><td style="text-align:center">首部原位构造元素</td></tr><tr><td style="text-align:center">push_back</td><td style="text-align:center">emplace_back</td><td style="text-align:center">尾部原位构造元素</td></tr></tbody></table><h4 id="std-map的try-emplace-与-insert-or-assign方法"><a href="#std-map的try-emplace-与-insert-or-assign方法" class="headerlink" title="std::map的try_emplace 与 insert_or_assign方法"></a>std::map的try_emplace 与 insert_or_assign方法</h4><p>由于map中的key是唯一的，因此在开发中经常遇到往map中插入数据之前需要先验证key是否存在，C++17中map提供了一个try_emplace方法，该方法会检测指定的key是否存在，函数签名如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;iterator, bool&gt; <span class="title">try_emplace</span>(<span class="title">const</span> <span class="title">key_type</span>&amp; <span class="title">k</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;iterator, bool&gt; <span class="title">try_emplace</span>(<span class="title">key_type</span>&amp;&amp; <span class="title">k</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">iterator</span> <span class="title">try_emplace</span>(<span class="title">const_iterator</span> <span class="title">hint</span>, <span class="title">const</span> <span class="title">key_type</span>&amp; <span class="title">k</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">iterator</span> <span class="title">try_emplace</span>(<span class="title">const_iterator</span> <span class="title">hint</span>, <span class="title">key_type</span>&amp;&amp; <span class="title">k</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure><p>其中k表示需要插入的key，args不定参数表示构造value对象所需的参数列表，hint表示插入位置。</p><p>前两种形式中，返回值是std::pair&lt;T1,T2&gt;，其中T2是个bool表示，当前插入操作成功与否，T1是一个迭代器，如果插入成功，则指向插入位置的元素迭代器，如果失败，则指向相同key元素的迭代器。 </p><p>后两种不常用，在map中插入时很少关心插入位置。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; m;</span><br><span class="line">m.emplace(<span class="string">"aaa"</span>, <span class="string">"ONE"</span>);</span><br><span class="line">m.emplace(<span class="string">"bbb"</span>, <span class="string">"TWO"</span>);</span><br><span class="line">m.emplace(<span class="string">"ccc"</span>, <span class="string">"THREE"</span>);</span><br><span class="line">m.emplace(<span class="string">"ddd"</span>, <span class="string">"FOUR"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> res = m.try_emplace(<span class="string">"eee"</span>, <span class="string">"FIVE"</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; res.first-&gt;second.c_str() &lt;&lt; <span class="string">" "</span> &lt;&lt; res.second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"map size:"</span> &lt;&lt; m.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : m) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter.first &lt;&lt; iter.second &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> resf = m.try_emplace(<span class="string">"aaa"</span>, <span class="string">"SIX"</span>);<span class="comment">//auto -&gt; std::pair&lt;std::map&lt;std::string, std::string&gt;::iterator, bool&gt;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; resf.first-&gt;second.c_str() &lt;&lt; <span class="string">" "</span> &lt;&lt; resf.second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : m) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter.first &lt;&lt; iter.second &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = m.try_emplace(m.begin(), <span class="string">"fff"</span>, <span class="string">"SEVEN"</span>);<span class="comment">////auto -&gt; std::map&lt;std::string, std::string&gt;::iterator</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : m) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter.first &lt;&lt; iter.second &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">FIVE <span class="number">1</span></span><br><span class="line"><span class="built_in">map</span> size:<span class="number">5</span></span><br><span class="line">aaaONE bbbTWO cccTHREE dddFOUR eeeFIVE</span><br><span class="line">ONE <span class="number">0</span></span><br><span class="line">aaaONE bbbTWO cccTHREE dddFOUR eeeFIVE</span><br><span class="line">fffSEVEN</span><br><span class="line">aaaONE bbbTWO cccTHREE dddFOUR eeeFIVE fffSEVEN</span><br></pre></td></tr></table></figure><p>try_emplace是map中指定的key存在就失败，不存在就插入，还有另一个方法insert_or_assign 当key存在时就更新value，不存在时就插入。</p><p>insert_or_assign函数签名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">M</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;iterator, bool&gt; <span class="title">insert_or_assign</span>(<span class="title">const</span> <span class="title">key_type</span>&amp; <span class="title">k</span>, <span class="title">M</span>&amp;&amp; <span class="title">obj</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">M</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;iterator, bool&gt; <span class="title">insert_or_assign</span>(<span class="title">key_type</span>&amp;&amp; <span class="title">k</span>, <span class="title">M</span>&amp;&amp; <span class="title">obj</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">M</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">iterator</span> <span class="title">insert_or_assign</span>(<span class="title">const_iterator</span> <span class="title">hint</span>, <span class="title">const</span> <span class="title">key_type</span>&amp; <span class="title">k</span>, <span class="title">M</span>&amp;&amp; <span class="title">obj</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">M</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">iterator</span> <span class="title">insert_or_assign</span>(<span class="title">const_iterator</span> <span class="title">hint</span>, <span class="title">key_type</span>&amp;&amp; <span class="title">k</span>, <span class="title">M</span>&amp;&amp; <span class="title">obj</span>);</span></span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; m;</span><br><span class="line">m.emplace(<span class="string">"aaa"</span>, <span class="string">"ONE"</span>);</span><br><span class="line">m.emplace(<span class="string">"bbb"</span>, <span class="string">"TWO"</span>);</span><br><span class="line">m.emplace(<span class="string">"ccc"</span>, <span class="string">"THREE"</span>);</span><br><span class="line">m.emplace(<span class="string">"ddd"</span>, <span class="string">"FOUR"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : m) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter.first &lt;&lt; iter.second &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">m.insert_or_assign(<span class="string">"aaa"</span>, <span class="string">"EIGHT"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : m) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter.first &lt;&lt; iter.second &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">aaaONE bbbTWO cccTHREE dddFOUR</span><br><span class="line">aaaEIGHT bbbTWO cccTHREE dddFOUR</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;emplace系列函数&quot;&gt;&lt;a href=&quot;#emplace系列函数&quot; class=&quot;headerlink&quot; title=&quot;emplace系列函数&quot;&gt;&lt;/a&gt;emplace系列函数&lt;/h4&gt;&lt;p&gt;先上一段常用的代码：&lt;/p&gt;
&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="stl" scheme="http://TokeyRoad.github.io/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>foreach循环</title>
    <link href="http://TokeyRoad.github.io/2020/05/18/foreach%E5%BE%AA%E7%8E%AF/"/>
    <id>http://TokeyRoad.github.io/2020/05/18/foreach循环/</id>
    <published>2020-05-18T06:36:54.000Z</published>
    <updated>2020-05-18T07:21:15.419Z</updated>
    
    <content type="html"><![CDATA[<h4 id="for-each"><a href="#for-each" class="headerlink" title="for-each"></a>for-each</h4><p>C++ 11之后才开始支持for-each语法。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; v_str;</span><br><span class="line">v_str.push_back(<span class="string">"aaa"</span>);</span><br><span class="line">v_str.push_back(<span class="string">"bbb"</span>);</span><br><span class="line">v_str.push_back(<span class="string">"ccc"</span>);</span><br><span class="line">v_str.push_back(<span class="string">"ddd"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : v_str) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter.c_str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><blockquote><ol><li>for-each中的迭代器类型与数组或集合中的元素类型完全一致，而stl容器中的迭代器是类型的取地址类型即指针，因此对于上面的例子中，iter是string类型；如果用stl迭代器，那就是指向string的指针。</li><li>for-each对于复杂数据类型，迭代器是原始数据的拷贝，而不是引用，在这个过程中会额外调用构造函数的开销，必要的时候可以使用<code>auto&amp; iter</code> 而不是 <code>auto iter</code> 这样就是原始数据的引用了。</li></ol></blockquote><p>示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; v_str;</span><br><span class="line">v_str.push_back(<span class="string">"aaa"</span>);</span><br><span class="line">v_str.push_back(<span class="string">"bbb"</span>);</span><br><span class="line">v_str.push_back(<span class="string">"ccc"</span>);</span><br><span class="line">v_str.push_back(<span class="string">"ddd"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : v_str) &#123;</span><br><span class="line">iter = <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : v_str) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter.c_str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br><span class="line">ddd</span><br></pre></td></tr></table></figure><p>修改后</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; v_str;</span><br><span class="line">v_str.push_back(<span class="string">"aaa"</span>);</span><br><span class="line">v_str.push_back(<span class="string">"bbb"</span>);</span><br><span class="line">v_str.push_back(<span class="string">"ccc"</span>);</span><br><span class="line">v_str.push_back(<span class="string">"ddd"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; iter : v_str) &#123;</span><br><span class="line">iter = <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : v_str) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter.c_str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><h4 id="自定义对象使用for-each（Range-based）"><a href="#自定义对象使用for-each（Range-based）" class="headerlink" title="自定义对象使用for-each（Range-based）"></a>自定义对象使用for-each（Range-based）</h4><p>for-each的lterator类型必须支持如下三种操作:</p><blockquote><p>operator++操作，即自增，可以自增返回下一个迭代子的位置</p><p>operator!=操作，即判不等</p><p>operator* 操作，即解引用</p></blockquote><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A() &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">m_elements[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~A() &#123;&#125;</span><br><span class="line"><span class="function">T* <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_elements + <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">T* <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_elements + N;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T m_elements[N];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里迭代子的类型是T* 本身就支持operator++ 和 operator!=操作，这里就不再实现</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A&lt;<span class="keyword">int</span>, <span class="number">10</span>&gt; arr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : arr) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;for-each&quot;&gt;&lt;a href=&quot;#for-each&quot; class=&quot;headerlink&quot; title=&quot;for-each&quot;&gt;&lt;/a&gt;for-each&lt;/h4&gt;&lt;p&gt;C++ 11之后才开始支持for-each语法。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="foreach" scheme="http://TokeyRoad.github.io/tags/foreach/"/>
    
  </entry>
  
  <entry>
    <title>在一个类中重载另一个类的构造函数</title>
    <link href="http://TokeyRoad.github.io/2020/05/12/%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%AD%E9%87%8D%E8%BD%BD%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>http://TokeyRoad.github.io/2020/05/12/在一个类中重载另一个类的构造函数/</id>
    <published>2020-05-12T02:51:53.000Z</published>
    <updated>2020-05-12T03:08:18.126Z</updated>
    
    <content type="html"><![CDATA[<h5 id="构造函数是一个特殊的操作符"><a href="#构造函数是一个特殊的操作符" class="headerlink" title="构造函数是一个特殊的操作符"></a>构造函数是一个特殊的操作符</h5><p>假如我们有两个类point 和 Cpoint</p><p>现在我们需要用类point去构造Cpoint对象，一般实现方式是在Cpoint中定义如下构造：</p><blockquote><p>Cpoint(point);</p></blockquote><a id="more"></a><p>但有些情况下，这个构造是无法定义的：</p><blockquote><ol><li>用point的私有成员给Cpoint赋值（可以添加get方法解决），point没有定义Cpoint为友元类；</li><li>没有权限修改Cpoint，只能修改point；</li></ol></blockquote><p>这里我们可以在point重载Cpoint的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Cpoint &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">Cpoint(int a) &#123;</span></span><br><span class="line"><span class="comment">_p = a;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">private:</span></span><br><span class="line"><span class="comment">int _p;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">Cpoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Cpoint(_c_point);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> _c_point;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>重载后，在需要point构造Cpoint时都会隐式的调用point中的重载构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">point p1;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Cpoint&gt; vec;</span><br><span class="line">vec.push_back(p1);<span class="comment">//这个过程就是 由p1隐式构造Cpoint对象存入vec</span></span><br></pre></td></tr></table></figure><p>完整测试源代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cpoint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Cpoint() &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cpoint:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">_p = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Cpoint(<span class="keyword">int</span> a) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cpoint_a:"</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">_p = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> _p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">point() &#123;</span><br><span class="line">_c_point = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"point::point:"</span> &lt;&lt; _c_point &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">Cpoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">_c_point = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"point::Cpoint:"</span> &lt;&lt; _c_point &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> _c_point;<span class="comment">//等价于 Cpoint(_c_point)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> _c_point;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">point p;</span><br><span class="line"><span class="function">Cpoint <span class="title">cp</span><span class="params">(p)</span></span>;</span><br><span class="line"></span><br><span class="line">point p1;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Cpoint&gt; vec;</span><br><span class="line">vec.push_back(p1);</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output：</span></span><br><span class="line"><span class="comment">point::point:1</span></span><br><span class="line"><span class="comment">point::Cpoint:3</span></span><br><span class="line"><span class="comment">Cpoint_a:3</span></span><br><span class="line"><span class="comment">point::point:1</span></span><br><span class="line"><span class="comment">point::Cpoint:3</span></span><br><span class="line"><span class="comment">Cpoint_a:3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;构造函数是一个特殊的操作符&quot;&gt;&lt;a href=&quot;#构造函数是一个特殊的操作符&quot; class=&quot;headerlink&quot; title=&quot;构造函数是一个特殊的操作符&quot;&gt;&lt;/a&gt;构造函数是一个特殊的操作符&lt;/h5&gt;&lt;p&gt;假如我们有两个类point 和 Cpoint&lt;/p&gt;
&lt;p&gt;现在我们需要用类point去构造Cpoint对象，一般实现方式是在Cpoint中定义如下构造：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Cpoint(point);&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="construct" scheme="http://TokeyRoad.github.io/tags/construct/"/>
    
      <category term="operator" scheme="http://TokeyRoad.github.io/tags/operator/"/>
    
  </entry>
  
  <entry>
    <title>可变参数 省略号的使用</title>
    <link href="http://TokeyRoad.github.io/2020/05/11/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0-%E7%9C%81%E7%95%A5%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://TokeyRoad.github.io/2020/05/11/可变参数-省略号的使用/</id>
    <published>2020-05-11T02:00:20.000Z</published>
    <updated>2020-05-11T03:14:27.490Z</updated>
    
    <content type="html"><![CDATA[<h4 id="函数参数的传递原理"><a href="#函数参数的传递原理" class="headerlink" title="函数参数的传递原理"></a>函数参数的传递原理</h4><p>函数参数是以数据结构：栈的形式存取，从右至左入栈。</p><p>首先是参数的内存存放格式：参数存放在内存的堆栈段，在执行函数的时候，从最后一个开始入栈。因此栈底高地址，栈顶低地址。</p><p>理论上来说，只要获取到一个参数的地址，就可以通过地址偏移获取到其他参数的地址。</p><a id="more"></a><h4 id="stdarg-h"><a href="#stdarg-h" class="headerlink" title="stdarg.h"></a>stdarg.h</h4><p>下面是&lt;stdarg.h&gt;里重要的几个宏定义：</p><blockquote><p>typedef char* va_list;</p><p>void va_start(va_list ap, prev_param);</p><p>void va_arg(va_list ap, type);</p><p>void va_end(va_list ap);</p></blockquote><p>va_list 是一个字符指针，指向当前参数，取参需要用这个指针进行。</p><blockquote><ol><li>在调用参数表之前，定义一个va_list类型的变量ap;</li><li>对ap初始化，使用va_start初始化，第一个参数就是ap，第二个参数是省略号前的那个已知参数；</li><li>获取参数值，使用va_arg获取对应的参数值，第一个参数就是ap，第二个参数是你要获取值的类型，返回对应的值，获取之后该函数会把ap指向下一个参数的地址；</li><li>获取完毕之后，需要关闭指针，使用va_end关闭，参数就是ap，会把ap置空，一般va_end和va_start成对使用。</li></ol></blockquote><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">argMax</span><span class="params">(<span class="keyword">int</span> count, ...)</span> </span>&#123;</span><br><span class="line">va_list ap;</span><br><span class="line">va_start(ap, count);</span><br><span class="line"><span class="keyword">int</span> cur_max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> t = va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, t);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == i) &#123;</span><br><span class="line">cur_max = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cur_max = t &gt; cur_max ? t : cur_max;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cur_max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>, d = <span class="number">4</span>, e = <span class="number">-2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n %d \n"</span>, argMax(<span class="number">5</span>, a, b, c, d, e));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1 2 3 4 -2</span></span><br><span class="line"><span class="comment"> 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;函数参数的传递原理&quot;&gt;&lt;a href=&quot;#函数参数的传递原理&quot; class=&quot;headerlink&quot; title=&quot;函数参数的传递原理&quot;&gt;&lt;/a&gt;函数参数的传递原理&lt;/h4&gt;&lt;p&gt;函数参数是以数据结构：栈的形式存取，从右至左入栈。&lt;/p&gt;
&lt;p&gt;首先是参数的内存存放格式：参数存放在内存的堆栈段，在执行函数的时候，从最后一个开始入栈。因此栈底高地址，栈顶低地址。&lt;/p&gt;
&lt;p&gt;理论上来说，只要获取到一个参数的地址，就可以通过地址偏移获取到其他参数的地址。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="args" scheme="http://TokeyRoad.github.io/tags/args/"/>
    
  </entry>
  
  <entry>
    <title>char*赋值给std::string的陷阱</title>
    <link href="http://TokeyRoad.github.io/2020/04/29/char%E8%B5%8B%E5%80%BC%E7%BB%99string%E7%9A%84%E9%99%B7%E9%98%B1/"/>
    <id>http://TokeyRoad.github.io/2020/04/29/char赋值给string的陷阱/</id>
    <published>2020-04-29T02:47:31.000Z</published>
    <updated>2020-05-06T01:28:48.443Z</updated>
    
    <content type="html"><![CDATA[<h5 id="char-赋值给std-string的一些陷阱"><a href="#char-赋值给std-string的一些陷阱" class="headerlink" title="char*赋值给std::string的一些陷阱"></a>char*赋值给std::string的一些陷阱</h5><ol><li><p>将char <em> 赋值给std::string如果不指定长度，则会默认以\0截断（ASCII码值为0）；如果指定长度超过char</em> 的长度，用std::cout系列的函数输出时，会把不属于char*之后的内存值打印出来，而对于printf系列的函数打印时，遇到\0会被截断，因而不能完全显示。这点在打印日志时，这类字符串需要注意。</p></li><li><p>如果是单个字符和一个字符串赋值给std::string 写法是有区别的：对于char，数目是第一个参数，对于char*，数目是第二个参数。</p><blockquote><p>string(const char* s, size_t n);</p><p>string(size_t n, char c);</p></blockquote><p>假定pstr是一个字符串，那么要写成string(pstr,n)；如果pstr是一个字符，那么要写成string(n,pstr)，而此时string(pstr, n)是一个错误的写法，可能会导致你的程序产生莫名其妙的问题，因为如果pstr是一个负值，负值转换成无符号整数size_t类型，n将非常大，会导致构造字符串时length非常大导致std::string 构造时抛出异常。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;char-赋值给std-string的一些陷阱&quot;&gt;&lt;a href=&quot;#char-赋值给std-string的一些陷阱&quot; class=&quot;headerlink&quot; title=&quot;char*赋值给std::string的一些陷阱&quot;&gt;&lt;/a&gt;char*赋值给std::str
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://TokeyRoad.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>strcmp实现</title>
    <link href="http://TokeyRoad.github.io/2020/04/28/strcmp%E5%AE%9E%E7%8E%B0/"/>
    <id>http://TokeyRoad.github.io/2020/04/28/strcmp实现/</id>
    <published>2020-04-28T01:54:39.000Z</published>
    <updated>2020-04-28T07:02:45.340Z</updated>
    
    <content type="html"><![CDATA[<h4 id="strcmp函数实现以及分析"><a href="#strcmp函数实现以及分析" class="headerlink" title="strcmp函数实现以及分析"></a>strcmp函数实现以及分析</h4><h5 id="strcmp函数原型"><a href="#strcmp函数原型" class="headerlink" title="strcmp函数原型"></a>strcmp函数原型</h5><blockquote><p>int strcmp(const char<em> str1, const char</em> str2);</p><p>str1 &lt; str2 返回负值或-1</p><p>str1 == str2 返回0</p><p>str1 &gt; str2 返回正值或1</p></blockquote><h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>该函数实际上是对字符的ASCII码进行比较，实现方案：从前往后依次比较两个字符串的字符，如果不相等，就停止比较并返回结果，如果相等就继续，直到其中一个字符串遇到结束符’\0’为止。</p><h5 id="Linux源码"><a href="#Linux源码" class="headerlink" title="Linux源码"></a>Linux源码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str1, <span class="keyword">const</span> <span class="keyword">char</span>* str2)</span></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c1, c2;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">c1 = *str1++;</span><br><span class="line">c2 = *str2++;</span><br><span class="line"><span class="keyword">if</span>(c1 != c2)<span class="keyword">return</span> (c1 &lt; c2) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!c1)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己用减法实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmpNew2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str1, <span class="keyword">const</span> <span class="keyword">char</span>* str2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!(ret = *(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)str1 - *(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)str2) &amp;&amp; *str1) &#123;</span><br><span class="line">str1++;</span><br><span class="line">str2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//if (ret &lt; 0)&#123;</span></span><br><span class="line"><span class="comment">//return -1;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//else if (ret &gt; 0)&#123;</span></span><br><span class="line"><span class="comment">//return 1;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//return 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>这个函数体内没有判断参数为NULL时的情况，所以当传入NULL时程序会崩溃，<string>中的strcmp也会崩溃</string></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;strcmp函数实现以及分析&quot;&gt;&lt;a href=&quot;#strcmp函数实现以及分析&quot; class=&quot;headerlink&quot; title=&quot;strcmp函数实现以及分析&quot;&gt;&lt;/a&gt;strcmp函数实现以及分析&lt;/h4&gt;&lt;h5 id=&quot;strcmp函数原型&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://TokeyRoad.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>产生dump文件</title>
    <link href="http://TokeyRoad.github.io/2020/04/28/%E4%BA%A7%E7%94%9Fdump%E6%96%87%E4%BB%B6/"/>
    <id>http://TokeyRoad.github.io/2020/04/28/产生dump文件/</id>
    <published>2020-04-28T01:31:07.000Z</published>
    <updated>2020-04-28T01:47:49.197Z</updated>
    
    <content type="html"><![CDATA[<h4 id="程序崩溃或发生异常时产生dump文件"><a href="#程序崩溃或发生异常时产生dump文件" class="headerlink" title="程序崩溃或发生异常时产生dump文件"></a>程序崩溃或发生异常时产生dump文件</h4><p>核心API是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CreateFile()</span><br><span class="line">MinDumpWriteDump()</span><br></pre></td></tr></table></figure><p>需要包含的头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;DbgHelp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"dbghelp.lib"</span>)</span></span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;DbgHelp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"dbghelp.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LONG WINAPI <span class="title">MyCustomUnhandledFilter</span><span class="params">(struct _EXCEPTION_POINTERS *lpExceptionInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LONG iRet = EXCEPTION_EXECUTE_HANDLER;</span><br><span class="line"></span><br><span class="line">TCHAR szDumpFileName[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">SYSTEMTIME st = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">GetLocalTime(&amp;st);</span><br><span class="line">wsprintf(szDumpFileName, <span class="string">"%04d-%02d-%02d-%02d-%02d-%02d.dmp"</span>, st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wMinute);</span><br><span class="line"></span><br><span class="line">HANDLE hDumpFile = CreateFile(szDumpFileName, GENERIC_WRITE, FILE_SHARE_READ, <span class="literal">NULL</span>, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hDumpFile == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">DWORD dwErrorID = GetLastError();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to create dump file, error ID: %d\n"</span>, dwErrorID);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> iRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MINIDUMP_EXCEPTION_INFORMATION MindumpExceptionInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">MindumpExceptionInfo.ThreadId = GetCurrentThreadId();</span><br><span class="line">MindumpExceptionInfo.ExceptionPointers = lpExceptionInfo;</span><br><span class="line">MindumpExceptionInfo.ClientPointers = FALSE;</span><br><span class="line"></span><br><span class="line">BOOL bRet = MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), hDumpFile, MiniDumpNormal, &amp;MindumpExceptionInfo, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Succeeded to create dump file!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to create dump file!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CloseHandle(hDumpFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> iRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crash</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = a;</span><br><span class="line"><span class="comment">//！！程序崩溃的地方</span></span><br><span class="line">i /= j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SetUnhandledExceptionFilter(MyCustomUnhandledFilter);</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">crash(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(buf, <span class="string">"123456789"</span>);</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;程序崩溃或发生异常时产生dump文件&quot;&gt;&lt;a href=&quot;#程序崩溃或发生异常时产生dump文件&quot; class=&quot;headerlink&quot; title=&quot;程序崩溃或发生异常时产生dump文件&quot;&gt;&lt;/a&gt;程序崩溃或发生异常时产生dump文件&lt;/h4&gt;&lt;p&gt;核心API是
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://TokeyRoad.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>vector resize与reserve区别</title>
    <link href="http://TokeyRoad.github.io/2020/04/27/vector-resize%E4%B8%8Ereserve%E5%8C%BA%E5%88%AB/"/>
    <id>http://TokeyRoad.github.io/2020/04/27/vector-resize与reserve区别/</id>
    <published>2020-04-27T06:43:13.000Z</published>
    <updated>2020-04-27T07:20:13.433Z</updated>
    
    <content type="html"><![CDATA[<p>std::vector的reserve和resize的区别</p><blockquote><ol><li>reserve：分配空间，更改capacity但不改变size。</li><li>resize：分配空间，更改capacity也改变size。</li></ol></blockquote><h4 id="函数作用"><a href="#函数作用" class="headerlink" title="函数作用"></a>函数作用</h4><p>reserve是容器预留空间，不会真正的去创建数组对象，在创建对象之前，不能引用容器内的元素，当加入新元素的时候使用push_bakc()/insert()函数。</p><p>resize是改变容器大小，并且创建对象，因此调用这个函数之后，就可以引用容器内的对象，加入新元素的时候可以使用operator[]操作符，或者引用迭代器来引用元素对象。</p><h4 id="函数形式"><a href="#函数形式" class="headerlink" title="函数形式"></a>函数形式</h4><p>reserve：一个参数，即需要预留的容器的空间；</p><p>resize：两个参数，第一个是容器新的大小，第二个是要加入容器中的新元素，如果这个参数被省略，                那么就调用元素对象的默认构造函数。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span> vec;</span><br><span class="line"><span class="comment">/*****reserve*****/</span></span><br><span class="line">vec.reserve(<span class="number">10</span>);<span class="comment">//新元素还没有构造</span></span><br><span class="line"><span class="comment">//此时不能用[]访问元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">vec.push_back(i);<span class="comment">//新元素这时才构造</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****resize****/</span></span><br><span class="line">vec.resize(<span class="number">12</span>);</span><br><span class="line">vec[<span class="number">10</span>] = <span class="number">1</span>;<span class="comment">//直接操作新元素</span></span><br><span class="line">vec[<span class="number">11</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>vector在内存中是连续分布的，所以设计的时候会在所有元素外预留一部分空间，否则每次新增元素都需要重新分配，那么效率将会很低。</p><p>假如vector中存在1000个元素，两种做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="built_in">std</span>::<span class="built_in">vector</span>， 循环调用<span class="number">1000</span>次push_back(将会进行大量次数的内存分配)</span><br><span class="line"><span class="number">2.</span> <span class="built_in">std</span>::<span class="built_in">vector</span>(<span class="number">1000</span>), 循环调用<span class="number">1000</span>次push_back(就只会进行几次内存分配)</span><br></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li>当前容器预留了多大的空间？（不进行内存重分配的情况下，可以容纳多少元素）</li><li>怎么重设容器的预留大小？</li></ol><p>获取预留空间capacity()</p><p>重设预留空间大小reserve()</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>resize()和reserve()是两回事，前者影响容器中元素个数，后者影响容器预留空间。</p><blockquote><p>假设vector vec;  size() = 50 capacity() = 100 那么：</p><ol><li>resize(10);//size() == 10  10–49下标的元素被删除,capacity()=100不变，没有内存重分配。</li><li>resize(60);//size()==60    50–59下标用默认构造函数填充,capacity()=100不变，没有内存重分配。</li><li>resize(60,999);//size()==60    50–59下标用999填充,capacity()=100不变，没有内存重分配。</li><li>resize(200);//size()==200    50–199下标用默认构造函数填充,capacity()=200,自动扩容，内存重分配。</li><li>reserve(10);//size()==50  不变，没有元素被删除，capacity()=100，不变，即reserve调用不起作用。</li><li>reserve(60);//size()==50  元素不变，capacity()=100，不变，即reserve调用不起作用。</li><li>reserve(200);//size()==50  元素不变，capacity()=200，扩容，内存重分配。</li></ol><p>vector vec(10); //size()==10;capacity()==10;</p><p>vec.push_back(999);//size()=11;capacity()=15;//自动扩容，capacity()的结果是不定的，也不一定是15。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;std::vector的reserve和resize的区别&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;reserve：分配空间，更改capacity但不改变size。&lt;/li&gt;
&lt;li&gt;resize：分配空间，更改capacity也改变size。&lt;/li&gt;
&lt;/o
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://TokeyRoad.github.io/tags/C/"/>
    
      <category term="STL" scheme="http://TokeyRoad.github.io/tags/STL/"/>
    
      <category term="vector" scheme="http://TokeyRoad.github.io/tags/vector/"/>
    
  </entry>
  
  <entry>
    <title>C++关键字(2)</title>
    <link href="http://TokeyRoad.github.io/2020/03/13/C++%E5%85%B3%E9%94%AE%E5%AD%97-2/"/>
    <id>http://TokeyRoad.github.io/2020/03/13/C++关键字-2/</id>
    <published>2020-03-13T07:51:16.000Z</published>
    <updated>2020-04-27T02:00:42.945Z</updated>
    
    <content type="html"><![CDATA[<h6 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h6><a id="more"></a><p>指定构造函数或转换函数为显示，即它不能用于隐式转换和复制初始化。</p><p>explicit说明符只能出现在类定义之内的构造函数或转换函数的声明说明符序列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">A(<span class="keyword">int</span>)&#123;&#125;</span><br><span class="line">A(<span class="keyword">int</span>,<span class="keyword">int</span>)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span>)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestExpl</span><span class="params">()</span></span>&#123;</span><br><span class="line">A a1 = <span class="number">1</span>;<span class="comment">// A a1 = A(1);</span></span><br><span class="line"><span class="comment">// B b1 = 1;//error</span></span><br><span class="line"><span class="function">A <span class="title">a2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">B <span class="title">b2</span><span class="params">(<span class="number">2</span>)</span></span>;<span class="comment">//OK</span></span><br><span class="line">A a3 = &#123;<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">// A a3 = A&#123;4,5&#125;;  A&#123;4,5&#125;;</span></span><br><span class="line"><span class="comment">// B b3 = &#123;4,5&#125;;//error</span></span><br><span class="line"><span class="keyword">int</span> na1 = a1;<span class="comment">//OK</span></span><br><span class="line"><span class="comment">//int na1 = b2;//error</span></span><br><span class="line"><span class="keyword">int</span> na2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(a1);</span><br><span class="line"><span class="keyword">int</span> nb2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(b2);</span><br><span class="line">A a4 = (A)<span class="number">1</span>;</span><br><span class="line">B b4 = (B)<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h6><p>C++11引入的，指代空指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T t, U u)</span></span>&#123;</span><br><span class="line">t(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nullPointer</span><span class="params">(<span class="keyword">int</span>* a)</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"i'm a pointer\n'"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testNullPointer</span><span class="params">()</span></span>&#123;</span><br><span class="line">nullPointer(<span class="number">0</span>);</span><br><span class="line">nullPointer(<span class="literal">NULL</span>);<span class="comment">//(void*)0</span></span><br><span class="line">nullPointer(<span class="literal">nullptr</span>);<span class="comment">// std::nullptr_t</span></span><br><span class="line">func(nullPointer, <span class="literal">nullptr</span>);<span class="comment">//OK</span></span><br><span class="line">    <span class="comment">//模板推导会去找 函数nullPointer(int),而不是nullPointer(int*)</span></span><br><span class="line">func(nullPointer, <span class="number">0</span>);<span class="comment">//error </span></span><br><span class="line">func(nullPointer, <span class="literal">NULL</span>);<span class="comment">//error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="operator"><a href="#operator" class="headerlink" title="operator"></a>operator</h6><p>当重载一些特殊操作符时，一定要小心，可能会一些预想之外的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AAA</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span> &amp;()&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testOperator</span><span class="params">()</span></span>&#123;</span><br><span class="line">AAA a;</span><br><span class="line">    <span class="comment">//这里&amp;已经不是获取地址的功能了</span></span><br><span class="line"><span class="keyword">auto</span> address = &amp;a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h6><p>类型转换（类似于int转char*）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AAA</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testReinter</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(&amp;a);</span><br><span class="line"><span class="keyword">if</span>(p[<span class="number">0</span>] == <span class="number">1</span>) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"the system is little endian\n"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"the system is big endian\n"</span>;</span><br><span class="line"><span class="comment">// reinterpret_cast</span></span><br><span class="line"><span class="comment">// static_cast</span></span><br><span class="line"><span class="comment">// const_cast</span></span><br><span class="line"><span class="comment">// dynamic_cast</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// c like cast</span></span><br><span class="line"><span class="keyword">auto</span> pp = (<span class="keyword">char</span>*)(&amp;a);</span><br><span class="line"><span class="keyword">const</span> AAA bb;</span><br><span class="line"><span class="keyword">auto</span> pbb = <span class="keyword">const_cast</span>&lt;AAA*&gt;(&amp;bb);</span><br><span class="line"><span class="keyword">auto</span> cbb = (AAA*)(&amp;bb);</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">auto</span> cc = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(c);</span><br><span class="line"><span class="keyword">auto</span> ccc = (<span class="keyword">char</span>)c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="static"><a href="#static" class="headerlink" title="static"></a>static</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量在其他文本extern声明后可访问，static不允许</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> globalA = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStatic</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> localStatic = <span class="number">0</span>;</span><br><span class="line">++localStatic;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; localStatic &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>&#123;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//sizeof(S) = 1 // S == empty</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S:s = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testStaticAssert</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">static_assert</span>((<span class="keyword">sizeof</span>(<span class="keyword">int</span>) == <span class="number">4</span>) &amp;&amp; <span class="string">"only work for int for 32 bit"</span>);</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">assert(a == b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="static-assert-amp-assert"><a href="#static-assert-amp-assert" class="headerlink" title="static_assert&amp;assert"></a>static_assert&amp;assert</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testStaticAssert</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//static_assert在编译期检查，assert在运行期检查 debug模式下生效</span></span><br><span class="line"><span class="keyword">static_assert</span>((<span class="keyword">sizeof</span>(<span class="keyword">int</span>) == <span class="number">4</span>) &amp;&amp; <span class="string">"only work for int for 32 bit"</span>);</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">assert(a == b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> ulong;</span><br><span class="line"><span class="function">class <span class="title">testTypedef</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, ulong&gt; Group;</span><br><span class="line">Group a;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aa</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// std::map&lt;int, ulong&gt;::itertor iter = a.find(10);</span></span><br><span class="line"><span class="comment">// Group::iteator iter = a.find(10);</span></span><br><span class="line"><span class="keyword">auto</span> iter = a.find(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;explicit&quot;&gt;&lt;a href=&quot;#explicit&quot; class=&quot;headerlink&quot; title=&quot;explicit&quot;&gt;&lt;/a&gt;explicit&lt;/h6&gt;
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://TokeyRoad.github.io/tags/C/"/>
    
      <category term="关键字" scheme="http://TokeyRoad.github.io/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>深入学习C++关键字</title>
    <link href="http://TokeyRoad.github.io/2020/03/12/C++%E5%85%B3%E9%94%AE%E5%AD%97-1/"/>
    <id>http://TokeyRoad.github.io/2020/03/12/C++关键字-1/</id>
    <published>2020-03-12T03:26:15.000Z</published>
    <updated>2020-03-13T08:12:30.326Z</updated>
    
    <content type="html"><![CDATA[<h6 id="alignas-amp-alignof"><a href="#alignas-amp-alignof" class="headerlink" title="alignas&amp;alignof"></a>alignas&amp;alignof</h6><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Empty</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct <span class="title">alignas</span><span class="params">(<span class="number">64</span>)</span> Empty64 </span>&#123;&#125;;</span><br><span class="line"><span class="comment">//0会被忽略</span></span><br><span class="line"><span class="function">struct <span class="title">alignas</span><span class="params">(<span class="number">0</span>)</span> BB </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct <span class="title">alignas</span><span class="params">(<span class="number">8</span>)</span> Double </span>&#123;</span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Obj</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//alignof </span></span><br><span class="line"><span class="keyword">int</span> s_obj = <span class="keyword">sizeof</span>(Obj);<span class="comment">//8</span></span><br><span class="line"><span class="keyword">int</span> a_obj = <span class="keyword">alignof</span>(Obj);<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alignInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Alignment of"</span> <span class="string">"\n"</span></span><br><span class="line"><span class="string">"- char:"</span> &lt;&lt; <span class="keyword">alignof</span>(<span class="keyword">char</span>)&lt;&lt; <span class="string">"\n"</span><span class="comment">//1</span></span><br><span class="line"><span class="string">"- pointer:"</span> &lt;&lt; <span class="keyword">alignof</span>(<span class="keyword">int</span>*)&lt;&lt; <span class="string">"\n"</span><span class="comment">//8 4</span></span><br><span class="line"><span class="string">"- empty class:"</span> &lt;&lt; <span class="keyword">alignof</span>(Empty)&lt;&lt; <span class="string">"\n"</span><span class="comment">//1</span></span><br><span class="line"><span class="string">"- class Foo:"</span> &lt;&lt; <span class="keyword">alignof</span>(Foo)&lt;&lt; <span class="string">"\n"</span><span class="comment">//4</span></span><br><span class="line"><span class="string">"- alignas(64) Empty:"</span> &lt;&lt; <span class="keyword">alignof</span>(Empty64)&lt;&lt; <span class="string">"\n"</span><span class="comment">//64</span></span><br><span class="line"><span class="string">"- alignas(1) Double:"</span> &lt;&lt; <span class="keyword">alignof</span>(Double)&lt;&lt; <span class="string">"\n"</span>;<span class="comment">//8(WIN下编译报错)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="and-amp-amp-and-eq"><a href="#and-amp-amp-and-eq" class="headerlink" title="and&amp;&amp;and_eq"></a>and&amp;&amp;and_eq</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iso646.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AND</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//and 等价于 &amp;</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">b and_eq a;</span><br><span class="line"><span class="comment">//等价于 b &amp;= a;</span></span><br><span class="line"><span class="comment">//等价于 b = b &amp; a;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="asm"><a href="#asm" class="headerlink" title="asm"></a>asm</h6><p>用于在C++代码中嵌入汇编语言，不常用</p><h6 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h6><ol><li>对于变量，指定将要从其初始值设定项自动推断出要声明的变量的类型。</li><li>对于函数，指定将其从其return语句推导返回类型。</li><li>对于非类型模板参数，指定将从参数推导类型。</li></ol><h6 id="bitand-amp-bitor"><a href="#bitand-amp-bitor" class="headerlink" title="bitand&amp;bitor"></a>bitand&amp;bitor</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showBitAndor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> a = <span class="number">3L</span>;</span><br><span class="line"><span class="keyword">auto</span> b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">auto</span> c = a bitand b;<span class="comment">//等价于 &amp;</span></span><br><span class="line"><span class="keyword">auto</span> d = a bitor b;<span class="comment">//等价于 |</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行时计算</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n &lt;= <span class="number">1</span> ? <span class="number">1</span> : (n * fact( n - <span class="number">1</span>)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译时计算</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n &lt;= <span class="number">1</span> ? <span class="number">1</span> : (n * factorial( n - <span class="number">1</span>)); &#125;</span><br></pre></td></tr></table></figure><p>constexpr所修饰的变量一定是编译期可求值的，所修饰的函数在所有的参数都是constexpr时，一定会返回constexpr。</p><p>constexpr的好处：</p><ol><li>是一种很强的约束，更好的保证程序的正确语义不被破坏。</li><li>编译期可以在编译期对constexpr的代码进行非常大的优化，比如将用到的constexpr表达式都直接替换成最终结果等。</li><li>相对于宏来说，没有额外的开销，更安全可靠。</li></ol><h6 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testConstCast</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> j = <span class="number">3</span>;<span class="comment">//j is declared const</span></span><br><span class="line"><span class="comment">//const int*</span></span><br><span class="line"><span class="keyword">int</span>* pj = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;j); </span><br><span class="line">*pj = <span class="number">4</span>;<span class="comment">//undefined behavior!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const_cast一般不推荐使用，出现的时候大多数意味着代码结构出现了问题，const本身表示不可变的，const_cast转换 却破坏了这个不变性。</p><h6 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h6><p>用于获取变量或者表达式的类型或者函数的返回类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span> <span class="keyword">double</span> x;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testDecl</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> A* a = <span class="keyword">new</span> A&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> aa = a-&gt;x;</span><br><span class="line"><span class="keyword">decltype</span>(a-&gt;x) y;<span class="comment">//double</span></span><br><span class="line"><span class="keyword">auto</span>&amp; cc = y;</span><br><span class="line"><span class="keyword">decltype</span>((a-&gt;x)) z = y;<span class="comment">//double&amp;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="comment">//后置函数类型</span></span><br><span class="line">auto add(T a, U b) -&gt; decltype(a+b)&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">error cant compile</span></span><br><span class="line"><span class="comment"> decltype(a+b) add(T a, U b)&#123;</span></span><br><span class="line"><span class="comment">  return a+b;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testDecltype</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> cc = add(<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//cc int</span></span><br><span class="line"><span class="keyword">auto</span> dd = add(<span class="number">1.0</span>, <span class="number">3</span>);<span class="comment">//dd double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h6><p>沿继承层级向上、向下及侧向，安全地转换 到其他类的指针和引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span>&#123;</span><span class="keyword">virtual</span> ~Base()&#123;&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestDyn</span><span class="params">()</span></span>&#123;</span><br><span class="line">Base *b1 = <span class="keyword">new</span> Base;</span><br><span class="line"><span class="keyword">if</span>(Derived *d = <span class="keyword">dynamic_cast</span>&lt;Derived*&gt;(b1))&#123;<span class="comment">//fail</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"downcast from b1 to d successful\n"</span>;</span><br><span class="line">d-&gt;name();<span class="comment">//safe to call</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Base *b2 = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="keyword">if</span>(Derived *d = <span class="keyword">dynamic_cast</span>&lt;Derived *&gt;(b2))&#123;<span class="comment">//success</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"downcast from b2 to d successful\n"</span>;</span><br><span class="line">d-&gt;name();<span class="comment">//safe to call</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Base bb;</span><br><span class="line"><span class="comment">//fail throw bad_cast exception</span></span><br><span class="line"><span class="comment">//Derived&amp; cc = dynamic_cast&lt;Derived&amp;&gt;(bb);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> b1;</span><br><span class="line">    <span class="keyword">delete</span> b2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;alignas-amp-alignof&quot;&gt;&lt;a href=&quot;#alignas-amp-alignof&quot; class=&quot;headerlink&quot; title=&quot;alignas&amp;amp;alignof&quot;&gt;&lt;/a&gt;alignas&amp;amp;alignof&lt;/h6&gt;
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://TokeyRoad.github.io/tags/C/"/>
    
      <category term="关键字" scheme="http://TokeyRoad.github.io/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>libcurl 编译使用</title>
    <link href="http://TokeyRoad.github.io/2019/07/19/libcurl-%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/"/>
    <id>http://TokeyRoad.github.io/2019/07/19/libcurl-编译使用/</id>
    <published>2019-07-19T08:20:30.000Z</published>
    <updated>2019-07-19T09:12:25.607Z</updated>
    
    <content type="html"><![CDATA[<p>工作的原因，需要使用libcurl库，这里整理一下过程，方便日后食用。（很大一部分来自网络资源，不喜勿喷）</p><h4 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h4><p>cURL、libcurl 还有 curl，他们究竟是什么？</p><p>也就是说，我们需要去了解下 libcurl 及其相关的概念。</p><h4 id="二、cURL、libcurl-还有-curl-傻傻分不清楚-T-T"><a href="#二、cURL、libcurl-还有-curl-傻傻分不清楚-T-T" class="headerlink" title="二、cURL、libcurl 还有 curl 傻傻分不清楚 T_T"></a>二、cURL、libcurl 还有 curl 傻傻分不清楚 T_T</h4><p>可能对于新人来说，就连 cURL、libcurl 和 curl 的概念都是分不清楚的。这不怪我们，确实关于这一点，官方网站都没有说的很清楚，但是在源代码中的 FAQ 文档中却说的非常明白。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">What is cURL? </span><br><span class="line">cURL is the name of the project. The name is a play on ‘Client for URLs’, originally with URL spelled in uppercase to make it obvious it deals with URLs. The fact ti can also be pronounced ‘see URL’ alse helped, it works as an abbreviation for “Client URL Request Library” or why not the recursive version: “Curl URL Request Library”.</span><br></pre></td></tr></table></figure><p>简而言之，cURL 是一个项目的名称。是 Client for URLs、see URL、Client URL Request Library 或者 Curl URL Request Library 的缩写，也就是一个客户端 URL 请求库的项目。</p><p>那么什么是 libcurl 呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The cURL project produces two products: </span><br><span class="line">libcurl </span><br><span class="line">A free and easy-to-use client-side URL transfer library. </span><br><span class="line">… </span><br><span class="line">curl </span><br><span class="line">A command line tool for getting or sending files using URL syntax.</span><br></pre></td></tr></table></figure><p>上面这段话很清晰的表现出了 cURL 与 libcurl 以及 curl 的关系，也就是说：</p><p>cURL 这个项目包含了 libcurl 和 curl 两个产品。<br>其中，libcurl 是一个客户端的 URL 支持库；而 curl 就是一个使用了 libcurl 库写出来的命令行工具，其可以使用 URL 标识来请求或者发送文件。</p><p>也就是说，如果我们想要编写代码来控制有关网络的行为的话，我们就需要使用到 libcurl 库而不是 curl 命令行工具；而如果我们想要直接调用 curl 命令行工具来完成一些操作，比如将其嵌入到脚本代码中去，那么这个时候，我们才会用到 curl 命令行工具。</p><p>现在搞清楚了一些必要的概念，以及一些有趣的题外话，现在让我们来看看，我们要在 Unix 环境和 Windows 环境下编译和使用 libcurl，我们需要哪些东西，以及我们能在哪些地方获取到这些东西。</p><h4 id="三、资料的获取"><a href="#三、资料的获取" class="headerlink" title="三、资料的获取"></a>三、资料的获取</h4><p>我们想要了解 libcurl 这个库，最直接的资源获取来源当然是官方网站： </p><p><a href="https://curl.haxx.se/" target="_blank" rel="noopener">curl官网</a></p><p>可能对于新手来说，一点开就会觉得有些迷茫，因为可能分不清楚 curl 和 libcurl 的区别。这也是为什么我一定要在介绍资料来源之前介绍 cURL、libcurl 和 curl 三者的区别的原因。相信在我上一节花了那么大篇幅来介绍这三者的区别之后，你应该不会那么迷茫了。 </p><p>对于我们开发者来说，了解 libcurl 应该是最重要的。因为我们是想要使用 libcurl 库来编写代码的，而不是来学习 curl 的使用方法的。</p><p>通过多次尝试的我最后发现，下载 Source Archives 也就是源代码的版本，是最好的。原因嘛，当你下载下来之后，解压到本地看看里面的内容你就知道了，因为它，实在是太完善了： </p><p>简单的说几个：</p><ol><li><p>docs 文件夹<br>这里面有丰富的说明文档以及 libcurl 的运行示例代码。<br>有关 cURL、libcurl 以及 curl 的概念的定义，就是在这个文件夹下的 FAQ 文件里面。后面将要讲述的在 Unix 下编译使用 libcurl 库的内容，也是来源于这个文件夹下的 INSTALL.md 文件。除此之外，这个文件夹下还有很多说明文档，有待大家去探索去发现去思考去使用。<br>这个文件夹下的 examples 文件夹下，有着丰富的示例代码，其中的 https.c 就是本篇博客的测试运行代码。</p></li><li><p>winbuild 文件夹<br>这个文件夹介绍了如何使用 Visual Studio 编译 libcurl 的方法。基于 Windows 环境的编译与使用就是参考的这个文件夹下的 BUILD.WINDOWS.txt 文件中的内容。<br>并且这个文件夹下提供了编译的配置信息文件，大大方便了我们在 Windows 下使用 Visual Studio 编译 libcurl 的工作。</p></li><li><p>configure<br>这个脚本文件用于在 Unix 下配置 libcurl 的安装信息，用来之后安装 libcurl 环境使用。</p></li></ol><p>等等等等，curl 的源代码文件中，包含了很多很多东西。有很多你可能接触不到，我们可以在学习中在使用中慢慢去发掘去使用。</p><h4 id="四、libcurl-在-Unix-环境下的编译"><a href="#四、libcurl-在-Unix-环境下的编译" class="headerlink" title="四、libcurl 在 Unix 环境下的编译"></a>四、libcurl 在 Unix 环境下的编译</h4><p>让我们步入正题吧，libcurl 在 Unix 环境下怎么编译与使用呢？</p><p>这个问题在 curl-7.61.0\docs 下的 INSTALL.md 文件中讲述的非常清晰：</p><blockquote><p>A normal Unix installation is made in three or four steps (after you’ve unpacked the source archive):<br>./configure<br>make<br>make test (optional) </p><p>make install</p></blockquote><p>也就是说，在类 Unix 环境下，我们都可以在源代码文件目录下使用以下四句指令完成 libcurl 库的安装与编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./configure</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make <span class="built_in">test</span> (optional)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure><p>其中第三步，也就是测试那步是非常耗时间的，为了节约时间可以省略。<br>另外第四步，可能会涉及到权限问题，如果出现这个问题，需要切换到 root 权限安装。</p><p>简单总结下步骤吧：</p><ol><li><p>使用 WinSCP 以及类似的工具，将下载下来的源代码文件放置到指定目录下，比如我现在将下载下来的 curl-7.61.0.zip 文件放到了 RedHat 7.2 环境中的 /home/wangying/libcurl 文件夹下</p></li><li><p>解压上一步放置的源代码文件</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ unzip curl<span class="number">-7.61</span><span class="number">.0</span>.zip</span><br></pre></td></tr></table></figure></li><li><p>解压完成后进入 curl-7.61.0 文件夹下，运行上述所说的 4 条指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./configure</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make <span class="built_in">test</span> (optional)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure><p>建议大家省去第三步，因为实在太耗费时间了（T_T）。</p></li><li><p>执行完了之后，现在直接运行 curl 还是会显示系统默认自带的版本。我们需要进入到默认安装的目录下 <code>/usr/local/bin</code> 中使用下列命令运行：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="string">./curl</span> <span class="params">--version</span></span><br><span class="line">$ <span class="string">./curl-config</span> <span class="params">--version</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="/2019/07/19/libcurl-编译使用/libcurl_1.png" alt="libcurl_1"></p><p>上述两行代码会输出 curl 以及 curl-config 两个工具的版本信息，与你下载的版本一致即为安装成功。根据我的试验经验，一旦你运行了上述两行代码，系统自动会记录下来这两个工具的路径，不过为了确保系统找得到这两个工具，你可以单独设置下环境变量。</p><ol start="5"><li><p>libcurl 库的相关头文件与库文件所在地方，可以通过下列命令查看（这会在下一节中的使用中提到）</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl-<span class="built_in">config</span> <span class="comment">--cflags</span></span><br><span class="line">$ curl-<span class="built_in">config</span> <span class="comment">--libs</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="/2019/07/19/libcurl-编译使用/libcurl_2.png" alt="libcurl_2"></p><p>其中 –cflags 输出的我们编写代码时需要包含的头文件路径， –libs 输出的是我们编写代码时需要包含的库文件路径，我们只需要将上述两行简单的添加到编译指令中即可运行我们的示例代码。</p><h4 id="五、libcurl-在-Unix-环境下的使用"><a href="#五、libcurl-在-Unix-环境下的使用" class="headerlink" title="五、libcurl 在 Unix 环境下的使用"></a>五、libcurl 在 Unix 环境下的使用</h4><p>让我们点开源代码 docs 目录下的 examples 文件夹，其中的 README 文件详细介绍了 libcurl 示例代码的使用方式：</p><blockquote><p>Most examples should build fine using a command line like this:<br>$ curl-config –cc –cflags –libs -o example example.c<br>Some compilers don’t like having the arguments in this order but instead want you do reorganize them like: </p><p>$ <code>curl-config --cc</code> -o example example.c <code>curl-config --cflags --libs</code></p></blockquote><p>也就是说，只要我们在上一步中成功安装了 curl 以及 curl-config 工具，在这一步中，我们只需要简单的运行这行指令即可自动的指定代码的包含头文件以及库文件信息：</p><blockquote><p>$ <code>curl-config --cc</code> -o example example.c <code>curl-config --cflags --libs</code></p></blockquote><p>让我们来尝试下 examples 中的 https.c 文件的编译（因为 https.c 文件可以在源代码中看到，这里就不再详细展示文件内容）：</p><blockquote><p>$ <code>curl-config --cc</code> -o https https.c <code>curl-config --cflags --libs</code></p></blockquote><p><img src="/2019/07/19/libcurl-编译使用/libcurl_3.png" alt="libcurl_3"></p><p>可见，https.c 的运行是非常成功的，成功返回了获取的 html 信息。</p><p>同样的示例我在 Ubuntu 18.04上运行通过，相信在类 Unix 上应该都是没有问题的。</p><h4 id="六、libcurl-在-Windows-环境下的编译"><a href="#六、libcurl-在-Windows-环境下的编译" class="headerlink" title="六、libcurl 在 Windows 环境下的编译"></a>六、libcurl 在 Windows 环境下的编译</h4><p>libcurl 在 Windows 环境下的编译，在源代码文件夹下的 docs 文件夹下的 INSTALL 文件中有所提及，但是讲述的稍微有些晦涩难懂。欣喜的是源代码根目录下直接提供了一个 winbuilds 文件夹方便我们完成在 Windows 环境下的编译工作。</p><p>这里，让我们看看 winbuild 文件夹下的 BUILD.WINDOWS.txt 文件的内容（这个文件中的内容非常详尽，这里不再粘贴出来）。</p><p>我简单总结下步骤：</p><ol><li>运行 Developer Command Prompt for VS 工具 </li></ol><ol start="2"><li><p>进入到源代码文件夹下的 winbuild 目录下</p></li><li><p>运行下列指令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmake /f Makefile.vc <span class="attribute">mode</span>=&lt;static <span class="keyword">or</span> dll&gt; &lt;options&gt;</span><br></pre></td></tr></table></figure><p>其中的 mode= 后面填写 static 是编译静态库， dll 是动态库；另外 options 的填写说明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">where &lt;options&gt; is one or many of:</span><br><span class="line">  VC=&lt;6,7,8,9,10,11,12,14,15&gt;    - VC versions</span><br><span class="line">  WITH_DEVEL=&lt;path&gt;              - Paths for the development files (SSL, zlib, etc.)</span><br><span class="line">                                   Defaults to sibbling directory deps: ../deps</span><br><span class="line">                                   Libraries can be fetched at http://windows.php.net/downloads/php-sdk/deps/</span><br><span class="line">                                   Uncompress them into the deps folder.</span><br><span class="line">  WITH_SSL=&lt;dll or static&gt;       - Enable OpenSSL support, DLL or static</span><br><span class="line">  WITH_NGHTTP2=&lt;dll or static&gt;   - Enable HTTP/2 support, DLL or static</span><br><span class="line">  WITH_MBEDTLS=&lt;dll or static&gt;   - Enable mbedTLS support, DLL or static</span><br><span class="line">  WITH_CARES=&lt;dll or static&gt;     - Enable c-ares support, DLL or static</span><br><span class="line">  WITH_ZLIB=&lt;dll or static&gt;      - Enable zlib support, DLL or static</span><br><span class="line">  WITH_SSH2=&lt;dll or static&gt;      - Enable libSSH2 support, DLL or static</span><br><span class="line">  ENABLE_SSPI=&lt;yes or no&gt;        - Enable SSPI support, defaults to yes</span><br><span class="line">  ENABLE_IPV6=&lt;yes or no&gt;        - Enable IPv6, defaults to yes</span><br><span class="line">  ENABLE_IDN=&lt;yes or no&gt;         - Enable use of Windows IDN APIs, defaults to yes</span><br><span class="line">                                   Requires Windows Vista or later</span><br><span class="line">  ENABLE_WINSSL=&lt;yes or no&gt;      - Enable native Windows SSL support, defaults to yes</span><br><span class="line">  GEN_PDB=&lt;yes or no&gt;            - Generate Program Database (debug symbols for release build)</span><br><span class="line">  DEBUG=&lt;yes or no&gt;              - Debug builds</span><br><span class="line">  MACHINE=&lt;x86 or x64&gt;           - Target architecture (default is x86)</span><br><span class="line">  CARES_PATH=&lt;path to cares&gt;     - Custom path for c-ares</span><br><span class="line">  MBEDTLS_PATH=&lt;path to mbedTLS&gt; - Custom path for mbedTLS</span><br><span class="line">  NGHTTP2_PATH=&lt;path to HTTP/2&gt;  - Custom path for nghttp2</span><br><span class="line">  SSH2_PATH=&lt;path to libSSH2&gt;    - Custom path for libSSH2</span><br><span class="line">  SSL_PATH=&lt;path to OpenSSL&gt;     - Custom path for OpenSSL</span><br><span class="line">  ZLIB_PATH=&lt;path to zlib&gt;       - Custom path for zlib</span><br></pre></td></tr></table></figure><p>大家可根据需要填写，这里我填写的命令是：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmake /f Makefile.vc <span class="attribute">mode</span>=static</span><br></pre></td></tr></table></figure></li><li><p>待编译完成，进入源代码文件夹下，其中多出来了一个 builds 文件夹，其中名字长度最短的那个点击进去，可以看到 bin、include 和 lib 子文件夹，其中 bin 中就是编译出来的 curl 命令行工具，include 就是我们在编写代码中需要包含的头文件，lib 就是我们在编写代码中需要包含的静态库文件（不过仍然需要 CRT 静态库的另外链接） </p></li></ol><p>至此，使用 Visual Studio 2017 编译工具静态编译 libcurl 库的工作就算是完成了。这里值得注意的是，Windows 平台下的编译选项有很多，我们可以根据需要配置自己想要的 libcurl 库。比如静态动态，比如使用 VC 12 13 14 15 版本等等等等。</p><p>在这篇博客里，主要展示了使用静态库的方式。接下来，我们来看看如何使用刚刚编译出来的这些文件进行示例代码的运行使用。</p><h4 id="七、libcurl-在-Windows-环境下的使用"><a href="#七、libcurl-在-Windows-环境下的使用" class="headerlink" title="七、libcurl 在 Windows 环境下的使用"></a>七、libcurl 在 Windows 环境下的使用</h4><p>这里，我简单总结下步骤：</p><ol><li><p>使用 Visual Studio 2017 新建一个 Visual C++ 的空项目，并将示例代码 https.c 拷贝到项目中去</p></li><li><p>为了使得我们的 https.c 代码运行后控制台不会一闪而过，我们需要修改 https.c 的代码，不多，只需要添加两行即可：</p></li></ol><p>// 添加在 include 的地方</p><p>#include &lt;stdlib.h&gt;<br>// 添加在 return 语句之前<br>system(“pause”);</p><p>这样，就可以使得控制台窗口运行完代码逻辑之后暂停，不至于关闭掉窗口了。</p><ol start="3"><li>将上一节中生成的 include 文件夹以及 lib 文件夹拷贝到项目中去 </li></ol><ol start="4"><li><p>配置 VC++ 目录：需要让代码能够找到需要包含的头文件和静态库文件<br> 包含目录添加：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// <span class="variable">$(SolutionDir)</span> 是当前的解决方案目录</span><br><span class="line"><span class="variable">$(SolutionDir)</span><span class="keyword">include</span></span><br></pre></td></tr></table></figure><p>库目录添加：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $(SolutionDir) 是当前的解决方案目录</span></span><br><span class="line"><span class="symbol">$</span>(SolutionDir)lib</span><br></pre></td></tr></table></figure><p><img src="/2019/07/19/libcurl-编译使用/libcurl_4.png" alt="libcurl_4"></p></li></ol><ol start="5"><li><p>配置需要链接的静态库文件 链接器-&gt;输入-&gt;附加依赖项</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">libcurl_a.lib</span><br><span class="line">Ws2_32.lib</span><br><span class="line">Wldap32.lib</span><br><span class="line">winmm.lib</span><br><span class="line">Crypt32.lib</span><br><span class="line">Normaliz.lib</span><br></pre></td></tr></table></figure><p><img src="/2019/07/19/libcurl-编译使用/libcurl_5.png" alt="libcurl_5"></p></li></ol><ol start="6"><li>修改预处理器定义：</li></ol><p>C/C++ -&gt; 预处理器 -&gt; 预处理器定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加 </span></span><br><span class="line">CURL_STATICLIB;</span><br></pre></td></tr></table></figure><ol start="7"><li><p>编译运行，顺利的话能够看到结果如下 </p><p><img src="/2019/07/19/libcurl-编译使用/libcurl_6.png" alt="libcurl_6"></p></li></ol><p>至此，完结撒花，^_^</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工作的原因，需要使用libcurl库，这里整理一下过程，方便日后食用。（很大一部分来自网络资源，不喜勿喷）&lt;/p&gt;
&lt;h4 id=&quot;一、引言&quot;&gt;&lt;a href=&quot;#一、引言&quot; class=&quot;headerlink&quot; title=&quot;一、引言&quot;&gt;&lt;/a&gt;一、引言&lt;/h4&gt;&lt;p&gt;c
      
    
    </summary>
    
      <category term="环境配置" scheme="http://TokeyRoad.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="libcurl" scheme="http://TokeyRoad.github.io/tags/libcurl/"/>
    
  </entry>
  
</feed>
