<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TokeyRoad</title>
  
  <subtitle>Never underestimate your power to change yourself!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://TokeyRoad.github.io/"/>
  <updated>2020-11-22T15:11:41.567Z</updated>
  <id>http://TokeyRoad.github.io/</id>
  
  <author>
    <name>Tokey</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解决git每次推送都要输入用户名密码的方案</title>
    <link href="http://TokeyRoad.github.io/2020/11/22/%E8%A7%A3%E5%86%B3git%E6%AF%8F%E6%AC%A1%E6%8E%A8%E9%80%81%E9%83%BD%E8%A6%81%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E7%9A%84%E6%96%B9%E6%A1%88/"/>
    <id>http://TokeyRoad.github.io/2020/11/22/解决git每次推送都要输入用户名密码的方案/</id>
    <published>2020-11-22T15:08:41.000Z</published>
    <updated>2020-11-22T15:11:41.567Z</updated>
    
    <content type="html"><![CDATA[<p>打开命令行，输入以下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><p>执行完毕会在在当前系统用户文件夹下生成一个名为.git-credentials的文件，如：C:\Users\Administrator\ .git-credentials，再次提交代码时，输入密码后会将用户名密码以明文的方式保存在其中。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;打开命令行，输入以下命令:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=
      
    
    </summary>
    
      <category term="环境配置" scheme="http://TokeyRoad.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="git" scheme="http://TokeyRoad.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>重装系统之后hexo博客恢复</title>
    <link href="http://TokeyRoad.github.io/2020/11/22/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%90%8Ehexo%E5%8D%9A%E5%AE%A2%E6%81%A2%E5%A4%8D/"/>
    <id>http://TokeyRoad.github.io/2020/11/22/重装系统之后hexo博客恢复/</id>
    <published>2020-11-22T13:57:11.000Z</published>
    <updated>2020-11-22T14:04:25.825Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-安装node-js和git"><a href="#1-安装node-js和git" class="headerlink" title="1.安装node.js和git"></a>1.安装node.js和git</h3><p>这个不用多说，直接下载安装就行了。</p><h3 id="2-配置-git-个人信息，生成新的-ssh-密钥："><a href="#2-配置-git-个人信息，生成新的-ssh-密钥：" class="headerlink" title="2.配置 git 个人信息，生成新的 ssh 密钥："></a>2.配置 git 个人信息，生成新的 ssh 密钥：</h3><p>git config –global user.name “xxxxxx”<br> git config –global user.email “xxxxxx”<br> ssh-keygen -t rsa -C “xxxxxxxx(邮箱)”</p><h3 id="3-添加公钥"><a href="#3-添加公钥" class="headerlink" title="3.添加公钥"></a>3.添加公钥</h3><p>在用户文件夹.ssh 文件里面把公钥复制出来粘贴到github个人设置的ssh位置。</p><h3 id="4-安装hexo"><a href="#4-安装hexo" class="headerlink" title="4.安装hexo"></a>4.安装hexo</h3><p> npm install hexo-cli -g</p><h3 id="5-删除博客文件夹文件，保留部分"><a href="#5-删除博客文件夹文件，保留部分" class="headerlink" title="5.删除博客文件夹文件，保留部分"></a>5.删除博客文件夹文件，保留部分</h3><p>打开原来的博客文件夹,只需保留_config.yml，theme/，source/，scaffolds/，package.json，.gitignore 这些项目，删除其他的文件。</p><h3 id="6-git-bush"><a href="#6-git-bush" class="headerlink" title="6.git bush"></a>6.git bush</h3><p>在本文件夹下git bush,运行npm install</p><h3 id="7-安装部署插件"><a href="#7-安装部署插件" class="headerlink" title="7.安装部署插件"></a>7.安装部署插件</h3><p>npm install hexo-deployer-git –save</p><h3 id="8-测试"><a href="#8-测试" class="headerlink" title="8.测试"></a>8.测试</h3><p>此时就可以hexo g &amp;&amp; hexo d 测试是否成功了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-安装node-js和git&quot;&gt;&lt;a href=&quot;#1-安装node-js和git&quot; class=&quot;headerlink&quot; title=&quot;1.安装node.js和git&quot;&gt;&lt;/a&gt;1.安装node.js和git&lt;/h3&gt;&lt;p&gt;这个不用多说，直接下载安装就行了。&lt;
      
    
    </summary>
    
      <category term="环境配置" scheme="http://TokeyRoad.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="git" scheme="http://TokeyRoad.github.io/tags/git/"/>
    
      <category term="hexo" scheme="http://TokeyRoad.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>智能指针类</title>
    <link href="http://TokeyRoad.github.io/2020/05/29/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%B1%BB/"/>
    <id>http://TokeyRoad.github.io/2020/05/29/智能指针类/</id>
    <published>2020-05-29T02:00:55.000Z</published>
    <updated>2020-06-01T09:42:53.915Z</updated>
    
    <content type="html"><![CDATA[<h4 id="std-auto-ptr"><a href="#std-auto-ptr" class="headerlink" title="std::auto_ptr"></a>std::auto_ptr</h4><p>基本用法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种形式</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; ap1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//第二种形式</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; ap2;</span><br><span class="line">ap2.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>智能指针对象ap1和ap2均持有一个在堆上分配int对象，这两块堆内存在对象释放时得以释放。</p><p>std::auto_ptr 经常误用的是复制操作，当复制auto_ptr对象时(拷贝复制或operator=复制)，原对象的堆内存会转移到复制的对象上，原指针就空了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; ap1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//拷贝复制</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; ap2(ap1);</span><br><span class="line"><span class="keyword">if</span> (ap1.get()!= <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ap1 is not NULL"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ap1 is NULL"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ap2.get() != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ap2 is not NULL"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ap2 is NULL"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//operator=复制</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; ap3(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; ap4 = ap3;</span><br><span class="line"><span class="keyword">if</span> (ap3.get() != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ap3 is not NULL"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ap3 is NULL"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ap4.get() != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ap4 is not NULL"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ap4 is NULL"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">ap1 is <span class="literal">NULL</span></span><br><span class="line">ap2 is <span class="keyword">not</span> <span class="literal">NULL</span></span><br><span class="line">ap3 is <span class="literal">NULL</span></span><br><span class="line">ap4 is <span class="keyword">not</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p>ap1的堆内存转移到了ap2，ap3的堆内存转移到了ap4</p><p>因此在使用中，应尽量避免使用std::auto_ptr（C++11之后 该指针已被弃用，不应该再使用它）</p><h4 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h4><p>std::unique_ptr对指向的堆内存具有唯一控制权，引用计数永远为1，对象销毁时释放对应的堆内存。</p><p>基本使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种形式</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//第二种形式</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up2;</span><br><span class="line">up2.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//第三种形式</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up3 = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>注</p><blockquote><p>std::unique_ptr禁止复制操作</p><p>std::unique_ptr类的拷贝构造函数和赋值operator=函数 都被标记为=delete</p></blockquote><p>禁止复制操作存在特例，即可以通过一个函数返回一个std::unique_ptr：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; func(<span class="keyword">int</span> val) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up(<span class="keyword">new</span> <span class="keyword">int</span>(val));</span><br><span class="line"><span class="keyword">return</span> up;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up4 = func(<span class="number">3</span>);<span class="comment">//std::move</span></span><br></pre></td></tr></table></figure><p>实现方法：使用移动构造，即std::move</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up5(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up6(<span class="built_in">std</span>::move(up5));</span><br></pre></td></tr></table></figure><p>std::move将up5持有的堆内存转移给了up6，最后up5不再持有堆内存，即是一个空的智能指针对象。</p><p>std::move操作是否有意义，取决于是否实现了移动构造(Move Constructor)和移动赋值(operator=)运算符，而unique_ptr正好实现了这两个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Deletor&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unique_ptr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unique_ptr</span>(<span class="built_in">unique_ptr</span>&amp;&amp; rhs)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_pT = ths.m_pT;</span><br><span class="line">        rhs.m_pT = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unique_ptr</span>&amp; <span class="keyword">operator</span>=(<span class="built_in">unique_ptr</span>&amp;&amp; rhs)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_pT = rhs.m_pT;</span><br><span class="line">        rhs.m_pT = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* m_pT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::unique_ptr不仅可以持有一个堆对象，也可以持有一组堆对象，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>[]&gt; up7(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">up7[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; up7[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//std::unique_ptr&lt;int&gt; up8(std::move(up7[2]));//错误</span></span><br></pre></td></tr></table></figure><p>std::shared_ptr和std::weak_ptr也可以持有一组堆对象，用法与std::unique_ptr一致。</p><h5 id="自定义-智能指针对象持有的资源的释放函数"><a href="#自定义-智能指针对象持有的资源的释放函数" class="headerlink" title="自定义 智能指针对象持有的资源的释放函数"></a>自定义 智能指针对象持有的资源的释放函数</h5><p>默认情况下，智能指针对象在析构时只会释放其持有的堆内存，调用delete或delete[]，但是有些时候，不止要回收指针对象，还需要回收与该指针相关的其他内存，这时，就需要自定义智能指针的资源释放函数了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Student() &#123;</span><br><span class="line">name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(name, <span class="string">"abc"</span>);</span><br><span class="line">&#125;</span><br><span class="line">~Student() &#123;&#125;</span><br><span class="line">    <span class="comment">//这里应该把delete放入析构中，这里只是为了说明智能指针的相关用法才这么写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">delete</span>[] name;</span><br><span class="line">name = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span>* name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> releaseFunc = [](Student* ps)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ps-&gt;getName() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        ps-&gt;release();</span><br><span class="line">        <span class="keyword">delete</span> ps;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Student, <span class="keyword">void</span>(*)(Student* ps)&gt; pStudent(<span class="keyword">new</span> Student(), releaseFunc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义std::unique_ptr的资源释放函数规则是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T,DeletorFuncPtr&gt;</span><br></pre></td></tr></table></figure><p>其中T是要释放的对象类型，DeletorFuncPtr是自定义函数指针，这里可以使用decltype(releaseFunc)让编译器自行推导releaseFunc的类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Student, <span class="keyword">void</span>(*)(Student* ps)&gt; pStudent(<span class="keyword">new</span> Student(), releaseFunc);</span><br><span class="line">可改为</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Student, <span class="keyword">decltype</span>(releaseFunc))&gt; pStudent(<span class="keyword">new</span> Student(), releaseFunc);</span><br></pre></td></tr></table></figure><h4 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h4><p>std::unique_ptr对持有的资源具有独占性，而std::shared_ptr对持有的资源具有共享性，即多个shared_ptr可以同时持有同一个资源对象，每增加一个shared_ptr指向该对象，该对象的引用计数就+1，每析构一个，引用计数-1，当引用计数为0时，该对象被释放回收，多个线程之间，递增或者递减引用计数是安全的，但并不意味着，多个线程之间同时操作引用对象时安全的。std::shared_ptr提供一个use_count()方法来获取当前持有资源的引用计数。除此之外，其余的用法与std::unique_ptr基本相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//初始化2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2;</span><br><span class="line">sp2.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//初始化3</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp3 = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>优先使用std::make_shared去初始化std::shared_ptr对象。</p><h5 id="std-enable-shared-from-this"><a href="#std-enable-shared-from-this" class="headerlink" title="std::enable_shared_from_this"></a>std::enable_shared_from_this</h5><p>在开发中，有时候需要在类中返回包裹当前对象（this）的std::shared_ptr对象给外部使用，有此需求的类只要继承自己的std::enable_shared_from_this<t>模板对象即可。</t></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;A&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A()&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~A() &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A destructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; getSelf() &#123;</span><br><span class="line"><span class="keyword">return</span> shared_from_this();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; sp4(<span class="keyword">new</span> A());</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; sp5 = sp4-&gt;getSelf();</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"use_count:"</span> &lt;&lt; sp4.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getSelf方法返回自身的std::shared_ptr对象，方法中直接返回shared_from_this()。</p><h5 id="陷阱一：不应该共享栈对象的this给智能指针对象"><a href="#陷阱一：不应该共享栈对象的this给智能指针对象" class="headerlink" title="陷阱一：不应该共享栈对象的this给智能指针对象"></a>陷阱一：不应该共享栈对象的this给智能指针对象</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与上文代码相同</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; sp5 = a.getSelf();</span><br><span class="line">    <span class="comment">//程序在该行崩溃</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"use_count:"</span> &lt;&lt; sp4.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>崩溃原因：智能指针是为了管理堆对象的，而a是栈对象，栈对象会在函数调用结束时自行销毁，不能通过shared_from_this交给智能指针管理。</p><p>智能指针最初的设计目的就是为了管理不会自动回收的堆内存的。</p><h5 id="陷阱二：避免std-enable-shared-from-this的循环引用问题"><a href="#陷阱二：避免std-enable-shared-from-this的循环引用问题" class="headerlink" title="陷阱二：避免std::enable_shared_from_this的循环引用问题"></a>陷阱二：避免std::enable_shared_from_this的循环引用问题</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;B&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B() &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~B() &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B destructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">m_mySelf = shared_from_this();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;B&gt; m_mySelf;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;B&gt; sp6(<span class="keyword">new</span> B());</span><br><span class="line">sp6-&gt;func();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">B constructor</span><br></pre></td></tr></table></figure><p>根据输出可以发现对象B没有被回收，发生了内存泄漏，那么这是为什么呢？</p><p>sp6创建的时候 对象引用计数为1，之后调用func函数把自身的shared_ptr赋值给了类变量m_mySelf,此时引用计数为2，之后sp6对象被销毁，此时B的引用计数为1，不会被销毁，这时就出现了矛盾，B想要销毁就要引用计数减为0，就需要销毁m_mySelf，那么就必须要销毁B对象，这样B对象就无法销毁了。因此我们实际开发中应该避免出现这样的逻辑。</p><h5 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h5><p>std::weak_ptr是一个不控制资源生命周期的智能指针，是对对象的一种弱引用，只是提供了对其管理对象的一个访问手段，引入的目的是为了辅助shared_ptr工作。</p><p>std::weak_ptr可以从一个std::shared_ptr或另一个std::weak_ptr对象构造，std::shared_ptr可以直接复制给std::weak_ptr，weak_ptr可以通过lock()方法获取shared_ptr，它的构造和析构不会引起引用计数的变化，weak_ptr可用于解决shared_ptr引用计数循环的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp1 = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"use_count:"</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; wp2(sp1);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"use_count:"</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; wp3 = sp1;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"use_count:"</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; wp4(wp3);</span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; wp5 = wp3;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"use_count:"</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过lock()方法获得shared_ptr会增加引用计数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp6 = wp5.lock();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"use_count:"</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">use count: <span class="number">1</span></span><br><span class="line">use count: <span class="number">1</span></span><br><span class="line">use count: <span class="number">1</span></span><br><span class="line">use count: <span class="number">1</span></span><br><span class="line">use count: <span class="number">2</span></span><br></pre></td></tr></table></figure><p>weak_ptr不管对象的生命周期，当对象被销毁时，通过expired()方法来检测，返回true，表示对象已经不存在了；false表示对象还存在，此时可以通过lock()方法获取shared_ptr继续操作对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tmpPoint  ----&gt;std::weak_ptr&lt;Point&gt;</span></span><br><span class="line"><span class="keyword">if</span>(tmpPoint.expired())&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Point&gt; p = tmpPoint.lock();</span><br><span class="line"><span class="keyword">if</span>(p)&#123;</span><br><span class="line">    <span class="comment">//数据处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>weak_ptr没有重写operator-&gt;和operator*方法，所以不能直接操作对象，也没有重写operator!操作，所以也不能判断引用的资源是否存在。</p><p>weak_ptr不增加引用资源的引用计数来管理资源的生命周期，是因为，即使它实现了以上几个方法，调用他们是不安全的，因为在调用期间，引用的资源可能已经被销毁了。</p><p>weak_ptr的正确使用场景是那些资源如果可用就使用，不可用就不用的场景，它不参与资源的生命周期管理。</p><p>例如：在网络分层中，Session对象：利用Connection对象提供的服务工作，但是Session对象不管理Connection对象的生命周期，因为网络底层会有各种原因导致Connection对象销毁，如果Session强行持有Connection对象,会与事实矛盾。</p><p>经典示例：（订阅者模式 或者 观察者模式）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subscriber</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubscribeManager</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">publish</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; iter : m_subscirbers)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!iter.expired())&#123;</span><br><span class="line">                <span class="comment">//<span class="doctag">TODO:</span>Send Message to Subscriber</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::weak_ptr&lt;Subscriber&gt;&gt; m_subscirbers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="智能指针对象的大小"><a href="#智能指针对象的大小" class="headerlink" title="智能指针对象的大小"></a>智能指针对象的大小</h4><p>一个<strong>std::unique_ptr</strong>对象大小与一个裸指针大小相同，而<strong>std::shared_ptr</strong>对象的大小是<strong>std::unique_ptr</strong>大小的一倍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp0;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; sp1;</span><br><span class="line">sp1.reset(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>());</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2;</span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; sp3;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sp0 size: "</span> &lt;&lt; <span class="keyword">sizeof</span>(sp0) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sp1 size: "</span> &lt;&lt; <span class="keyword">sizeof</span>(sp1) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sp2 size: "</span> &lt;&lt; <span class="keyword">sizeof</span>(sp2) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sp3 size: "</span> &lt;&lt; <span class="keyword">sizeof</span>(sp3) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">sp0 size: <span class="number">8</span></span><br><span class="line">sp1 size: <span class="number">8</span></span><br><span class="line">sp2 size: <span class="number">4</span></span><br><span class="line">sp3 size: <span class="number">8</span></span><br></pre></td></tr></table></figure><h4 id="智能指针使用注意事项"><a href="#智能指针使用注意事项" class="headerlink" title="智能指针使用注意事项"></a>智能指针使用注意事项</h4><blockquote><ul><li>一旦一个对象使用智能指针管理后，就不该再使用原始裸指针去操作。</li><li>分清楚场合应该使用哪种类型的智能指针。</li><li>认真考虑，避免操作某个引用资源已经释放的智能指针。</li><li>作为类成员变量时，应该优先使用前置声明（forward declarations）。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;std-auto-ptr&quot;&gt;&lt;a href=&quot;#std-auto-ptr&quot; class=&quot;headerlink&quot; title=&quot;std::auto_ptr&quot;&gt;&lt;/a&gt;std::auto_ptr&lt;/h4&gt;&lt;p&gt;基本用法&lt;/p&gt;
&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="unique_ptr" scheme="http://TokeyRoad.github.io/tags/unique-ptr/"/>
    
      <category term="shared_ptr" scheme="http://TokeyRoad.github.io/tags/shared-ptr/"/>
    
  </entry>
  
  <entry>
    <title>原子操作类-atomic</title>
    <link href="http://TokeyRoad.github.io/2020/05/22/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB-atomic/"/>
    <id>http://TokeyRoad.github.io/2020/05/22/原子操作类-atomic/</id>
    <published>2020-05-22T03:29:15.000Z</published>
    <updated>2020-05-23T02:59:50.146Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 11 新标准中提供了对整形变量原子操作的相关库，即std::atomic,这是个模板类型：（同时支持跨平台）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">atomic</span>;</span></span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; ato_int;</span><br><span class="line">ato_int = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::atomic&lt;int&gt; ato_int = 1;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d \n"</span>, (<span class="keyword">int</span>)ato_int);</span><br><span class="line"></span><br><span class="line">++ato_int;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d \n"</span>, (<span class="keyword">int</span>)ato_int);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码在win和linux中都可以运行，但是如果这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//std::atomic&lt;int&gt; ato_int;</span></span><br><span class="line"><span class="comment">//ato_int = 1;</span></span><br><span class="line">   <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; ato_int = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>就只能在win下运行，linux编译无法通过。</p><p>错误原因是std::atomic的拷贝构造函数是默认=delete 禁止编译器生成的 g++遵循了，但是win上的vc++没有遵循。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atomic&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> atomic&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">方法说明</th></tr></thead><tbody><tr><td style="text-align:center">operator=</td><td style="text-align:center">存储值到对象</td></tr><tr><td style="text-align:center">store</td><td style="text-align:center">原子的以非原子对象替换原子对象的值</td></tr><tr><td style="text-align:center">load</td><td style="text-align:center">原子的获取原子对象的值</td></tr><tr><td style="text-align:center">exchange</td><td style="text-align:center">原子的替换原子对象的值并获得它先前替换的值</td></tr><tr><td style="text-align:center">compare_exchange_weak<br>compare_exchange_strong</td><td style="text-align:center">原子的比较原子对象非原子参数的值。若相等则交换，不相等则加载</td></tr><tr><td style="text-align:center">fetch_add</td><td style="text-align:center">原子的将参数加到原子对象的值，并返回先前的值</td></tr><tr><td style="text-align:center">fetch_sub</td><td style="text-align:center">原子的将原子对象的值减去参数，并返回先前的值</td></tr><tr><td style="text-align:center">fetch_and</td><td style="text-align:center">原子的进行参数和原子对象逐位与，并获得先前保存的值</td></tr><tr><td style="text-align:center">fetch_or</td><td style="text-align:center">原子的进行参数和原子对象逐位或，并获得先前保存的值</td></tr><tr><td style="text-align:center">fetch_xor</td><td style="text-align:center">原子的进行参数和原子对象逐位异或，并获得先前保存的值</td></tr><tr><td style="text-align:center">operator++ operator++(int) operator- operator-(int</td><td style="text-align:center">原子值增加或者减一</td></tr><tr><td style="text-align:center">operator+= operator-= operator&amp;= operator\</td><td style="text-align:center">= operator^=</td><td>=加减，=与原子值进行逐位与或异或</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C++ 11 新标准中提供了对整形变量原子操作的相关库，即std::atomic,这是个模板类型：（同时支持跨平台）&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="atomic" scheme="http://TokeyRoad.github.io/tags/atomic/"/>
    
  </entry>
  
  <entry>
    <title>线程资源同步对象-condition_variable</title>
    <link href="http://TokeyRoad.github.io/2020/05/20/%E7%BA%BF%E7%A8%8B%E8%B5%84%E6%BA%90%E5%90%8C%E6%AD%A5%E5%AF%B9%E8%B1%A1-condition-variable/"/>
    <id>http://TokeyRoad.github.io/2020/05/20/线程资源同步对象-condition-variable/</id>
    <published>2020-05-20T06:41:58.000Z</published>
    <updated>2020-05-21T08:23:41.093Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 11提供了std::condition_variable这个类 代表条件变量，与Linux系统原生的条件变量一样，同时还提供了等待条件变量的一系列wait方法(wait/wait_for/wait_until)，发送信号使用notify方法(notify_one/notify_all)，使用std::condition_variable时需要绑定到std::unique_lock或std::lock_guard对象。</p><blockquote><p>C++ 11中 std::condition_variable 不再需要显示调用方法初始化和销毁</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Task(<span class="keyword">int</span> id) &#123;</span><br><span class="line">m_taskID = id;</span><br><span class="line">&#125;</span><br><span class="line">~Task() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"do task,taskID:"</span> &lt;&lt; m_taskID &lt;&lt; <span class="string">", threadID:"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_taskID;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mutex;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;Task*&gt; tasks;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">produce_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Task* pTask = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> taskID = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">pTask = <span class="keyword">new</span> Task(taskID);</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lg(mutex);</span><br><span class="line">tasks.push_back(pTask);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"produce a task,taskID:"</span> &lt;&lt; taskID &lt;&lt; <span class="string">",threadID:"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">cv.notify_all();</span><br><span class="line">taskID++;</span><br><span class="line"><span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consume_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Task* pTask = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> taskID = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; guard(mutex);</span><br><span class="line"><span class="keyword">while</span> (tasks.empty()) &#123;</span><br><span class="line">cv.wait(guard);</span><br><span class="line">&#125;</span><br><span class="line">pTask = tasks.front();</span><br><span class="line">tasks.pop_front();</span><br><span class="line"><span class="keyword">if</span> (pTask == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">pTask-&gt;DoTask();</span><br><span class="line"><span class="keyword">delete</span> pTask;</span><br><span class="line">pTask = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::thread consume1 = <span class="built_in">std</span>::thread(consume_thread);</span><br><span class="line"><span class="built_in">std</span>::thread consume2 = <span class="built_in">std</span>::thread(consume_thread);</span><br><span class="line"><span class="built_in">std</span>::thread consume3 = <span class="built_in">std</span>::thread(consume_thread);</span><br><span class="line"><span class="built_in">std</span>::thread consume4 = <span class="built_in">std</span>::thread(consume_thread);</span><br><span class="line"><span class="built_in">std</span>::thread consume5 = <span class="built_in">std</span>::thread(consume_thread);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::thread produce1 = <span class="built_in">std</span>::thread(produce_thread);</span><br><span class="line"><span class="comment">//std::thread produce2 = std::thread(produce_thread);</span></span><br><span class="line"><span class="comment">//std::thread produce3 = std::thread(produce_thread);</span></span><br><span class="line"></span><br><span class="line">consume1.join();</span><br><span class="line">consume2.join();</span><br><span class="line">consume3.join();</span><br><span class="line">consume4.join();</span><br><span class="line">consume5.join();</span><br><span class="line">produce1.join();</span><br><span class="line"><span class="comment">//produce2.join();</span></span><br><span class="line"><span class="comment">//produce3.join();</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line">produce a task,taskID:<span class="number">0</span>,threadID:<span class="number">19444</span></span><br><span class="line"><span class="keyword">do</span> task,taskID:<span class="number">0</span>, threadID:<span class="number">6344</span></span><br><span class="line">produce a task,taskID:<span class="number">1</span>,threadID:<span class="number">19444</span></span><br><span class="line"><span class="keyword">do</span> task,taskID:<span class="number">1</span>, threadID:<span class="number">6352</span></span><br><span class="line">produce a task,taskID:<span class="number">2</span>,threadID:<span class="number">19444</span></span><br><span class="line"><span class="keyword">do</span> task,taskID:<span class="number">2</span>, threadID:<span class="number">4836</span></span><br><span class="line">produce a task,taskID:<span class="number">3</span>,threadID:<span class="number">19444</span></span><br><span class="line"><span class="keyword">do</span> task,taskID:<span class="number">3</span>, threadID:<span class="number">6352</span></span><br><span class="line">produce a task,taskID:<span class="number">4</span>,threadID:<span class="number">19444</span></span><br><span class="line"><span class="keyword">do</span> task,taskID:<span class="number">4</span>, threadID:<span class="number">6344</span></span><br><span class="line">produce a task,taskID:<span class="number">5</span>,threadID:<span class="number">19444</span></span><br><span class="line"><span class="keyword">do</span> task,taskID:<span class="number">5</span>, threadID:<span class="number">4836</span></span><br><span class="line">produce a task,taskID:<span class="number">6</span>,threadID:<span class="number">19444</span></span><br><span class="line"><span class="keyword">do</span> task,taskID:<span class="number">6</span>, threadID:<span class="number">13436</span></span><br><span class="line">produce a task,taskID:<span class="number">7</span>,threadID:<span class="number">19444</span></span><br><span class="line"><span class="keyword">do</span> task,taskID:<span class="number">7</span>, threadID:<span class="number">4836</span></span><br><span class="line">    .........</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C++ 11提供了std::condition_variable这个类 代表条件变量，与Linux系统原生的条件变量一样，同时还提供了等待条件变量的一系列wait方法(wait/wait_for/wait_until)，发送信号使用notify方法(notify_one/n
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="condition_variable" scheme="http://TokeyRoad.github.io/tags/condition-variable/"/>
    
  </entry>
  
  <entry>
    <title>线程资源同步对象-mutex</title>
    <link href="http://TokeyRoad.github.io/2020/05/20/%E7%BA%BF%E7%A8%8B%E8%B5%84%E6%BA%90%E5%90%8C%E6%AD%A5%E5%AF%B9%E8%B1%A1-mutex/"/>
    <id>http://TokeyRoad.github.io/2020/05/20/线程资源同步对象-mutex/</id>
    <published>2020-05-20T01:34:48.000Z</published>
    <updated>2020-05-20T06:43:30.233Z</updated>
    
    <content type="html"><![CDATA[<p>在C++ 11新标准中新增了线程资源同步对象：std::mutex 和 std::condition_variable 。</p><h5 id="std-mutex-系列"><a href="#std-mutex-系列" class="headerlink" title="std::mutex 系列"></a>std::mutex 系列</h5><p>C++ 11/14/17中提供了如下mutex系列类型：</p><table><thead><tr><th style="text-align:center">互斥量</th><th style="text-align:center">版本</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">mutex</td><td style="text-align:center">C++ 11</td><td style="text-align:center">最基本的互斥量</td></tr><tr><td style="text-align:center">timed_mutex</td><td style="text-align:center">C++ 11</td><td style="text-align:center">有超时机制的互斥量</td></tr><tr><td style="text-align:center">recursive_mutex</td><td style="text-align:center">C++ 11</td><td style="text-align:center">可重入的互斥量</td></tr><tr><td style="text-align:center">recursive_timed_mutex</td><td style="text-align:center">C++ 11</td><td style="text-align:center">结合timed_mutex和recursive_mutex特点的互斥量</td></tr><tr><td style="text-align:center">shared_timed_mutex</td><td style="text-align:center">C++ 14</td><td style="text-align:center">具有超时机制的可共享互斥量</td></tr><tr><td style="text-align:center">shared_mutex</td><td style="text-align:center">C++ 17</td><td style="text-align:center">共享的互斥量</td></tr></tbody></table><p>这个系列的对象均提供了加锁(lock)、尝试加锁(trylock) 和 解锁(unlock) 的方法。</p><p>为了避免死锁， std::mutex.lock() 和 std::mutex.unlock() 需要成对使用，同时C++11提供了一些互斥量管理的封装方法，避免忘记unlock而造成死锁。</p><table><thead><tr><th style="text-align:center">互斥量管理</th><th style="text-align:center">版本</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">lock_guard</td><td style="text-align:center">C++ 11</td><td style="text-align:center">基于作用域的互斥量管理</td></tr><tr><td style="text-align:center">unique_lock</td><td style="text-align:center">C++ 11</td><td style="text-align:center">更加灵活的互斥量管理</td></tr><tr><td style="text-align:center">shared_lock</td><td style="text-align:center">C++ 14</td><td style="text-align:center">共享互斥量的管理</td></tr><tr><td style="text-align:center">scope_lock</td><td style="text-align:center">C++ 17</td><td style="text-align:center">多互斥量避免死锁的管理</td></tr></tbody></table><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lg(mymutex);</span><br><span class="line"><span class="comment">//保护的资源操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：mymutex的声明周期必须比函数func的作用域长。</p><p>错误示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误写法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lg(mymutex);</span><br><span class="line"><span class="comment">//保护的资源操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写是错误的，当跳出func作用域时，m已经失效，这时lg析构解锁的时候，会出现未定义的行为。</p><p>此外，如果一个std::mutex对象已经调用lock()方法，再次调用时,会出现未定义的行为(Windows)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line">m.lock();</span><br><span class="line">m.lock();<span class="comment">//程序在这里崩溃</span></span><br><span class="line"><span class="comment">//bool re = m.try_lock();</span></span><br><span class="line"><span class="comment">//std::cout &lt;&lt; re &lt;&lt; std::endl;//output 0</span></span><br><span class="line">m.unlock();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，对于一个已经调用lock()方法再次调用lock()方法的做法是错误的。</p><h5 id="std-shared-mutex"><a href="#std-shared-mutex" class="headerlink" title="std::shared_mutex"></a>std::shared_mutex</h5><p>std::shared_mutex底层实现主要原理是操作系统提供的读写锁，在存在多个线程对公共资源读，少部分线程对公共资源写的情况下，std::shared_mutex 比 std::mutex效率更高。</p><p>std::shared_mutex提供了lock_shared()和unlock_shared()方法 获取读锁和写锁，写锁通常被称为 排他锁(Exclusive Locking)，读锁常被称为 共享锁(Shared Locking)。</p><p>同时C++ 新标准中引入了 std::unique_lock 和 std::shared_lock 用于进入作用域自动加锁，离开作用域自动解锁，前者用于写锁，后者用于读锁。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_mutex_counter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">shared_mutex_counter() = <span class="keyword">default</span>;</span><br><span class="line">~shared_mutex_counter() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::shared_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; sl(_shared_mutex);</span><br><span class="line"><span class="keyword">return</span> _value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increse</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; sl(_shared_mutex);</span><br><span class="line">++_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; sl(_shared_mutex);</span><br><span class="line">_value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::shared_mutex _shared_mutex;</span><br><span class="line"><span class="comment">//共享数据</span></span><br><span class="line"><span class="keyword">int</span> _value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOOP_COUNT 5000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_COUNT 8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_shared_mutex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">shared_mutex_counter shared_counter;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> readr = [&amp;shared_counter, &amp;result]() &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LOOP_COUNT; ++i) &#123;</span><br><span class="line">result = shared_counter.get();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> start = clock();</span><br><span class="line"><span class="keyword">auto</span> writer = [&amp;shared_counter]() &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LOOP_COUNT; ++i) &#123;</span><br><span class="line">shared_counter.increse();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::thread** tarray = <span class="keyword">new</span> <span class="built_in">std</span>::thread*[THREAD_COUNT];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; ++i) &#123;</span><br><span class="line">tarray[i] = <span class="keyword">new</span> <span class="built_in">std</span>::thread(readr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::thread* tw = <span class="keyword">new</span> <span class="built_in">std</span>::thread(writer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; ++i) &#123;</span><br><span class="line">tarray[i]-&gt;join();</span><br><span class="line">&#125;</span><br><span class="line">tw-&gt;join();</span><br><span class="line"><span class="keyword">clock_t</span> end = clock();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[test_shared_mutex] thread_count:%d\n"</span>, THREAD_COUNT);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"count_value:%d, cost:%dms, result:%d"</span>, shared_counter.get(), end - start, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">test_shared_mutex();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">[test_shared_mutex] thread_count:<span class="number">8</span></span><br><span class="line">count_value:<span class="number">5000000</span>, cost:<span class="number">5030</span>ms, result:<span class="number">2522449</span></span><br></pre></td></tr></table></figure><p>另外一个mutex的测试案例不再列出，跟shared_mutex类似。但是两者效率差距较大。</p><p>如果条件允许，可以根据使用场景，用shared_mutex替换mutex，可以提高很大的效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在C++ 11新标准中新增了线程资源同步对象：std::mutex 和 std::condition_variable 。&lt;/p&gt;
&lt;h5 id=&quot;std-mutex-系列&quot;&gt;&lt;a href=&quot;#std-mutex-系列&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="mutex" scheme="http://TokeyRoad.github.io/tags/mutex/"/>
    
  </entry>
  
  <entry>
    <title>stl容器新增的实用方法</title>
    <link href="http://TokeyRoad.github.io/2020/05/19/stl%E5%AE%B9%E5%99%A8%E6%96%B0%E5%A2%9E%E7%9A%84%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://TokeyRoad.github.io/2020/05/19/stl容器新增的实用方法/</id>
    <published>2020-05-19T03:44:34.000Z</published>
    <updated>2020-05-19T09:33:43.909Z</updated>
    
    <content type="html"><![CDATA[<h4 id="emplace系列函数"><a href="#emplace系列函数" class="headerlink" title="emplace系列函数"></a>emplace系列函数</h4><p>先上一段常用的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Test(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">m_a = a;</span><br><span class="line">m_b = b;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Test constructed"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Test() &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_a &lt;&lt; <span class="string">" Test destructed"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test(<span class="keyword">const</span> Test&amp; t) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;t) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = t.m_a;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_b = t.m_b;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_a &lt;&lt; <span class="string">" Test copy-constructed"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_a;</span><br><span class="line"><span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Test&gt; vec;</span><br><span class="line">vec.reserve(<span class="number">20</span>);<span class="comment">//，提前分好内存 避免vector的内存重分配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line"><span class="function">Test <span class="title">t</span><span class="params">(i, i + <span class="number">1</span>)</span></span>;</span><br><span class="line">vec.push_back(t);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">Test constructed</span><br><span class="line"><span class="number">0</span> Test copy-constructed</span><br><span class="line"><span class="number">0</span> Test destructed</span><br><span class="line">Test constructed</span><br><span class="line"><span class="number">1</span> Test copy-constructed</span><br><span class="line"><span class="number">1</span> Test destructed</span><br><span class="line">Test constructed</span><br><span class="line"><span class="number">2</span> Test copy-constructed</span><br><span class="line"><span class="number">2</span> Test destructed</span><br></pre></td></tr></table></figure><p>在这个过程中，我们的目的是为了产生一个对象数组，为了产生3个对象,调用了3*3次，这个过程执行过程：创建对象t调用构造函数—&gt;调用对象t的拷贝构造函数放入集合—&gt;调用析构函数。</p><p>C++11 提供了一个新的方法代替emplace_back</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Test&gt; vec;</span><br><span class="line">vec.reserve(<span class="number">20</span>);<span class="comment">//，提前分好内存 避免vector的内存重分配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">vec.emplace_back(i, i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">Test constructed</span><br><span class="line">Test constructed</span><br><span class="line">Test constructed</span><br></pre></td></tr></table></figure><p>emplace操作被称为 “原位构造元素”</p><p>同理的方法 如下:</p><table><thead><tr><th style="text-align:center">原方法</th><th style="text-align:center">C++11 改进方法</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">push/insert</td><td style="text-align:center">emplace</td><td style="text-align:center">指定位置原位构造元素</td></tr><tr><td style="text-align:center">push_front</td><td style="text-align:center">emplace_front</td><td style="text-align:center">首部原位构造元素</td></tr><tr><td style="text-align:center">push_back</td><td style="text-align:center">emplace_back</td><td style="text-align:center">尾部原位构造元素</td></tr></tbody></table><h4 id="std-map的try-emplace-与-insert-or-assign方法"><a href="#std-map的try-emplace-与-insert-or-assign方法" class="headerlink" title="std::map的try_emplace 与 insert_or_assign方法"></a>std::map的try_emplace 与 insert_or_assign方法</h4><p>由于map中的key是唯一的，因此在开发中经常遇到往map中插入数据之前需要先验证key是否存在，C++17中map提供了一个try_emplace方法，该方法会检测指定的key是否存在，函数签名如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;iterator, bool&gt; <span class="title">try_emplace</span>(<span class="title">const</span> <span class="title">key_type</span>&amp; <span class="title">k</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;iterator, bool&gt; <span class="title">try_emplace</span>(<span class="title">key_type</span>&amp;&amp; <span class="title">k</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">iterator</span> <span class="title">try_emplace</span>(<span class="title">const_iterator</span> <span class="title">hint</span>, <span class="title">const</span> <span class="title">key_type</span>&amp; <span class="title">k</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">iterator</span> <span class="title">try_emplace</span>(<span class="title">const_iterator</span> <span class="title">hint</span>, <span class="title">key_type</span>&amp;&amp; <span class="title">k</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure><p>其中k表示需要插入的key，args不定参数表示构造value对象所需的参数列表，hint表示插入位置。</p><p>前两种形式中，返回值是std::pair&lt;T1,T2&gt;，其中T2是个bool表示，当前插入操作成功与否，T1是一个迭代器，如果插入成功，则指向插入位置的元素迭代器，如果失败，则指向相同key元素的迭代器。 </p><p>后两种不常用，在map中插入时很少关心插入位置。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; m;</span><br><span class="line">m.emplace(<span class="string">"aaa"</span>, <span class="string">"ONE"</span>);</span><br><span class="line">m.emplace(<span class="string">"bbb"</span>, <span class="string">"TWO"</span>);</span><br><span class="line">m.emplace(<span class="string">"ccc"</span>, <span class="string">"THREE"</span>);</span><br><span class="line">m.emplace(<span class="string">"ddd"</span>, <span class="string">"FOUR"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> res = m.try_emplace(<span class="string">"eee"</span>, <span class="string">"FIVE"</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; res.first-&gt;second.c_str() &lt;&lt; <span class="string">" "</span> &lt;&lt; res.second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"map size:"</span> &lt;&lt; m.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : m) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter.first &lt;&lt; iter.second &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> resf = m.try_emplace(<span class="string">"aaa"</span>, <span class="string">"SIX"</span>);<span class="comment">//auto -&gt; std::pair&lt;std::map&lt;std::string, std::string&gt;::iterator, bool&gt;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; resf.first-&gt;second.c_str() &lt;&lt; <span class="string">" "</span> &lt;&lt; resf.second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : m) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter.first &lt;&lt; iter.second &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = m.try_emplace(m.begin(), <span class="string">"fff"</span>, <span class="string">"SEVEN"</span>);<span class="comment">////auto -&gt; std::map&lt;std::string, std::string&gt;::iterator</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : m) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter.first &lt;&lt; iter.second &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">FIVE <span class="number">1</span></span><br><span class="line"><span class="built_in">map</span> size:<span class="number">5</span></span><br><span class="line">aaaONE bbbTWO cccTHREE dddFOUR eeeFIVE</span><br><span class="line">ONE <span class="number">0</span></span><br><span class="line">aaaONE bbbTWO cccTHREE dddFOUR eeeFIVE</span><br><span class="line">fffSEVEN</span><br><span class="line">aaaONE bbbTWO cccTHREE dddFOUR eeeFIVE fffSEVEN</span><br></pre></td></tr></table></figure><p>try_emplace是map中指定的key存在就失败，不存在就插入，还有另一个方法insert_or_assign 当key存在时就更新value，不存在时就插入。</p><p>insert_or_assign函数签名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">M</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;iterator, bool&gt; <span class="title">insert_or_assign</span>(<span class="title">const</span> <span class="title">key_type</span>&amp; <span class="title">k</span>, <span class="title">M</span>&amp;&amp; <span class="title">obj</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">M</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;iterator, bool&gt; <span class="title">insert_or_assign</span>(<span class="title">key_type</span>&amp;&amp; <span class="title">k</span>, <span class="title">M</span>&amp;&amp; <span class="title">obj</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">M</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">iterator</span> <span class="title">insert_or_assign</span>(<span class="title">const_iterator</span> <span class="title">hint</span>, <span class="title">const</span> <span class="title">key_type</span>&amp; <span class="title">k</span>, <span class="title">M</span>&amp;&amp; <span class="title">obj</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">M</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">iterator</span> <span class="title">insert_or_assign</span>(<span class="title">const_iterator</span> <span class="title">hint</span>, <span class="title">key_type</span>&amp;&amp; <span class="title">k</span>, <span class="title">M</span>&amp;&amp; <span class="title">obj</span>);</span></span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; m;</span><br><span class="line">m.emplace(<span class="string">"aaa"</span>, <span class="string">"ONE"</span>);</span><br><span class="line">m.emplace(<span class="string">"bbb"</span>, <span class="string">"TWO"</span>);</span><br><span class="line">m.emplace(<span class="string">"ccc"</span>, <span class="string">"THREE"</span>);</span><br><span class="line">m.emplace(<span class="string">"ddd"</span>, <span class="string">"FOUR"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : m) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter.first &lt;&lt; iter.second &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">m.insert_or_assign(<span class="string">"aaa"</span>, <span class="string">"EIGHT"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : m) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter.first &lt;&lt; iter.second &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">aaaONE bbbTWO cccTHREE dddFOUR</span><br><span class="line">aaaEIGHT bbbTWO cccTHREE dddFOUR</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;emplace系列函数&quot;&gt;&lt;a href=&quot;#emplace系列函数&quot; class=&quot;headerlink&quot; title=&quot;emplace系列函数&quot;&gt;&lt;/a&gt;emplace系列函数&lt;/h4&gt;&lt;p&gt;先上一段常用的代码：&lt;/p&gt;
&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="stl" scheme="http://TokeyRoad.github.io/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>foreach循环</title>
    <link href="http://TokeyRoad.github.io/2020/05/18/foreach%E5%BE%AA%E7%8E%AF/"/>
    <id>http://TokeyRoad.github.io/2020/05/18/foreach循环/</id>
    <published>2020-05-18T06:36:54.000Z</published>
    <updated>2020-05-18T07:21:15.419Z</updated>
    
    <content type="html"><![CDATA[<h4 id="for-each"><a href="#for-each" class="headerlink" title="for-each"></a>for-each</h4><p>C++ 11之后才开始支持for-each语法。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; v_str;</span><br><span class="line">v_str.push_back(<span class="string">"aaa"</span>);</span><br><span class="line">v_str.push_back(<span class="string">"bbb"</span>);</span><br><span class="line">v_str.push_back(<span class="string">"ccc"</span>);</span><br><span class="line">v_str.push_back(<span class="string">"ddd"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : v_str) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter.c_str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><blockquote><ol><li>for-each中的迭代器类型与数组或集合中的元素类型完全一致，而stl容器中的迭代器是类型的取地址类型即指针，因此对于上面的例子中，iter是string类型；如果用stl迭代器，那就是指向string的指针。</li><li>for-each对于复杂数据类型，迭代器是原始数据的拷贝，而不是引用，在这个过程中会额外调用构造函数的开销，必要的时候可以使用<code>auto&amp; iter</code> 而不是 <code>auto iter</code> 这样就是原始数据的引用了。</li></ol></blockquote><p>示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; v_str;</span><br><span class="line">v_str.push_back(<span class="string">"aaa"</span>);</span><br><span class="line">v_str.push_back(<span class="string">"bbb"</span>);</span><br><span class="line">v_str.push_back(<span class="string">"ccc"</span>);</span><br><span class="line">v_str.push_back(<span class="string">"ddd"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : v_str) &#123;</span><br><span class="line">iter = <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : v_str) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter.c_str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br><span class="line">ddd</span><br></pre></td></tr></table></figure><p>修改后</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; v_str;</span><br><span class="line">v_str.push_back(<span class="string">"aaa"</span>);</span><br><span class="line">v_str.push_back(<span class="string">"bbb"</span>);</span><br><span class="line">v_str.push_back(<span class="string">"ccc"</span>);</span><br><span class="line">v_str.push_back(<span class="string">"ddd"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; iter : v_str) &#123;</span><br><span class="line">iter = <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : v_str) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter.c_str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><h4 id="自定义对象使用for-each（Range-based）"><a href="#自定义对象使用for-each（Range-based）" class="headerlink" title="自定义对象使用for-each（Range-based）"></a>自定义对象使用for-each（Range-based）</h4><p>for-each的lterator类型必须支持如下三种操作:</p><blockquote><p>operator++操作，即自增，可以自增返回下一个迭代子的位置</p><p>operator!=操作，即判不等</p><p>operator* 操作，即解引用</p></blockquote><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A() &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">m_elements[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~A() &#123;&#125;</span><br><span class="line"><span class="function">T* <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_elements + <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">T* <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_elements + N;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T m_elements[N];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里迭代子的类型是T* 本身就支持operator++ 和 operator!=操作，这里就不再实现</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A&lt;<span class="keyword">int</span>, <span class="number">10</span>&gt; arr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : arr) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;for-each&quot;&gt;&lt;a href=&quot;#for-each&quot; class=&quot;headerlink&quot; title=&quot;for-each&quot;&gt;&lt;/a&gt;for-each&lt;/h4&gt;&lt;p&gt;C++ 11之后才开始支持for-each语法。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="foreach" scheme="http://TokeyRoad.github.io/tags/foreach/"/>
    
  </entry>
  
  <entry>
    <title>在一个类中重载另一个类的构造函数</title>
    <link href="http://TokeyRoad.github.io/2020/05/12/%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%AD%E9%87%8D%E8%BD%BD%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>http://TokeyRoad.github.io/2020/05/12/在一个类中重载另一个类的构造函数/</id>
    <published>2020-05-12T02:51:53.000Z</published>
    <updated>2020-05-12T03:08:18.126Z</updated>
    
    <content type="html"><![CDATA[<h5 id="构造函数是一个特殊的操作符"><a href="#构造函数是一个特殊的操作符" class="headerlink" title="构造函数是一个特殊的操作符"></a>构造函数是一个特殊的操作符</h5><p>假如我们有两个类point 和 Cpoint</p><p>现在我们需要用类point去构造Cpoint对象，一般实现方式是在Cpoint中定义如下构造：</p><blockquote><p>Cpoint(point);</p></blockquote><a id="more"></a><p>但有些情况下，这个构造是无法定义的：</p><blockquote><ol><li>用point的私有成员给Cpoint赋值（可以添加get方法解决），point没有定义Cpoint为友元类；</li><li>没有权限修改Cpoint，只能修改point；</li></ol></blockquote><p>这里我们可以在point重载Cpoint的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Cpoint &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">Cpoint(int a) &#123;</span></span><br><span class="line"><span class="comment">_p = a;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">private:</span></span><br><span class="line"><span class="comment">int _p;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">Cpoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Cpoint(_c_point);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> _c_point;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>重载后，在需要point构造Cpoint时都会隐式的调用point中的重载构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">point p1;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Cpoint&gt; vec;</span><br><span class="line">vec.push_back(p1);<span class="comment">//这个过程就是 由p1隐式构造Cpoint对象存入vec</span></span><br></pre></td></tr></table></figure><p>完整测试源代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cpoint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Cpoint() &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cpoint:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">_p = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Cpoint(<span class="keyword">int</span> a) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cpoint_a:"</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">_p = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> _p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">point() &#123;</span><br><span class="line">_c_point = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"point::point:"</span> &lt;&lt; _c_point &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">Cpoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">_c_point = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"point::Cpoint:"</span> &lt;&lt; _c_point &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> _c_point;<span class="comment">//等价于 Cpoint(_c_point)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> _c_point;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">point p;</span><br><span class="line"><span class="function">Cpoint <span class="title">cp</span><span class="params">(p)</span></span>;</span><br><span class="line"></span><br><span class="line">point p1;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Cpoint&gt; vec;</span><br><span class="line">vec.push_back(p1);</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output：</span></span><br><span class="line"><span class="comment">point::point:1</span></span><br><span class="line"><span class="comment">point::Cpoint:3</span></span><br><span class="line"><span class="comment">Cpoint_a:3</span></span><br><span class="line"><span class="comment">point::point:1</span></span><br><span class="line"><span class="comment">point::Cpoint:3</span></span><br><span class="line"><span class="comment">Cpoint_a:3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;构造函数是一个特殊的操作符&quot;&gt;&lt;a href=&quot;#构造函数是一个特殊的操作符&quot; class=&quot;headerlink&quot; title=&quot;构造函数是一个特殊的操作符&quot;&gt;&lt;/a&gt;构造函数是一个特殊的操作符&lt;/h5&gt;&lt;p&gt;假如我们有两个类point 和 Cpoint&lt;/p&gt;
&lt;p&gt;现在我们需要用类point去构造Cpoint对象，一般实现方式是在Cpoint中定义如下构造：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Cpoint(point);&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="construct" scheme="http://TokeyRoad.github.io/tags/construct/"/>
    
      <category term="operator" scheme="http://TokeyRoad.github.io/tags/operator/"/>
    
  </entry>
  
  <entry>
    <title>可变参数 省略号的使用</title>
    <link href="http://TokeyRoad.github.io/2020/05/11/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0-%E7%9C%81%E7%95%A5%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://TokeyRoad.github.io/2020/05/11/可变参数-省略号的使用/</id>
    <published>2020-05-11T02:00:20.000Z</published>
    <updated>2020-05-11T03:14:27.490Z</updated>
    
    <content type="html"><![CDATA[<h4 id="函数参数的传递原理"><a href="#函数参数的传递原理" class="headerlink" title="函数参数的传递原理"></a>函数参数的传递原理</h4><p>函数参数是以数据结构：栈的形式存取，从右至左入栈。</p><p>首先是参数的内存存放格式：参数存放在内存的堆栈段，在执行函数的时候，从最后一个开始入栈。因此栈底高地址，栈顶低地址。</p><p>理论上来说，只要获取到一个参数的地址，就可以通过地址偏移获取到其他参数的地址。</p><a id="more"></a><h4 id="stdarg-h"><a href="#stdarg-h" class="headerlink" title="stdarg.h"></a>stdarg.h</h4><p>下面是&lt;stdarg.h&gt;里重要的几个宏定义：</p><blockquote><p>typedef char* va_list;</p><p>void va_start(va_list ap, prev_param);</p><p>void va_arg(va_list ap, type);</p><p>void va_end(va_list ap);</p></blockquote><p>va_list 是一个字符指针，指向当前参数，取参需要用这个指针进行。</p><blockquote><ol><li>在调用参数表之前，定义一个va_list类型的变量ap;</li><li>对ap初始化，使用va_start初始化，第一个参数就是ap，第二个参数是省略号前的那个已知参数；</li><li>获取参数值，使用va_arg获取对应的参数值，第一个参数就是ap，第二个参数是你要获取值的类型，返回对应的值，获取之后该函数会把ap指向下一个参数的地址；</li><li>获取完毕之后，需要关闭指针，使用va_end关闭，参数就是ap，会把ap置空，一般va_end和va_start成对使用。</li></ol></blockquote><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">argMax</span><span class="params">(<span class="keyword">int</span> count, ...)</span> </span>&#123;</span><br><span class="line">va_list ap;</span><br><span class="line">va_start(ap, count);</span><br><span class="line"><span class="keyword">int</span> cur_max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> t = va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, t);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == i) &#123;</span><br><span class="line">cur_max = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cur_max = t &gt; cur_max ? t : cur_max;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cur_max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>, d = <span class="number">4</span>, e = <span class="number">-2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n %d \n"</span>, argMax(<span class="number">5</span>, a, b, c, d, e));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1 2 3 4 -2</span></span><br><span class="line"><span class="comment"> 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;函数参数的传递原理&quot;&gt;&lt;a href=&quot;#函数参数的传递原理&quot; class=&quot;headerlink&quot; title=&quot;函数参数的传递原理&quot;&gt;&lt;/a&gt;函数参数的传递原理&lt;/h4&gt;&lt;p&gt;函数参数是以数据结构：栈的形式存取，从右至左入栈。&lt;/p&gt;
&lt;p&gt;首先是参数的内存存放格式：参数存放在内存的堆栈段，在执行函数的时候，从最后一个开始入栈。因此栈底高地址，栈顶低地址。&lt;/p&gt;
&lt;p&gt;理论上来说，只要获取到一个参数的地址，就可以通过地址偏移获取到其他参数的地址。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="args" scheme="http://TokeyRoad.github.io/tags/args/"/>
    
  </entry>
  
  <entry>
    <title>char*赋值给std::string的陷阱</title>
    <link href="http://TokeyRoad.github.io/2020/04/29/char%E8%B5%8B%E5%80%BC%E7%BB%99string%E7%9A%84%E9%99%B7%E9%98%B1/"/>
    <id>http://TokeyRoad.github.io/2020/04/29/char赋值给string的陷阱/</id>
    <published>2020-04-29T02:47:31.000Z</published>
    <updated>2020-05-06T01:28:48.443Z</updated>
    
    <content type="html"><![CDATA[<h5 id="char-赋值给std-string的一些陷阱"><a href="#char-赋值给std-string的一些陷阱" class="headerlink" title="char*赋值给std::string的一些陷阱"></a>char*赋值给std::string的一些陷阱</h5><ol><li><p>将char <em> 赋值给std::string如果不指定长度，则会默认以\0截断（ASCII码值为0）；如果指定长度超过char</em> 的长度，用std::cout系列的函数输出时，会把不属于char*之后的内存值打印出来，而对于printf系列的函数打印时，遇到\0会被截断，因而不能完全显示。这点在打印日志时，这类字符串需要注意。</p></li><li><p>如果是单个字符和一个字符串赋值给std::string 写法是有区别的：对于char，数目是第一个参数，对于char*，数目是第二个参数。</p><blockquote><p>string(const char* s, size_t n);</p><p>string(size_t n, char c);</p></blockquote><p>假定pstr是一个字符串，那么要写成string(pstr,n)；如果pstr是一个字符，那么要写成string(n,pstr)，而此时string(pstr, n)是一个错误的写法，可能会导致你的程序产生莫名其妙的问题，因为如果pstr是一个负值，负值转换成无符号整数size_t类型，n将非常大，会导致构造字符串时length非常大导致std::string 构造时抛出异常。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;char-赋值给std-string的一些陷阱&quot;&gt;&lt;a href=&quot;#char-赋值给std-string的一些陷阱&quot; class=&quot;headerlink&quot; title=&quot;char*赋值给std::string的一些陷阱&quot;&gt;&lt;/a&gt;char*赋值给std::str
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://TokeyRoad.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>strcmp实现</title>
    <link href="http://TokeyRoad.github.io/2020/04/28/strcmp%E5%AE%9E%E7%8E%B0/"/>
    <id>http://TokeyRoad.github.io/2020/04/28/strcmp实现/</id>
    <published>2020-04-28T01:54:39.000Z</published>
    <updated>2020-04-28T07:02:45.340Z</updated>
    
    <content type="html"><![CDATA[<h4 id="strcmp函数实现以及分析"><a href="#strcmp函数实现以及分析" class="headerlink" title="strcmp函数实现以及分析"></a>strcmp函数实现以及分析</h4><h5 id="strcmp函数原型"><a href="#strcmp函数原型" class="headerlink" title="strcmp函数原型"></a>strcmp函数原型</h5><blockquote><p>int strcmp(const char<em> str1, const char</em> str2);</p><p>str1 &lt; str2 返回负值或-1</p><p>str1 == str2 返回0</p><p>str1 &gt; str2 返回正值或1</p></blockquote><h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>该函数实际上是对字符的ASCII码进行比较，实现方案：从前往后依次比较两个字符串的字符，如果不相等，就停止比较并返回结果，如果相等就继续，直到其中一个字符串遇到结束符’\0’为止。</p><h5 id="Linux源码"><a href="#Linux源码" class="headerlink" title="Linux源码"></a>Linux源码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str1, <span class="keyword">const</span> <span class="keyword">char</span>* str2)</span></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c1, c2;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">c1 = *str1++;</span><br><span class="line">c2 = *str2++;</span><br><span class="line"><span class="keyword">if</span>(c1 != c2)<span class="keyword">return</span> (c1 &lt; c2) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!c1)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己用减法实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmpNew2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str1, <span class="keyword">const</span> <span class="keyword">char</span>* str2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!(ret = *(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)str1 - *(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)str2) &amp;&amp; *str1) &#123;</span><br><span class="line">str1++;</span><br><span class="line">str2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//if (ret &lt; 0)&#123;</span></span><br><span class="line"><span class="comment">//return -1;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//else if (ret &gt; 0)&#123;</span></span><br><span class="line"><span class="comment">//return 1;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//return 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>这个函数体内没有判断参数为NULL时的情况，所以当传入NULL时程序会崩溃，<string>中的strcmp也会崩溃</string></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;strcmp函数实现以及分析&quot;&gt;&lt;a href=&quot;#strcmp函数实现以及分析&quot; class=&quot;headerlink&quot; title=&quot;strcmp函数实现以及分析&quot;&gt;&lt;/a&gt;strcmp函数实现以及分析&lt;/h4&gt;&lt;h5 id=&quot;strcmp函数原型&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://TokeyRoad.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>产生dump文件</title>
    <link href="http://TokeyRoad.github.io/2020/04/28/%E4%BA%A7%E7%94%9Fdump%E6%96%87%E4%BB%B6/"/>
    <id>http://TokeyRoad.github.io/2020/04/28/产生dump文件/</id>
    <published>2020-04-28T01:31:07.000Z</published>
    <updated>2020-04-28T01:47:49.197Z</updated>
    
    <content type="html"><![CDATA[<h4 id="程序崩溃或发生异常时产生dump文件"><a href="#程序崩溃或发生异常时产生dump文件" class="headerlink" title="程序崩溃或发生异常时产生dump文件"></a>程序崩溃或发生异常时产生dump文件</h4><p>核心API是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CreateFile()</span><br><span class="line">MinDumpWriteDump()</span><br></pre></td></tr></table></figure><p>需要包含的头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;DbgHelp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"dbghelp.lib"</span>)</span></span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;DbgHelp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"dbghelp.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LONG WINAPI <span class="title">MyCustomUnhandledFilter</span><span class="params">(struct _EXCEPTION_POINTERS *lpExceptionInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LONG iRet = EXCEPTION_EXECUTE_HANDLER;</span><br><span class="line"></span><br><span class="line">TCHAR szDumpFileName[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">SYSTEMTIME st = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">GetLocalTime(&amp;st);</span><br><span class="line">wsprintf(szDumpFileName, <span class="string">"%04d-%02d-%02d-%02d-%02d-%02d.dmp"</span>, st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wMinute);</span><br><span class="line"></span><br><span class="line">HANDLE hDumpFile = CreateFile(szDumpFileName, GENERIC_WRITE, FILE_SHARE_READ, <span class="literal">NULL</span>, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hDumpFile == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">DWORD dwErrorID = GetLastError();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to create dump file, error ID: %d\n"</span>, dwErrorID);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> iRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MINIDUMP_EXCEPTION_INFORMATION MindumpExceptionInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">MindumpExceptionInfo.ThreadId = GetCurrentThreadId();</span><br><span class="line">MindumpExceptionInfo.ExceptionPointers = lpExceptionInfo;</span><br><span class="line">MindumpExceptionInfo.ClientPointers = FALSE;</span><br><span class="line"></span><br><span class="line">BOOL bRet = MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), hDumpFile, MiniDumpNormal, &amp;MindumpExceptionInfo, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Succeeded to create dump file!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to create dump file!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CloseHandle(hDumpFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> iRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crash</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = a;</span><br><span class="line"><span class="comment">//！！程序崩溃的地方</span></span><br><span class="line">i /= j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SetUnhandledExceptionFilter(MyCustomUnhandledFilter);</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">crash(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(buf, <span class="string">"123456789"</span>);</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;程序崩溃或发生异常时产生dump文件&quot;&gt;&lt;a href=&quot;#程序崩溃或发生异常时产生dump文件&quot; class=&quot;headerlink&quot; title=&quot;程序崩溃或发生异常时产生dump文件&quot;&gt;&lt;/a&gt;程序崩溃或发生异常时产生dump文件&lt;/h4&gt;&lt;p&gt;核心API是
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://TokeyRoad.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>vector resize与reserve区别</title>
    <link href="http://TokeyRoad.github.io/2020/04/27/vector-resize%E4%B8%8Ereserve%E5%8C%BA%E5%88%AB/"/>
    <id>http://TokeyRoad.github.io/2020/04/27/vector-resize与reserve区别/</id>
    <published>2020-04-27T06:43:13.000Z</published>
    <updated>2020-04-27T07:20:13.433Z</updated>
    
    <content type="html"><![CDATA[<p>std::vector的reserve和resize的区别</p><blockquote><ol><li>reserve：分配空间，更改capacity但不改变size。</li><li>resize：分配空间，更改capacity也改变size。</li></ol></blockquote><h4 id="函数作用"><a href="#函数作用" class="headerlink" title="函数作用"></a>函数作用</h4><p>reserve是容器预留空间，不会真正的去创建数组对象，在创建对象之前，不能引用容器内的元素，当加入新元素的时候使用push_bakc()/insert()函数。</p><p>resize是改变容器大小，并且创建对象，因此调用这个函数之后，就可以引用容器内的对象，加入新元素的时候可以使用operator[]操作符，或者引用迭代器来引用元素对象。</p><h4 id="函数形式"><a href="#函数形式" class="headerlink" title="函数形式"></a>函数形式</h4><p>reserve：一个参数，即需要预留的容器的空间；</p><p>resize：两个参数，第一个是容器新的大小，第二个是要加入容器中的新元素，如果这个参数被省略，                那么就调用元素对象的默认构造函数。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span> vec;</span><br><span class="line"><span class="comment">/*****reserve*****/</span></span><br><span class="line">vec.reserve(<span class="number">10</span>);<span class="comment">//新元素还没有构造</span></span><br><span class="line"><span class="comment">//此时不能用[]访问元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">vec.push_back(i);<span class="comment">//新元素这时才构造</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****resize****/</span></span><br><span class="line">vec.resize(<span class="number">12</span>);</span><br><span class="line">vec[<span class="number">10</span>] = <span class="number">1</span>;<span class="comment">//直接操作新元素</span></span><br><span class="line">vec[<span class="number">11</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>vector在内存中是连续分布的，所以设计的时候会在所有元素外预留一部分空间，否则每次新增元素都需要重新分配，那么效率将会很低。</p><p>假如vector中存在1000个元素，两种做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="built_in">std</span>::<span class="built_in">vector</span>， 循环调用<span class="number">1000</span>次push_back(将会进行大量次数的内存分配)</span><br><span class="line"><span class="number">2.</span> <span class="built_in">std</span>::<span class="built_in">vector</span>(<span class="number">1000</span>), 循环调用<span class="number">1000</span>次push_back(就只会进行几次内存分配)</span><br></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li>当前容器预留了多大的空间？（不进行内存重分配的情况下，可以容纳多少元素）</li><li>怎么重设容器的预留大小？</li></ol><p>获取预留空间capacity()</p><p>重设预留空间大小reserve()</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>resize()和reserve()是两回事，前者影响容器中元素个数，后者影响容器预留空间。</p><blockquote><p>假设vector vec;  size() = 50 capacity() = 100 那么：</p><ol><li>resize(10);//size() == 10  10–49下标的元素被删除,capacity()=100不变，没有内存重分配。</li><li>resize(60);//size()==60    50–59下标用默认构造函数填充,capacity()=100不变，没有内存重分配。</li><li>resize(60,999);//size()==60    50–59下标用999填充,capacity()=100不变，没有内存重分配。</li><li>resize(200);//size()==200    50–199下标用默认构造函数填充,capacity()=200,自动扩容，内存重分配。</li><li>reserve(10);//size()==50  不变，没有元素被删除，capacity()=100，不变，即reserve调用不起作用。</li><li>reserve(60);//size()==50  元素不变，capacity()=100，不变，即reserve调用不起作用。</li><li>reserve(200);//size()==50  元素不变，capacity()=200，扩容，内存重分配。</li></ol><p>vector vec(10); //size()==10;capacity()==10;</p><p>vec.push_back(999);//size()=11;capacity()=15;//自动扩容，capacity()的结果是不定的，也不一定是15。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;std::vector的reserve和resize的区别&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;reserve：分配空间，更改capacity但不改变size。&lt;/li&gt;
&lt;li&gt;resize：分配空间，更改capacity也改变size。&lt;/li&gt;
&lt;/o
      
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://TokeyRoad.github.io/tags/C/"/>
    
      <category term="STL" scheme="http://TokeyRoad.github.io/tags/STL/"/>
    
      <category term="vector" scheme="http://TokeyRoad.github.io/tags/vector/"/>
    
  </entry>
  
  <entry>
    <title>C++关键字(2)</title>
    <link href="http://TokeyRoad.github.io/2020/03/13/C++%E5%85%B3%E9%94%AE%E5%AD%97-2/"/>
    <id>http://TokeyRoad.github.io/2020/03/13/C++关键字-2/</id>
    <published>2020-03-13T07:51:16.000Z</published>
    <updated>2020-04-27T02:00:42.945Z</updated>
    
    <content type="html"><![CDATA[<h6 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h6><a id="more"></a><p>指定构造函数或转换函数为显示，即它不能用于隐式转换和复制初始化。</p><p>explicit说明符只能出现在类定义之内的构造函数或转换函数的声明说明符序列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">A(<span class="keyword">int</span>)&#123;&#125;</span><br><span class="line">A(<span class="keyword">int</span>,<span class="keyword">int</span>)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span>)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestExpl</span><span class="params">()</span></span>&#123;</span><br><span class="line">A a1 = <span class="number">1</span>;<span class="comment">// A a1 = A(1);</span></span><br><span class="line"><span class="comment">// B b1 = 1;//error</span></span><br><span class="line"><span class="function">A <span class="title">a2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">B <span class="title">b2</span><span class="params">(<span class="number">2</span>)</span></span>;<span class="comment">//OK</span></span><br><span class="line">A a3 = &#123;<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">// A a3 = A&#123;4,5&#125;;  A&#123;4,5&#125;;</span></span><br><span class="line"><span class="comment">// B b3 = &#123;4,5&#125;;//error</span></span><br><span class="line"><span class="keyword">int</span> na1 = a1;<span class="comment">//OK</span></span><br><span class="line"><span class="comment">//int na1 = b2;//error</span></span><br><span class="line"><span class="keyword">int</span> na2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(a1);</span><br><span class="line"><span class="keyword">int</span> nb2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(b2);</span><br><span class="line">A a4 = (A)<span class="number">1</span>;</span><br><span class="line">B b4 = (B)<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h6><p>C++11引入的，指代空指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T t, U u)</span></span>&#123;</span><br><span class="line">t(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nullPointer</span><span class="params">(<span class="keyword">int</span>* a)</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"i'm a pointer\n'"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testNullPointer</span><span class="params">()</span></span>&#123;</span><br><span class="line">nullPointer(<span class="number">0</span>);</span><br><span class="line">nullPointer(<span class="literal">NULL</span>);<span class="comment">//(void*)0</span></span><br><span class="line">nullPointer(<span class="literal">nullptr</span>);<span class="comment">// std::nullptr_t</span></span><br><span class="line">func(nullPointer, <span class="literal">nullptr</span>);<span class="comment">//OK</span></span><br><span class="line">    <span class="comment">//模板推导会去找 函数nullPointer(int),而不是nullPointer(int*)</span></span><br><span class="line">func(nullPointer, <span class="number">0</span>);<span class="comment">//error </span></span><br><span class="line">func(nullPointer, <span class="literal">NULL</span>);<span class="comment">//error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="operator"><a href="#operator" class="headerlink" title="operator"></a>operator</h6><p>当重载一些特殊操作符时，一定要小心，可能会一些预想之外的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AAA</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span> &amp;()&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testOperator</span><span class="params">()</span></span>&#123;</span><br><span class="line">AAA a;</span><br><span class="line">    <span class="comment">//这里&amp;已经不是获取地址的功能了</span></span><br><span class="line"><span class="keyword">auto</span> address = &amp;a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h6><p>类型转换（类似于int转char*）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AAA</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testReinter</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(&amp;a);</span><br><span class="line"><span class="keyword">if</span>(p[<span class="number">0</span>] == <span class="number">1</span>) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"the system is little endian\n"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"the system is big endian\n"</span>;</span><br><span class="line"><span class="comment">// reinterpret_cast</span></span><br><span class="line"><span class="comment">// static_cast</span></span><br><span class="line"><span class="comment">// const_cast</span></span><br><span class="line"><span class="comment">// dynamic_cast</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// c like cast</span></span><br><span class="line"><span class="keyword">auto</span> pp = (<span class="keyword">char</span>*)(&amp;a);</span><br><span class="line"><span class="keyword">const</span> AAA bb;</span><br><span class="line"><span class="keyword">auto</span> pbb = <span class="keyword">const_cast</span>&lt;AAA*&gt;(&amp;bb);</span><br><span class="line"><span class="keyword">auto</span> cbb = (AAA*)(&amp;bb);</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">auto</span> cc = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(c);</span><br><span class="line"><span class="keyword">auto</span> ccc = (<span class="keyword">char</span>)c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="static"><a href="#static" class="headerlink" title="static"></a>static</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量在其他文本extern声明后可访问，static不允许</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> globalA = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStatic</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> localStatic = <span class="number">0</span>;</span><br><span class="line">++localStatic;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; localStatic &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>&#123;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//sizeof(S) = 1 // S == empty</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S:s = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testStaticAssert</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">static_assert</span>((<span class="keyword">sizeof</span>(<span class="keyword">int</span>) == <span class="number">4</span>) &amp;&amp; <span class="string">"only work for int for 32 bit"</span>);</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">assert(a == b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="static-assert-amp-assert"><a href="#static-assert-amp-assert" class="headerlink" title="static_assert&amp;assert"></a>static_assert&amp;assert</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testStaticAssert</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//static_assert在编译期检查，assert在运行期检查 debug模式下生效</span></span><br><span class="line"><span class="keyword">static_assert</span>((<span class="keyword">sizeof</span>(<span class="keyword">int</span>) == <span class="number">4</span>) &amp;&amp; <span class="string">"only work for int for 32 bit"</span>);</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">assert(a == b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> ulong;</span><br><span class="line"><span class="function">class <span class="title">testTypedef</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, ulong&gt; Group;</span><br><span class="line">Group a;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aa</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// std::map&lt;int, ulong&gt;::itertor iter = a.find(10);</span></span><br><span class="line"><span class="comment">// Group::iteator iter = a.find(10);</span></span><br><span class="line"><span class="keyword">auto</span> iter = a.find(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;explicit&quot;&gt;&lt;a href=&quot;#explicit&quot; class=&quot;headerlink&quot; title=&quot;explicit&quot;&gt;&lt;/a&gt;explicit&lt;/h6&gt;
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://TokeyRoad.github.io/tags/C/"/>
    
      <category term="关键字" scheme="http://TokeyRoad.github.io/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>深入学习C++关键字</title>
    <link href="http://TokeyRoad.github.io/2020/03/12/C++%E5%85%B3%E9%94%AE%E5%AD%97-1/"/>
    <id>http://TokeyRoad.github.io/2020/03/12/C++关键字-1/</id>
    <published>2020-03-12T03:26:15.000Z</published>
    <updated>2020-03-13T08:12:30.326Z</updated>
    
    <content type="html"><![CDATA[<h6 id="alignas-amp-alignof"><a href="#alignas-amp-alignof" class="headerlink" title="alignas&amp;alignof"></a>alignas&amp;alignof</h6><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Empty</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct <span class="title">alignas</span><span class="params">(<span class="number">64</span>)</span> Empty64 </span>&#123;&#125;;</span><br><span class="line"><span class="comment">//0会被忽略</span></span><br><span class="line"><span class="function">struct <span class="title">alignas</span><span class="params">(<span class="number">0</span>)</span> BB </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct <span class="title">alignas</span><span class="params">(<span class="number">8</span>)</span> Double </span>&#123;</span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Obj</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//alignof </span></span><br><span class="line"><span class="keyword">int</span> s_obj = <span class="keyword">sizeof</span>(Obj);<span class="comment">//8</span></span><br><span class="line"><span class="keyword">int</span> a_obj = <span class="keyword">alignof</span>(Obj);<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alignInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Alignment of"</span> <span class="string">"\n"</span></span><br><span class="line"><span class="string">"- char:"</span> &lt;&lt; <span class="keyword">alignof</span>(<span class="keyword">char</span>)&lt;&lt; <span class="string">"\n"</span><span class="comment">//1</span></span><br><span class="line"><span class="string">"- pointer:"</span> &lt;&lt; <span class="keyword">alignof</span>(<span class="keyword">int</span>*)&lt;&lt; <span class="string">"\n"</span><span class="comment">//8 4</span></span><br><span class="line"><span class="string">"- empty class:"</span> &lt;&lt; <span class="keyword">alignof</span>(Empty)&lt;&lt; <span class="string">"\n"</span><span class="comment">//1</span></span><br><span class="line"><span class="string">"- class Foo:"</span> &lt;&lt; <span class="keyword">alignof</span>(Foo)&lt;&lt; <span class="string">"\n"</span><span class="comment">//4</span></span><br><span class="line"><span class="string">"- alignas(64) Empty:"</span> &lt;&lt; <span class="keyword">alignof</span>(Empty64)&lt;&lt; <span class="string">"\n"</span><span class="comment">//64</span></span><br><span class="line"><span class="string">"- alignas(1) Double:"</span> &lt;&lt; <span class="keyword">alignof</span>(Double)&lt;&lt; <span class="string">"\n"</span>;<span class="comment">//8(WIN下编译报错)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="and-amp-amp-and-eq"><a href="#and-amp-amp-and-eq" class="headerlink" title="and&amp;&amp;and_eq"></a>and&amp;&amp;and_eq</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iso646.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AND</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//and 等价于 &amp;</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">b and_eq a;</span><br><span class="line"><span class="comment">//等价于 b &amp;= a;</span></span><br><span class="line"><span class="comment">//等价于 b = b &amp; a;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="asm"><a href="#asm" class="headerlink" title="asm"></a>asm</h6><p>用于在C++代码中嵌入汇编语言，不常用</p><h6 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h6><ol><li>对于变量，指定将要从其初始值设定项自动推断出要声明的变量的类型。</li><li>对于函数，指定将其从其return语句推导返回类型。</li><li>对于非类型模板参数，指定将从参数推导类型。</li></ol><h6 id="bitand-amp-bitor"><a href="#bitand-amp-bitor" class="headerlink" title="bitand&amp;bitor"></a>bitand&amp;bitor</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showBitAndor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> a = <span class="number">3L</span>;</span><br><span class="line"><span class="keyword">auto</span> b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">auto</span> c = a bitand b;<span class="comment">//等价于 &amp;</span></span><br><span class="line"><span class="keyword">auto</span> d = a bitor b;<span class="comment">//等价于 |</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行时计算</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n &lt;= <span class="number">1</span> ? <span class="number">1</span> : (n * fact( n - <span class="number">1</span>)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译时计算</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n &lt;= <span class="number">1</span> ? <span class="number">1</span> : (n * factorial( n - <span class="number">1</span>)); &#125;</span><br></pre></td></tr></table></figure><p>constexpr所修饰的变量一定是编译期可求值的，所修饰的函数在所有的参数都是constexpr时，一定会返回constexpr。</p><p>constexpr的好处：</p><ol><li>是一种很强的约束，更好的保证程序的正确语义不被破坏。</li><li>编译期可以在编译期对constexpr的代码进行非常大的优化，比如将用到的constexpr表达式都直接替换成最终结果等。</li><li>相对于宏来说，没有额外的开销，更安全可靠。</li></ol><h6 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testConstCast</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> j = <span class="number">3</span>;<span class="comment">//j is declared const</span></span><br><span class="line"><span class="comment">//const int*</span></span><br><span class="line"><span class="keyword">int</span>* pj = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;j); </span><br><span class="line">*pj = <span class="number">4</span>;<span class="comment">//undefined behavior!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const_cast一般不推荐使用，出现的时候大多数意味着代码结构出现了问题，const本身表示不可变的，const_cast转换 却破坏了这个不变性。</p><h6 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h6><p>用于获取变量或者表达式的类型或者函数的返回类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span> <span class="keyword">double</span> x;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testDecl</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> A* a = <span class="keyword">new</span> A&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> aa = a-&gt;x;</span><br><span class="line"><span class="keyword">decltype</span>(a-&gt;x) y;<span class="comment">//double</span></span><br><span class="line"><span class="keyword">auto</span>&amp; cc = y;</span><br><span class="line"><span class="keyword">decltype</span>((a-&gt;x)) z = y;<span class="comment">//double&amp;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="comment">//后置函数类型</span></span><br><span class="line">auto add(T a, U b) -&gt; decltype(a+b)&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">error cant compile</span></span><br><span class="line"><span class="comment"> decltype(a+b) add(T a, U b)&#123;</span></span><br><span class="line"><span class="comment">  return a+b;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testDecltype</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> cc = add(<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//cc int</span></span><br><span class="line"><span class="keyword">auto</span> dd = add(<span class="number">1.0</span>, <span class="number">3</span>);<span class="comment">//dd double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h6><p>沿继承层级向上、向下及侧向，安全地转换 到其他类的指针和引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span>&#123;</span><span class="keyword">virtual</span> ~Base()&#123;&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestDyn</span><span class="params">()</span></span>&#123;</span><br><span class="line">Base *b1 = <span class="keyword">new</span> Base;</span><br><span class="line"><span class="keyword">if</span>(Derived *d = <span class="keyword">dynamic_cast</span>&lt;Derived*&gt;(b1))&#123;<span class="comment">//fail</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"downcast from b1 to d successful\n"</span>;</span><br><span class="line">d-&gt;name();<span class="comment">//safe to call</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Base *b2 = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="keyword">if</span>(Derived *d = <span class="keyword">dynamic_cast</span>&lt;Derived *&gt;(b2))&#123;<span class="comment">//success</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"downcast from b2 to d successful\n"</span>;</span><br><span class="line">d-&gt;name();<span class="comment">//safe to call</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Base bb;</span><br><span class="line"><span class="comment">//fail throw bad_cast exception</span></span><br><span class="line"><span class="comment">//Derived&amp; cc = dynamic_cast&lt;Derived&amp;&gt;(bb);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> b1;</span><br><span class="line">    <span class="keyword">delete</span> b2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;alignas-amp-alignof&quot;&gt;&lt;a href=&quot;#alignas-amp-alignof&quot; class=&quot;headerlink&quot; title=&quot;alignas&amp;amp;alignof&quot;&gt;&lt;/a&gt;alignas&amp;amp;alignof&lt;/h6&gt;
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://TokeyRoad.github.io/tags/C/"/>
    
      <category term="关键字" scheme="http://TokeyRoad.github.io/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>libcurl 编译使用</title>
    <link href="http://TokeyRoad.github.io/2019/07/19/libcurl-%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/"/>
    <id>http://TokeyRoad.github.io/2019/07/19/libcurl-编译使用/</id>
    <published>2019-07-19T08:20:30.000Z</published>
    <updated>2019-07-19T09:12:25.607Z</updated>
    
    <content type="html"><![CDATA[<p>工作的原因，需要使用libcurl库，这里整理一下过程，方便日后食用。（很大一部分来自网络资源，不喜勿喷）</p><h4 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h4><p>cURL、libcurl 还有 curl，他们究竟是什么？</p><p>也就是说，我们需要去了解下 libcurl 及其相关的概念。</p><h4 id="二、cURL、libcurl-还有-curl-傻傻分不清楚-T-T"><a href="#二、cURL、libcurl-还有-curl-傻傻分不清楚-T-T" class="headerlink" title="二、cURL、libcurl 还有 curl 傻傻分不清楚 T_T"></a>二、cURL、libcurl 还有 curl 傻傻分不清楚 T_T</h4><p>可能对于新人来说，就连 cURL、libcurl 和 curl 的概念都是分不清楚的。这不怪我们，确实关于这一点，官方网站都没有说的很清楚，但是在源代码中的 FAQ 文档中却说的非常明白。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">What is cURL? </span><br><span class="line">cURL is the name of the project. The name is a play on ‘Client for URLs’, originally with URL spelled in uppercase to make it obvious it deals with URLs. The fact ti can also be pronounced ‘see URL’ alse helped, it works as an abbreviation for “Client URL Request Library” or why not the recursive version: “Curl URL Request Library”.</span><br></pre></td></tr></table></figure><p>简而言之，cURL 是一个项目的名称。是 Client for URLs、see URL、Client URL Request Library 或者 Curl URL Request Library 的缩写，也就是一个客户端 URL 请求库的项目。</p><p>那么什么是 libcurl 呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The cURL project produces two products: </span><br><span class="line">libcurl </span><br><span class="line">A free and easy-to-use client-side URL transfer library. </span><br><span class="line">… </span><br><span class="line">curl </span><br><span class="line">A command line tool for getting or sending files using URL syntax.</span><br></pre></td></tr></table></figure><p>上面这段话很清晰的表现出了 cURL 与 libcurl 以及 curl 的关系，也就是说：</p><p>cURL 这个项目包含了 libcurl 和 curl 两个产品。<br>其中，libcurl 是一个客户端的 URL 支持库；而 curl 就是一个使用了 libcurl 库写出来的命令行工具，其可以使用 URL 标识来请求或者发送文件。</p><p>也就是说，如果我们想要编写代码来控制有关网络的行为的话，我们就需要使用到 libcurl 库而不是 curl 命令行工具；而如果我们想要直接调用 curl 命令行工具来完成一些操作，比如将其嵌入到脚本代码中去，那么这个时候，我们才会用到 curl 命令行工具。</p><p>现在搞清楚了一些必要的概念，以及一些有趣的题外话，现在让我们来看看，我们要在 Unix 环境和 Windows 环境下编译和使用 libcurl，我们需要哪些东西，以及我们能在哪些地方获取到这些东西。</p><h4 id="三、资料的获取"><a href="#三、资料的获取" class="headerlink" title="三、资料的获取"></a>三、资料的获取</h4><p>我们想要了解 libcurl 这个库，最直接的资源获取来源当然是官方网站： </p><p><a href="https://curl.haxx.se/" target="_blank" rel="noopener">curl官网</a></p><p>可能对于新手来说，一点开就会觉得有些迷茫，因为可能分不清楚 curl 和 libcurl 的区别。这也是为什么我一定要在介绍资料来源之前介绍 cURL、libcurl 和 curl 三者的区别的原因。相信在我上一节花了那么大篇幅来介绍这三者的区别之后，你应该不会那么迷茫了。 </p><p>对于我们开发者来说，了解 libcurl 应该是最重要的。因为我们是想要使用 libcurl 库来编写代码的，而不是来学习 curl 的使用方法的。</p><p>通过多次尝试的我最后发现，下载 Source Archives 也就是源代码的版本，是最好的。原因嘛，当你下载下来之后，解压到本地看看里面的内容你就知道了，因为它，实在是太完善了： </p><p>简单的说几个：</p><ol><li><p>docs 文件夹<br>这里面有丰富的说明文档以及 libcurl 的运行示例代码。<br>有关 cURL、libcurl 以及 curl 的概念的定义，就是在这个文件夹下的 FAQ 文件里面。后面将要讲述的在 Unix 下编译使用 libcurl 库的内容，也是来源于这个文件夹下的 INSTALL.md 文件。除此之外，这个文件夹下还有很多说明文档，有待大家去探索去发现去思考去使用。<br>这个文件夹下的 examples 文件夹下，有着丰富的示例代码，其中的 https.c 就是本篇博客的测试运行代码。</p></li><li><p>winbuild 文件夹<br>这个文件夹介绍了如何使用 Visual Studio 编译 libcurl 的方法。基于 Windows 环境的编译与使用就是参考的这个文件夹下的 BUILD.WINDOWS.txt 文件中的内容。<br>并且这个文件夹下提供了编译的配置信息文件，大大方便了我们在 Windows 下使用 Visual Studio 编译 libcurl 的工作。</p></li><li><p>configure<br>这个脚本文件用于在 Unix 下配置 libcurl 的安装信息，用来之后安装 libcurl 环境使用。</p></li></ol><p>等等等等，curl 的源代码文件中，包含了很多很多东西。有很多你可能接触不到，我们可以在学习中在使用中慢慢去发掘去使用。</p><h4 id="四、libcurl-在-Unix-环境下的编译"><a href="#四、libcurl-在-Unix-环境下的编译" class="headerlink" title="四、libcurl 在 Unix 环境下的编译"></a>四、libcurl 在 Unix 环境下的编译</h4><p>让我们步入正题吧，libcurl 在 Unix 环境下怎么编译与使用呢？</p><p>这个问题在 curl-7.61.0\docs 下的 INSTALL.md 文件中讲述的非常清晰：</p><blockquote><p>A normal Unix installation is made in three or four steps (after you’ve unpacked the source archive):<br>./configure<br>make<br>make test (optional) </p><p>make install</p></blockquote><p>也就是说，在类 Unix 环境下，我们都可以在源代码文件目录下使用以下四句指令完成 libcurl 库的安装与编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./configure</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make <span class="built_in">test</span> (optional)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure><p>其中第三步，也就是测试那步是非常耗时间的，为了节约时间可以省略。<br>另外第四步，可能会涉及到权限问题，如果出现这个问题，需要切换到 root 权限安装。</p><p>简单总结下步骤吧：</p><ol><li><p>使用 WinSCP 以及类似的工具，将下载下来的源代码文件放置到指定目录下，比如我现在将下载下来的 curl-7.61.0.zip 文件放到了 RedHat 7.2 环境中的 /home/wangying/libcurl 文件夹下</p></li><li><p>解压上一步放置的源代码文件</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ unzip curl<span class="number">-7.61</span><span class="number">.0</span>.zip</span><br></pre></td></tr></table></figure></li><li><p>解压完成后进入 curl-7.61.0 文件夹下，运行上述所说的 4 条指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./configure</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make <span class="built_in">test</span> (optional)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure><p>建议大家省去第三步，因为实在太耗费时间了（T_T）。</p></li><li><p>执行完了之后，现在直接运行 curl 还是会显示系统默认自带的版本。我们需要进入到默认安装的目录下 <code>/usr/local/bin</code> 中使用下列命令运行：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="string">./curl</span> <span class="params">--version</span></span><br><span class="line">$ <span class="string">./curl-config</span> <span class="params">--version</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="/2019/07/19/libcurl-编译使用/libcurl_1.png" alt="libcurl_1"></p><p>上述两行代码会输出 curl 以及 curl-config 两个工具的版本信息，与你下载的版本一致即为安装成功。根据我的试验经验，一旦你运行了上述两行代码，系统自动会记录下来这两个工具的路径，不过为了确保系统找得到这两个工具，你可以单独设置下环境变量。</p><ol start="5"><li><p>libcurl 库的相关头文件与库文件所在地方，可以通过下列命令查看（这会在下一节中的使用中提到）</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl-<span class="built_in">config</span> <span class="comment">--cflags</span></span><br><span class="line">$ curl-<span class="built_in">config</span> <span class="comment">--libs</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="/2019/07/19/libcurl-编译使用/libcurl_2.png" alt="libcurl_2"></p><p>其中 –cflags 输出的我们编写代码时需要包含的头文件路径， –libs 输出的是我们编写代码时需要包含的库文件路径，我们只需要将上述两行简单的添加到编译指令中即可运行我们的示例代码。</p><h4 id="五、libcurl-在-Unix-环境下的使用"><a href="#五、libcurl-在-Unix-环境下的使用" class="headerlink" title="五、libcurl 在 Unix 环境下的使用"></a>五、libcurl 在 Unix 环境下的使用</h4><p>让我们点开源代码 docs 目录下的 examples 文件夹，其中的 README 文件详细介绍了 libcurl 示例代码的使用方式：</p><blockquote><p>Most examples should build fine using a command line like this:<br>$ curl-config –cc –cflags –libs -o example example.c<br>Some compilers don’t like having the arguments in this order but instead want you do reorganize them like: </p><p>$ <code>curl-config --cc</code> -o example example.c <code>curl-config --cflags --libs</code></p></blockquote><p>也就是说，只要我们在上一步中成功安装了 curl 以及 curl-config 工具，在这一步中，我们只需要简单的运行这行指令即可自动的指定代码的包含头文件以及库文件信息：</p><blockquote><p>$ <code>curl-config --cc</code> -o example example.c <code>curl-config --cflags --libs</code></p></blockquote><p>让我们来尝试下 examples 中的 https.c 文件的编译（因为 https.c 文件可以在源代码中看到，这里就不再详细展示文件内容）：</p><blockquote><p>$ <code>curl-config --cc</code> -o https https.c <code>curl-config --cflags --libs</code></p></blockquote><p><img src="/2019/07/19/libcurl-编译使用/libcurl_3.png" alt="libcurl_3"></p><p>可见，https.c 的运行是非常成功的，成功返回了获取的 html 信息。</p><p>同样的示例我在 Ubuntu 18.04上运行通过，相信在类 Unix 上应该都是没有问题的。</p><h4 id="六、libcurl-在-Windows-环境下的编译"><a href="#六、libcurl-在-Windows-环境下的编译" class="headerlink" title="六、libcurl 在 Windows 环境下的编译"></a>六、libcurl 在 Windows 环境下的编译</h4><p>libcurl 在 Windows 环境下的编译，在源代码文件夹下的 docs 文件夹下的 INSTALL 文件中有所提及，但是讲述的稍微有些晦涩难懂。欣喜的是源代码根目录下直接提供了一个 winbuilds 文件夹方便我们完成在 Windows 环境下的编译工作。</p><p>这里，让我们看看 winbuild 文件夹下的 BUILD.WINDOWS.txt 文件的内容（这个文件中的内容非常详尽，这里不再粘贴出来）。</p><p>我简单总结下步骤：</p><ol><li>运行 Developer Command Prompt for VS 工具 </li></ol><ol start="2"><li><p>进入到源代码文件夹下的 winbuild 目录下</p></li><li><p>运行下列指令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmake /f Makefile.vc <span class="attribute">mode</span>=&lt;static <span class="keyword">or</span> dll&gt; &lt;options&gt;</span><br></pre></td></tr></table></figure><p>其中的 mode= 后面填写 static 是编译静态库， dll 是动态库；另外 options 的填写说明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">where &lt;options&gt; is one or many of:</span><br><span class="line">  VC=&lt;6,7,8,9,10,11,12,14,15&gt;    - VC versions</span><br><span class="line">  WITH_DEVEL=&lt;path&gt;              - Paths for the development files (SSL, zlib, etc.)</span><br><span class="line">                                   Defaults to sibbling directory deps: ../deps</span><br><span class="line">                                   Libraries can be fetched at http://windows.php.net/downloads/php-sdk/deps/</span><br><span class="line">                                   Uncompress them into the deps folder.</span><br><span class="line">  WITH_SSL=&lt;dll or static&gt;       - Enable OpenSSL support, DLL or static</span><br><span class="line">  WITH_NGHTTP2=&lt;dll or static&gt;   - Enable HTTP/2 support, DLL or static</span><br><span class="line">  WITH_MBEDTLS=&lt;dll or static&gt;   - Enable mbedTLS support, DLL or static</span><br><span class="line">  WITH_CARES=&lt;dll or static&gt;     - Enable c-ares support, DLL or static</span><br><span class="line">  WITH_ZLIB=&lt;dll or static&gt;      - Enable zlib support, DLL or static</span><br><span class="line">  WITH_SSH2=&lt;dll or static&gt;      - Enable libSSH2 support, DLL or static</span><br><span class="line">  ENABLE_SSPI=&lt;yes or no&gt;        - Enable SSPI support, defaults to yes</span><br><span class="line">  ENABLE_IPV6=&lt;yes or no&gt;        - Enable IPv6, defaults to yes</span><br><span class="line">  ENABLE_IDN=&lt;yes or no&gt;         - Enable use of Windows IDN APIs, defaults to yes</span><br><span class="line">                                   Requires Windows Vista or later</span><br><span class="line">  ENABLE_WINSSL=&lt;yes or no&gt;      - Enable native Windows SSL support, defaults to yes</span><br><span class="line">  GEN_PDB=&lt;yes or no&gt;            - Generate Program Database (debug symbols for release build)</span><br><span class="line">  DEBUG=&lt;yes or no&gt;              - Debug builds</span><br><span class="line">  MACHINE=&lt;x86 or x64&gt;           - Target architecture (default is x86)</span><br><span class="line">  CARES_PATH=&lt;path to cares&gt;     - Custom path for c-ares</span><br><span class="line">  MBEDTLS_PATH=&lt;path to mbedTLS&gt; - Custom path for mbedTLS</span><br><span class="line">  NGHTTP2_PATH=&lt;path to HTTP/2&gt;  - Custom path for nghttp2</span><br><span class="line">  SSH2_PATH=&lt;path to libSSH2&gt;    - Custom path for libSSH2</span><br><span class="line">  SSL_PATH=&lt;path to OpenSSL&gt;     - Custom path for OpenSSL</span><br><span class="line">  ZLIB_PATH=&lt;path to zlib&gt;       - Custom path for zlib</span><br></pre></td></tr></table></figure><p>大家可根据需要填写，这里我填写的命令是：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmake /f Makefile.vc <span class="attribute">mode</span>=static</span><br></pre></td></tr></table></figure></li><li><p>待编译完成，进入源代码文件夹下，其中多出来了一个 builds 文件夹，其中名字长度最短的那个点击进去，可以看到 bin、include 和 lib 子文件夹，其中 bin 中就是编译出来的 curl 命令行工具，include 就是我们在编写代码中需要包含的头文件，lib 就是我们在编写代码中需要包含的静态库文件（不过仍然需要 CRT 静态库的另外链接） </p></li></ol><p>至此，使用 Visual Studio 2017 编译工具静态编译 libcurl 库的工作就算是完成了。这里值得注意的是，Windows 平台下的编译选项有很多，我们可以根据需要配置自己想要的 libcurl 库。比如静态动态，比如使用 VC 12 13 14 15 版本等等等等。</p><p>在这篇博客里，主要展示了使用静态库的方式。接下来，我们来看看如何使用刚刚编译出来的这些文件进行示例代码的运行使用。</p><h4 id="七、libcurl-在-Windows-环境下的使用"><a href="#七、libcurl-在-Windows-环境下的使用" class="headerlink" title="七、libcurl 在 Windows 环境下的使用"></a>七、libcurl 在 Windows 环境下的使用</h4><p>这里，我简单总结下步骤：</p><ol><li><p>使用 Visual Studio 2017 新建一个 Visual C++ 的空项目，并将示例代码 https.c 拷贝到项目中去</p></li><li><p>为了使得我们的 https.c 代码运行后控制台不会一闪而过，我们需要修改 https.c 的代码，不多，只需要添加两行即可：</p></li></ol><p>// 添加在 include 的地方</p><p>#include &lt;stdlib.h&gt;<br>// 添加在 return 语句之前<br>system(“pause”);</p><p>这样，就可以使得控制台窗口运行完代码逻辑之后暂停，不至于关闭掉窗口了。</p><ol start="3"><li>将上一节中生成的 include 文件夹以及 lib 文件夹拷贝到项目中去 </li></ol><ol start="4"><li><p>配置 VC++ 目录：需要让代码能够找到需要包含的头文件和静态库文件<br> 包含目录添加：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// <span class="variable">$(SolutionDir)</span> 是当前的解决方案目录</span><br><span class="line"><span class="variable">$(SolutionDir)</span><span class="keyword">include</span></span><br></pre></td></tr></table></figure><p>库目录添加：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $(SolutionDir) 是当前的解决方案目录</span></span><br><span class="line"><span class="symbol">$</span>(SolutionDir)lib</span><br></pre></td></tr></table></figure><p><img src="/2019/07/19/libcurl-编译使用/libcurl_4.png" alt="libcurl_4"></p></li></ol><ol start="5"><li><p>配置需要链接的静态库文件 链接器-&gt;输入-&gt;附加依赖项</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">libcurl_a.lib</span><br><span class="line">Ws2_32.lib</span><br><span class="line">Wldap32.lib</span><br><span class="line">winmm.lib</span><br><span class="line">Crypt32.lib</span><br><span class="line">Normaliz.lib</span><br></pre></td></tr></table></figure><p><img src="/2019/07/19/libcurl-编译使用/libcurl_5.png" alt="libcurl_5"></p></li></ol><ol start="6"><li>修改预处理器定义：</li></ol><p>C/C++ -&gt; 预处理器 -&gt; 预处理器定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加 </span></span><br><span class="line">CURL_STATICLIB;</span><br></pre></td></tr></table></figure><ol start="7"><li><p>编译运行，顺利的话能够看到结果如下 </p><p><img src="/2019/07/19/libcurl-编译使用/libcurl_6.png" alt="libcurl_6"></p></li></ol><p>至此，完结撒花，^_^</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工作的原因，需要使用libcurl库，这里整理一下过程，方便日后食用。（很大一部分来自网络资源，不喜勿喷）&lt;/p&gt;
&lt;h4 id=&quot;一、引言&quot;&gt;&lt;a href=&quot;#一、引言&quot; class=&quot;headerlink&quot; title=&quot;一、引言&quot;&gt;&lt;/a&gt;一、引言&lt;/h4&gt;&lt;p&gt;c
      
    
    </summary>
    
      <category term="环境配置" scheme="http://TokeyRoad.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="libcurl" scheme="http://TokeyRoad.github.io/tags/libcurl/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现(列表对象)</title>
    <link href="http://TokeyRoad.github.io/2019/07/17/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1/"/>
    <id>http://TokeyRoad.github.io/2019/07/17/Redis设计与实现-列表对象/</id>
    <published>2019-07-17T01:19:55.000Z</published>
    <updated>2019-07-17T03:42:19.876Z</updated>
    
    <content type="html"><![CDATA[<p>列表对象的编码可以是 <code>ziplist</code> 或者 <code>linkedlist</code> 。</p><ul><li><code>ziplist</code> 编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点（entry）保存了一个列表元素。</li><li><code>linkedlist</code> 编码的列表对象使用双端链表作为底层实现，每个双端链表节点（node）都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。</li></ul><blockquote><p> 注：linkedlist编码的列表对象在底层的双端链表结构中包含了多个字符串对象，这种嵌套字符串对象的行为在后续的哈希对象，集合对象，有序集合对象中都会出现，字符串对象是Redis五种类型的对象中唯一的一个会被嵌套的对象。</p></blockquote><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH numbers 1 &quot;three&quot; 5</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><p>创建出一个列表对象 作为 <code>numbers</code> 键的值。</p><p>如果 <code>numbers</code>键的值对象使用的是 <code>ziplist</code> 编码，这个值对象结构如下：</p><p><img src="/2019/07/17/Redis设计与实现-列表对象/ListObject_1.png" alt="ListObject_1"></p><p>如果 <code>numbers</code> 键的值对象使用的不是 <code>ziplist</code> 编码，而是 <code>linkedlist</code> 编码，值结构如下：</p><p><img src="/2019/07/17/Redis设计与实现-列表对象/ListObject_2.png" alt="ListObject_2"></p><p>下图表示一个包含了字符串值 <code>“three”</code> 的字符串对象：</p><p>简化表示：</p><p><img src="/2019/07/17/Redis设计与实现-列表对象/ListObject_3.png" alt="ListObject_3"></p><p>实际结构：</p><p><img src="/2019/07/17/Redis设计与实现-列表对象/ListObject_4.png" alt="ListObject_4"></p><h4 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h4><p>当列表对象可以同时满足以下两个条件时，列表对象使用 <code>ziplist</code> 编码：</p><ol><li>列表对象保存的所有字符串元素的长度都小于 <code>64</code> 字节；</li><li>列表对象保存的元素数量小于 <code>512</code> 个；</li></ol><p>不能满足这两个条件的列表对象需要使用 <code>linkedlist</code> 编码。</p><blockquote><p>两个上限值可以在配置文件中修改 <code>list-max-ziplist-value</code> 和 <code>list-max-ziplist-entries</code>选项。</p></blockquote><p>对于使用 <code>ziplist</code> 编码的列表对象，当两个条件任意一个不满足时，对象的编码转换操作就会被执行；原本保存在压缩列表里的所有列表元素都会被转移并保存到双端链表里，对象的编码也会从 <code>ziplist</code> 变为 <code>linkedlist</code>。</p><h4 id="列表命令的实现"><a href="#列表命令的实现" class="headerlink" title="列表命令的实现"></a>列表命令的实现</h4><table><thead><tr><th>命令</th><th><code>ziplist</code> 编码的实现方法</th><th><code>linkedlist</code> 编码的实现方法</th></tr></thead><tbody><tr><td>LPUSH</td><td>调用 <code>ziplistPush</code> 函数，将新元素推入到压缩列表的表头。</td><td>调用 <code>listAddNodeHead</code> 函数，将新元素推入到双端链表的表头。</td></tr><tr><td>RPUSH</td><td>调用 <code>ziplistPush</code> 函数，将新元素推入到压缩列表的末尾。</td><td>调用 <code>listAddNodeTail</code> 函数，将新元素推入到双端链表的表尾。</td></tr><tr><td>LPOP</td><td>调用 <code>ziplistIndex</code> 函数定位压缩列表的表头节点，在向用户返回节点所保存的元素之后，调用 <code>ziplistDelete</code> 函数删除表头节点。</td><td>调用 <code>listFirst</code> 函数定位双端链表的表头节点，在向用户返回节点所保存的元素之后，调用 <code>listDelNode</code> 函数删除表头节点。</td></tr><tr><td>RPOP</td><td>调用 <code>ziplistIndex</code> 函数定位压缩列表的表尾节点，在向用户返回节点所保存的元素之后，调用 <code>ziplistDelete</code> 函数删除表尾节点。</td><td>调用 <code>listLast</code> 函数定位双端链表的表尾节点，在向用户返回节点所保存的元素之后，调用 <code>listDelNode</code> 函数删除表尾节点。</td></tr><tr><td>LINDEX</td><td>调用 <code>ziplistIndex</code> 函数定位压缩列表中的指定节点，然后返回节点所保存的元素。</td><td>调用 <code>listIndex</code> 函数定位双端链表中的指定节点，然后返回节点所保存的元素。</td></tr><tr><td>LLEN</td><td>调用 <code>ziplistLen</code> 函数返回压缩列表的长度。</td><td>调用 <code>listLength</code> 函数返回双端链表的长度。</td></tr><tr><td>LINSERT</td><td>插入新节点到压缩列表的表头或者表尾是，使用 <code>ziplistPush</code> 函数；插入新节点到压缩列表其他位置时，使用 <code>ziplistInsert</code> 函数。</td><td>调用 <code>listInsertNode</code> 函数，将新节点插入到双端链表的指定位置。</td></tr><tr><td>LREM</td><td>遍历压缩列表节点，并调用 <code>ziplistDelete</code> 函数删除包含了指定元素的节点。</td><td>遍历双端链表节点，并调用 <code>listDelNode</code> 函数删除包含了指定元素的节点。</td></tr><tr><td>LTRIM</td><td>调用 <code>ziplistDeleteRange</code> 函数，删除压缩列表中所有不在指定索引范围内的节点。</td><td>遍历双端链表节点，并调用 <code>listDelNode</code> 函数删除链表中所有不在指定索引范围内的节点。</td></tr><tr><td>LSET</td><td>调用 <code>ziplistDelete</code> 函数，先删除压缩列表指定索引上的现有节点，然后调用 <code>ziplistInsert</code> 函数，将一个包含给定元素的新节点插入到相同索引上。</td><td>调用 <code>listIndex</code> 函数，定位到双端链表指定索引上的节点，通过赋值操作更新节点的值。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;列表对象的编码可以是 &lt;code&gt;ziplist&lt;/code&gt; 或者 &lt;code&gt;linkedlist&lt;/code&gt; 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ziplist&lt;/code&gt; 编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点（entry）保存了一个列表
      
    
    </summary>
    
      <category term="Redis设计与实现" scheme="http://TokeyRoad.github.io/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="Redis" scheme="http://TokeyRoad.github.io/tags/Redis/"/>
    
      <category term="列表对象" scheme="http://TokeyRoad.github.io/tags/%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现(字符串对象)</title>
    <link href="http://TokeyRoad.github.io/2019/07/05/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1/"/>
    <id>http://TokeyRoad.github.io/2019/07/05/Redis设计与实现-字符串对象/</id>
    <published>2019-07-05T01:50:42.000Z</published>
    <updated>2019-07-15T09:20:46.658Z</updated>
    
    <content type="html"><![CDATA[<p>Redis的键值对都是由对象来表示的，即每次创建一个新的键值对时，我们会至少创建两个对象，一个对象用作键（键对象），另一个用作值（值对象）。</p><p>Redis的每一个对象都是由一个 <code>redisObject</code> 结构表示，该结构中和保存数据有关的三个属性分别是 <code>type</code>、<code>encoding</code>、<code>ptr</code> 属性:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125;robj;</span><br></pre></td></tr></table></figure><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>对象的 <code>type</code> 属性记录了对象的类型，属性值对应的常量如下：</p><table><thead><tr><th>类型常量</th><th>对象的名称</th></tr></thead><tbody><tr><td><code>REDIS_STRING</code></td><td>字符串对象</td></tr><tr><td><code>REDIS_LIST</code></td><td>列表对象</td></tr><tr><td><code>REDIS_HASH</code></td><td>哈希对象</td></tr><tr><td><code>REDIS_SET</code></td><td>集合对象</td></tr><tr><td><code>REDIS_ZSET</code></td><td>有序集合对象</td></tr></tbody></table><p>对于Redis数据库保存的键值对，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种，因此：</p><ul><li>当称呼一个数据库键为 “字符串键”时，我们指的是“这个数据库键所对应的值为字符串对象”；</li><li>当称呼一个键为“列表键”时，我们指的是“这个数据库键所对应的值为列表对象”。</li></ul><p>所以当我们队一个数据库键执行 <code>TYPE</code> 命令时，命令返回的结果为数据库键对应的值对象的类型，而不是键对象的类型；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 键为字符串对象，值为字符串对象</span><br><span class="line">redis&gt; SET msg &quot;hello world&quot;</span><br><span class="line">OK</span><br><span class="line">redis&gt; TYPE msg</span><br><span class="line">string</span><br><span class="line"># 键为字符串对象，值为列表对象</span><br><span class="line">redis&gt; RPUSH numbers 1 3 5</span><br><span class="line">(integer) 6</span><br><span class="line">redis&gt; TYPE numbers</span><br><span class="line">list</span><br></pre></td></tr></table></figure><p>下表为不同类型值对象的TYPE命令输出：</p><table><thead><tr><th>对象</th><th>对象 <code>type</code> 属性的值</th><th>TYPE命令的输出</th></tr></thead><tbody><tr><td>字符串对象</td><td><code>REDIS_STRING</code></td><td>“string”</td></tr><tr><td>列表对象</td><td><code>REDIS_LIST</code></td><td>“list”</td></tr><tr><td>哈希对象</td><td><code>REDIS_HASH</code></td><td>“hash”</td></tr><tr><td>集合对象</td><td><code>REDIS_SET</code></td><td>“set“</td></tr><tr><td>有序集合对象</td><td><code>REDIS_ZSET</code></td><td>“zset”</td></tr></tbody></table><h3 id="编码和底层实现"><a href="#编码和底层实现" class="headerlink" title="编码和底层实现"></a>编码和底层实现</h3><p>对象的 <code>ptr</code> 指针指向对象的底层实现数据结构，而这些数据结构由对象的 <code>encoding</code> 属性决定。</p><p><code>encoding</code> 属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现，这个属性的值在下表中列出：</p><table><thead><tr><th>编码常量</th><th>编码所对应的底层数据结构</th></tr></thead><tbody><tr><td><code>REDIS_ENCODING_INT</code></td><td><code>long</code> 类型的整数</td></tr><tr><td><code>REDIS_ENCODING_EMBSTR</code></td><td><code>embstr</code> 编码的简单动态字符串</td></tr><tr><td><code>REDIS_ENCODING_RAW</code></td><td>简单动态字符串</td></tr><tr><td><code>REDIS_ENCODING_HT</code></td><td>字典</td></tr><tr><td><code>REDIS_ENCODING_LINKEDLIST</code></td><td>双端链表</td></tr><tr><td><code>REDIS_ENCODING_ZIPLIST</code></td><td>压缩列表</td></tr><tr><td><code>REDIS_ENCODING_INTSET</code></td><td>整数集合</td></tr><tr><td><code>REDIS_ENCODING_SKIPLIST</code></td><td>跳跃表和字典</td></tr></tbody></table><p>每种类型的对象都至少使用了两种不同的编码，下表列出了每种类型的对象可以使用的编码。</p><table><thead><tr><th>类型</th><th>编码</th><th>对象</th></tr></thead><tbody><tr><td><code>REDIS_STRING</code></td><td><code>REDIS_ENCODING_INT</code></td><td>使用整数值实现的字符串对象</td></tr><tr><td></td><td><code>REDIS_ENCODING_EMBSTR</code></td><td>使用 <code>embstr</code> 编码的简单动态字符串实现的字符串对象</td></tr><tr><td></td><td><code>REDIS_ENCODING_RAW</code></td><td>使用简单动态字符串实现的字符串对象</td></tr><tr><td><code>REDIS_LIST</code></td><td><code>REDIS_ENCODING_ZIPLIST</code></td><td>使用压缩列表实现的列表对象</td></tr><tr><td></td><td><code>REDIS_ENCODING_LINKEDLIST</code></td><td>使用双端链表实现的哈希对象</td></tr><tr><td><code>REDIS_HASH</code></td><td><code>REDIS_ENCODING_ZIPLIST</code></td><td>使用压缩列表实现的哈希对象</td></tr><tr><td></td><td><code>REDIS_ENCODING_HT</code></td><td>使用字典实现的哈希对象</td></tr><tr><td><code>REDIS_SET</code></td><td><code>REDIS_ENCODING_INTSET</code></td><td>使用整数集合实现的集合对象</td></tr><tr><td></td><td><code>REDIS_ENCODING_HT</code></td><td>使用字典实现的集合对象</td></tr><tr><td><code>REDIS_ZSET</code></td><td><code>REDIS_ENCODING_ZIPLIST</code></td><td>使用压缩列表实现的有序集合对象</td></tr><tr><td></td><td><code>REDIS_ENCODING_SKIPLIST</code></td><td>使用跳跃表和字典实现的有序集合对象</td></tr></tbody></table><p>使用OBJECT ENCODING 命令可以查看一个数据库键的值对象的编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello wrold&quot;</span><br><span class="line">OK</span><br><span class="line">redis&gt; OBJECT ENCODING msg</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">redis&gt; SET story &quot;long long long long long long ago ...&quot;</span><br><span class="line">OK</span><br><span class="line">redis&gt; OBJECT ENCODING story</span><br><span class="line">&quot;raw&quot;</span><br></pre></td></tr></table></figure><p>OBJECT ENCODING对不同编码的输出:</p><table><thead><tr><th style="text-align:left">对象所使用的底层数据结构</th><th style="text-align:left">编码常量</th><th style="text-align:left">OBJECT ENCODING 命令输出</th></tr></thead><tbody><tr><td style="text-align:left">整数</td><td style="text-align:left"><code>REDIS_ENCODING_INT</code></td><td style="text-align:left"><code>&quot;int&quot;</code></td></tr><tr><td style="text-align:left"><code>embstr</code> 编码的简单动态字符串（SDS）</td><td style="text-align:left"><code>REDIS_ENCODING_EMBSTR</code></td><td style="text-align:left"><code>&quot;embstr&quot;</code></td></tr><tr><td style="text-align:left">简单动态字符串</td><td style="text-align:left"><code>REDIS_ENCODING_RAW</code></td><td style="text-align:left"><code>&quot;raw&quot;</code></td></tr><tr><td style="text-align:left">字典</td><td style="text-align:left"><code>REDIS_ENCODING_HT</code></td><td style="text-align:left"><code>&quot;hashtable&quot;</code></td></tr><tr><td style="text-align:left">双端链表</td><td style="text-align:left"><code>REDIS_ENCODING_LINKEDLIST</code></td><td style="text-align:left"><code>&quot;linkedlist&quot;</code></td></tr><tr><td style="text-align:left">压缩列表</td><td style="text-align:left"><code>REDIS_ENCODING_ZIPLIST</code></td><td style="text-align:left"><code>&quot;ziplist&quot;</code></td></tr><tr><td style="text-align:left">整数集合</td><td style="text-align:left"><code>REDIS_ENCODING_INTSET</code></td><td style="text-align:left"><code>&quot;intset&quot;</code></td></tr><tr><td style="text-align:left">跳跃表和字典</td><td style="text-align:left"><code>REDIS_ENCODING_SKIPLIST</code></td><td style="text-align:left"><code>&quot;skiplist&quot;</code></td></tr></tbody></table><p>通过 <code>encoding</code>属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大的提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某场景下的使用效率。</p><p>举个例子：</p><p>在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现：</p><ul><li>因为压缩列表比双端链表更节约内存，并且在元素数量较少时，在内存中以连续块方式保存的压缩列表比起双端链表可以更快的被载入到缓存中；</li><li>随着列表对象包含的元素越来越多，使用压缩列表来保存元素的优势逐渐消失时，对象就会将以底层实现从压缩列表转向功能更强，也更适合保存大量元素的双端链表上面；</li></ul><h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><p>字符串对象的编码可以是 <code>int</code> 、<code>raw</code> 、<code>embstr</code> 。</p><ul><li>如果一个字符串对象保存的是整数值，并且这个整数值可以用 <code>long</code> 类型表示，那么字符串对象会将整数值保存在字符串对象结构的 <code>ptr</code> 属性里面（<code>void*</code> -&gt; <code>long</code>），并将字符串对象的编码设置为 <code>int</code>。</li><li>如果字符串对象保存的是字符串值，并且这个字符串的长度大于 <code>39</code> 字节，那么字符串对象将会使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为 <code>raw</code>。</li><li>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于 <code>39</code> 字节，那么字符串对象将使用 <code>embstr</code> 编码的方式来保存这个字符串值。</li></ul><p><code>embstr</code> 编码是专门用于保存短字符串的一种优化编码方式，这种编码和 <code>raw</code> 编码一样，都使用 <code>redisObject</code> 结构和 <code>sdshdr</code> 结构来表示字符串对象，但 <code>raw</code>编码会调用两次内存分配函数来分别创建 <code>redisObject</code>结构和 <code>sdshrd</code> 结构，而 <code>embstr</code> 编码则通过调用一次内存分配函数来分配一块连续的空间，空间中依次包含 <code>redisObject</code> 和 <code>sdshdr</code> 结构。</p><p><code>embstr</code> 编码的字符串对象在执行时，产生的效果和 <code>raw</code> 编码的字符串对象执行命令时产生的效果是相同的，但使用 <code>embstr</code> 编码的字符串对象来保存短字符串值有以下好处:</p><ol><li><code>embstr</code> 编码将创建字符串对象所需的内存分配次数从 <code>raw</code> 编码的两次降低为一次。</li><li>释放 <code>embstr</code> 编码的字符串对象只需要调用一次内存释放函数，而释放 <code>raw</code> 变啊的字符串对象需要调用两次内存释放函数。</li><li>因为 <code>embstr</code> 编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起 <code>raw</code> 编码的字符串对象能更好地利用缓存带来的优势。</li></ol><p>可以用 <code>long double</code> 类型表示的浮点数在Redis中也是作为字符串值来保存的：如果保存一个浮点数到字符串对象里，那么程序会先将这个浮点数转换成字符串值，然后再保存起转换所得的字符串值。</p><p>在有需要的时候，程序会把保存在字符串对象里的字符串值转换为浮点数，执行某些操作，执行之后把所得的浮点数值转换为字符串值，继续保存在字符串对象里。（主要是体现在某些运算命令上（+-*/））</p><p>下表为字符串对象保存各类型值的编码方式：</p><table><thead><tr><th>值</th><th>编码</th></tr></thead><tbody><tr><td><code>long</code> 类型保存的整数</td><td><code>int</code></td></tr><tr><td><code>long doube</code> 类型保存的浮点数</td><td><code>embstr</code> 或 <code>raw</code></td></tr><tr><td>字符串值，或因为长度太大而无法用 <code>long</code> 类型表示的整数，或太大无法用 <code>long double</code> 类型表示的浮点数。</td><td><code>embstr</code> 或者 <code>raw</code></td></tr></tbody></table><h4 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h4><p><code>int</code> 编码的字符串对象和 <code>embstr</code> 编码的字符串对象在条件满足的情况下，会被转换为 <code>raw</code> 编码的字符串对象。</p><p>对于 <code>int</code> 编码的字符串对象，如果我们向对象执行了一些命令，使得这个对象保存的不再是整数值，而是一个字符串值，那么字符串对象的编码将从 <code>int</code> 变为 <code>raw</code></p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET number 10086</span><br><span class="line">OK</span><br><span class="line">redis&gt; OBJECT ENCODING number</span><br><span class="line">&quot;int&quot;</span><br><span class="line">redis&gt; APPEND number &quot; is a good number!&quot;</span><br><span class="line">(integer) 23</span><br><span class="line">redis&gt; GET number</span><br><span class="line">&quot;10086 is a good number!&quot;</span><br><span class="line">redis&gt; OBJECT ENCODING number</span><br><span class="line">&quot;raw&quot;</span><br></pre></td></tr></table></figure><p>此外，Redis没有为 <code>embstr</code> 编码的字符串对象编写任何相应的修改程序（只有 <code>int</code> 编码和 <code>raw</code> 编码的字符串对象有这些程序），所以 <code>embstr</code> 编码的字符串对象实际上是只读的，当我们对 <code>embstr</code> 编码的字符串对象执行任何修改命令时，程序会先将对象的编码从 <code>embstr</code> 转换为 <code>raw</code> ，然后再执行修改命令，因此， <code>embstr</code> 编码的字符串对象在执行修改命令之后，总会变成一个 <code>raw</code> 编码的字符串对象。</p><p>字符串命令的实现：</p><table><thead><tr><th>命令</th><th><code>int</code>编码的实现方法</th><th><code>embstr</code>编码的实现方法</th><th><code>raw</code>编码的实现方法</th></tr></thead><tbody><tr><td>SET</td><td>使用 <code>int</code> 编码保存值。</td><td>使用 <code>embstr</code> 编码保存值。</td><td>使用 <code>raw</code> 编码保存值。</td></tr><tr><td>GET</td><td>拷贝对象所保存的整数值，将这个拷贝转换成字符串值，然后向客户端返回这个字符串值。</td><td>直接向客户端返回字符串值。</td><td>直接向客户端返回字符串值。</td></tr><tr><td>APPEND</td><td>将对象转换成 <code>raw</code> 编码，然后按 <code>raw</code> 编码的方式执行此操作。</td><td>将对象转换成 <code>raw</code>编码，然后按 <code>raw</code> 编码的方式执行此操作。</td><td>调用 <code>sdscatlen</code> 函数，将给定欺负穿追加到现有字符串的末尾。</td></tr><tr><td>INCRBYFLOAT</td><td>取出整数值，并将其转换成 <code>long double</code> 类型的浮点数，对这个浮点数进行加法计算，然后将得出的浮点数结果保存起来。</td><td>取出字符串并尝试将其转换成 <code>long double</code> 类型的浮点数，对这个浮点数进行加法计算，然后将得出的浮点数结果保存起来。如果字符串不能被转换成浮点数，那么向客户端返回一个错误。</td><td>取出字符串并尝试将其转换成 <code>long double</code> 类型的浮点数，对这个浮点数进行加法计算，然后将得出的浮点数结果保存起来。如果字符串不能被转换成浮点数，那么向客户端返回一个错误。</td></tr><tr><td>INCYBY</td><td>对整数值进行加法计算，得到的计算结果会作为整数被保存起来。</td><td><code>embstr</code> 编码不能执行此命令，向客户端返回一个错误。</td><td><code>raw</code> 编码不能执行此命令，向客户端返回一个错误。</td></tr><tr><td>DECRBY</td><td>对整数值进行减法运算，得出的计算结果会作为整数被保存起来。</td><td><code>embstr</code> 编码不能执行此命令，向客户端返回一个错误。</td><td><code>raw</code> 编码不能执行此命令，向客户端返回一个错误。</td></tr><tr><td>STRLEN</td><td>拷贝对象所保存的整数值，将这个拷贝转换成字符串值，计算并返回这个字符串值的长度。</td><td>调用 <code>sdslen</code> 函数，返回字符串的长度。</td><td>调用 <code>sdslen</code> 函数，返回字符串的长度。</td></tr><tr><td>SETRANGE</td><td>将对象转换成 <code>raw</code> 编码，然后按 <code>raw</code> 编码的方式执行此命令。</td><td>将对象转换成 <code>raw</code>编码，然后按 <code>raw</code> 编码的方式执行此命令。</td><td>将字符串特定索引上的值设置为给定的字符。</td></tr><tr><td>GETRANGE</td><td>拷贝对象所保存的整数值，将这个拷贝转换成字符串值，然后取出并返回字符串指定索引上的字符。</td><td>直接取出并返回字符串指定索引上的字符。</td><td>直接取出并返回字符串指定索引上的字符。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis的键值对都是由对象来表示的，即每次创建一个新的键值对时，我们会至少创建两个对象，一个对象用作键（键对象），另一个用作值（值对象）。&lt;/p&gt;
&lt;p&gt;Redis的每一个对象都是由一个 &lt;code&gt;redisObject&lt;/code&gt; 结构表示，该结构中和保存数据有关的
      
    
    </summary>
    
      <category term="Redis设计与实现" scheme="http://TokeyRoad.github.io/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="Redis" scheme="http://TokeyRoad.github.io/tags/Redis/"/>
    
      <category term="字符串对象" scheme="http://TokeyRoad.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>const用法总结</title>
    <link href="http://TokeyRoad.github.io/2019/07/01/const%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://TokeyRoad.github.io/2019/07/01/const用法总结/</id>
    <published>2019-07-01T02:32:27.000Z</published>
    <updated>2019-07-05T03:42:24.743Z</updated>
    
    <content type="html"><![CDATA[<p>简单总结一下const的用法。</p><h4 id="一、const修饰普通类型的变量。"><a href="#一、const修饰普通类型的变量。" class="headerlink" title="一、const修饰普通类型的变量。"></a>一、const修饰普通类型的变量。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> b = a;<span class="comment">//正确</span></span><br><span class="line">a = <span class="number">8</span>;<span class="comment">//错误，const修饰的参数为常量，不可修改</span></span><br></pre></td></tr></table></figure><p>a被 const修饰之后，被编译器识别为一个常量，常量不能被赋值。</p><a id="more"></a><p>简单实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)&amp;a;</span><br><span class="line">    *p = <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a;<span class="comment">//下断点，调试</span></span><br><span class="line">    <span class="comment">//这里会输出几呢?</span></span><br><span class="line">    <span class="comment">//输出：7</span></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，const 修饰 a，无法直接对a的值进行修改，但是通过*p直接对a地址内的值进行了赋值。</p><p>下断点调试时，会发现在 <code>*p = 8</code> 之后，a的值就变为了8。</p><p>但是程序最后输出的还是7。</p><p>从上述实例中发现，编译器对const修饰的a进行了优化，一直认为a的值为定义的7，当对它的地址的值修改之后，编译器并没有去修改它，认为它还是常量7，如果后续有用到a的操作可能会产生意想不到的结果。</p><p>如果不想让编译器对它的优化，在const前面添加 volatile关键字。</p><p>volatile关键字和const是相反的，不会被编译器优化，a的值也就会被改变了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">7</span>;</span><br><span class="line">改为：</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>这时，结果就会输出期望值 8。</p><h4 id="二、const修饰指针变量。"><a href="#二、const修饰指针变量。" class="headerlink" title="二、const修饰指针变量。"></a>二、const修饰指针变量。</h4><p>const修饰指针有三种情况：</p><ul><li>const修饰指针指向的内容，其内容不可变。</li><li>const修饰指针，指针不可变。</li><li>const修饰指针和指针指向的内容，两者都不可变。</li></ul><p>第一种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//const 位于 * 之前，则表示指针指向的内容不可变（左定值），即 8不可修改。</span></span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a;</span><br><span class="line">*p = <span class="number">9</span>;<span class="comment">//正确，修改了a地址的值 8-&gt;9</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">7</span>;</span><br><span class="line">p = &amp;b;<span class="comment">//错误</span></span><br><span class="line"><span class="comment">//const在 * 之后，表示指针不可变（右定向），即p只能指向a地址，不能修改。</span></span><br></pre></td></tr></table></figure><p>第三种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a;</span><br><span class="line"><span class="comment">//第一种和第二种的合并</span></span><br></pre></td></tr></table></figure><p>“左定值，右定向，const修饰不变量”</p><h4 id="三、const参数传递和参数返回值。"><a href="#三、const参数传递和参数返回值。" class="headerlink" title="三、const参数传递和参数返回值。"></a>三、const参数传递和参数返回值。</h4><h5 id="const修饰函数参数可分为三种情况："><a href="#const修饰函数参数可分为三种情况：" class="headerlink" title="const修饰函数参数可分为三种情况："></a>const修饰函数参数可分为三种情况：</h5><p>第一种：值传递的const修饰，一般这种情况不需要修饰，函数会自动产生临时变量复制实参值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    ++a;<span class="comment">//错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种：当const修饰指针时，可以防止指针被意外篡改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> * <span class="keyword">const</span> a)</span></span>&#123;</span><br><span class="line">    *a = <span class="number">9</span>;</span><br><span class="line">    <span class="comment">//int b = 5;</span></span><br><span class="line">    <span class="comment">//a = &amp;b;//错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line">    Test(&amp;a);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a; <span class="comment">// a = 9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种：自定义类型的参数传递（常用类型用的相对较少），需要临时构造对象复制参数，比较浪费时间，因此采用const加引用传递的方式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test(<span class="keyword">int</span> para)&#123;</span><br><span class="line">        m_Para = para;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPara</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="comment">//表示返回值不可变  下文有提到</span></span><br><span class="line">        <span class="keyword">return</span> m_para;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Para;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFun</span><span class="params">(<span class="keyword">const</span> Test&amp; t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t.getPara();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">8</span>)</span></span>;</span><br><span class="line">    TestFun(t);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="const修饰函数的返回值也有三种情况："><a href="#const修饰函数的返回值也有三种情况：" class="headerlink" title="const修饰函数的返回值也有三种情况："></a>const修饰函数的返回值也有三种情况：</h5><p>第一种：const修饰内置类型的返回值，修饰与不修饰返回值作用一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">CTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = CTest();</span><br><span class="line">    <span class="keyword">int</span> b = Test();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种：const修饰自定义类型的作为返回值，此时返回的值不能作为左值使用，不能被修改。</p><p>第三种：const修饰返回的指针或者引用，是否返回一个指向const的指针，取决于函数的作用。</p><h4 id="四、const修饰类成员函数"><a href="#四、const修饰类成员函数" class="headerlink" title="四、const修饰类成员函数"></a>四、const修饰类成员函数</h4><p>const修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果不想修改一个调用对象的值，所有的成员函数都应该声明为const成员函数。</p><p><strong>重点：</strong> const关键字不能与static关键字同时使用，因为static关键字修饰静态成员函数，静态成员函数不含有this指针，即不能实例化，const成员函数必须具体到某一实例。</p><p>如果有个成员函数想修改对象中的某一个成员，其他的不允许修改，这时就可以使用mutable关键字修饰这个成员，被mutable修饰的成员变量可以在const成员函数中被修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">t</span><span class="params">()</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        ++a;<span class="comment">//错误 </span></span><br><span class="line">        ++b;<span class="comment">//正确</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单总结一下const的用法。&lt;/p&gt;
&lt;h4 id=&quot;一、const修饰普通类型的变量。&quot;&gt;&lt;a href=&quot;#一、const修饰普通类型的变量。&quot; class=&quot;headerlink&quot; title=&quot;一、const修饰普通类型的变量。&quot;&gt;&lt;/a&gt;一、const修饰普通类型的变量。&lt;/h4&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b = a;	&lt;span class=&quot;comment&quot;&gt;//正确&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a = &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;;		&lt;span class=&quot;comment&quot;&gt;//错误，const修饰的参数为常量，不可修改&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;a被 const修饰之后，被编译器识别为一个常量，常量不能被赋值。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://TokeyRoad.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://TokeyRoad.github.io/tags/C/"/>
    
      <category term="Const" scheme="http://TokeyRoad.github.io/tags/Const/"/>
    
  </entry>
  
</feed>
