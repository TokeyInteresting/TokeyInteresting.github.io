---
title: Redis设计与实现(压缩列表)
date: 2019-06-21 15:02:29
categories: 
- Redis设计与实现
copyright: true
---

Redis为了节约内存而开发的压缩列表。

由一系列特殊编码的连续内存块组成的顺序型数据结构。

一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。

### 压缩列表的构成

包含三个节点的压缩列表，如下图：

![ziplist_1](Redis设计与实现-压缩列表\ziplist_1.png)

#### 各部分详细说明

| 属性      | 类型       | 长度     | 用途                                                         |
| --------- | ---------- | -------- | ------------------------------------------------------------ |
| `zlbytes` | `uint32_t` | `4` 字节 | 记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配，或者计算 `zlend` 的位置时使用。 |
| `zltail`  | `uint32_t` | `4` 字节 | 记录压缩列表表尾节点距离压缩列表的起始地址有多少个字节：通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。 |
| `zllen`   | `uint16_t` | `2` 字节 | 记录了压缩列表包含的节点数量：当这个属性的值小于 `UINT16_MAX(65535)` 时，这个属性的值就是压缩列表包含节点的数量；当这个值等于 `UINT16_MAX` 时，节点的真实数量需要遍历整个压缩列表才能计算得出。 |
| `entryX`  | 列表节点   | 不定     | 压缩列表的各个节点，节点的长度由节点保存的内容决定。         |
| `zlend`   | `uint8_t`  | `1` 字节 | 特殊值 `0xFF` （十进制 `255`），用于标记压缩列表的末端。     |

> 列表 `zlbytes` 属性的值为 `0x50` （十进制80），表示压缩列表的总长为 `80` 字节。
>
> 列表 `zltail` 属性的值为 `0x3c` （十进制60），这表示如果我们有一个指向压缩列表起始地址的指针 `p`，那么只要用指针 `p` 加上偏移量 `60` ，就可以计算出表尾节点 `entry3` 的地址。
>
> 列表 `zllen` 属性的值为 `0x3` （十进制3），表示压缩列表包含三个节点。

### 节点的构成

每个压缩列表节点可以保存一个字节数组或者一个整数值。

其中字节数组可以是以下三种长度的其中之一：

1. 长度小于等于 `63`（2^6  - 1）字节的字节数组；
2. 长度小于等于 `16383`（2^14 - 1）字节的字节数组；
3. 长度小于等于 `4294967295`（2^32 - 1）字节的字节数组；

整数值则可以是以下六种之一：

1. `4` 位长，介于 0 至 12 之间的无符号整数；
2. `1` 字节长的有符号整数；
3. `3` 字节长的有符号整数；
4. `int6_t` 类型整数；
5. `int32_t` 类型整数；
6. `int64_t` 类型整数。

每个压缩列表节点都是由 `previous_entry_length`、`encoding`、`content` 三个部分组成，如下图：

![ziplist_2](Redis设计与实现-压缩列表\ziplist_2.png)

#### previous_entry_length

节点的 `previous_entry_length` 属性以字节为单位，记录里压缩列表中前一个节点的长度。

属性的长度可以是 `1` 字节或者 `5` 字节：

> 如果前一节点的长度小于 `254`字节，那么 `previous_entry_length` 属性的长度为 `1`字节，前一节点的长度就保存在这一个字节中；
>
> 如果前一节点的长度大于等于 `254`字节，那么`previous_entry_length` 属性的长度为 `5`字节，其中属性中的第一个字节就会被设置为 `0xFE`（十进制 254），而之后的四个字节才是前一个节点的真正长度。



因为节点的`previous_entry_length` 属性记录了前一个节点的长度，所以程序可以通过指针运算，根据当前节点的起始地址来计算出前一个节点的起始地址。

压缩列表的从表尾向表头遍历操作就是使用这一原理实现的：只要我们拥有了一个指向某个节点起始地址的指针，那么通过这个指针以及这个节点的`previous_entry_length` 属性，程序就可以一直向前一个节点回溯，最终到达压缩列表的表头节点。

从表尾到表头节点遍历的过程（如下图）：

- 首先，我们拥有指向压缩列表表尾节点 `entry4` 起始地址的指针 `p1` （指向表尾节点的指针可以通过指向压缩列表起始地址的指针加上 `zltail` 属性的值得出）；
- 通过用 `p1` 减去 `entry4` 节点`previous_entry_length`属性的值，我们得到一个指向 `entry4`前一节点 `entry3`起始地址的指针 `p2`；
- 通过用 `p2` 减去 `entry3` 节点`previous_entry_length`属性的值，我们得到一个指向 `entry3`前一节点 `entry2`起始地址的指针 `p3`；
- 通过用 `p3` 减去 `entry2` 节点`previous_entry_length`属性的值，我们得到一个指向 `entry2`前一节点 `entry1`起始地址的指针 `p4`，`entry1`为压缩列表的表头节点；
- 最后，我们从表尾节点向表头节点遍历了整个列表。

![ziplist_3](Redis设计与实现-压缩列表\ziplist_3.png)

#### encoding

节点的 `encoding` 属性记录了节点的 `content`属性所保存数据的类型以及长度：

- 一字节、两字节或者五字节，值得最高位为 `00`、`01`或者 `10`的是字节数组编码：这种编码表示节点的 `content` 属性保存着字节数组，数组的长度由编码除去最高两位之后的其他位记录；
- 一字节长，值的最高位以 `11` 开头的是整数编码：这种编码表示节点的 `content`属性保存着整数值，整数值的类型和长度由编码除去最高两位之后的其他位记录；

字节数组编码

| 编码                                   | 编码长度 | `content` 属性保存的值               |
| -------------------------------------- | -------- | ------------------------------------ |
| `00bbbbbb`                             | `1`字节  | 长度小于等于 `63`字节的字节数组      |
| `01bbbbbb xxxxxxxx`                    | `2` 字节 | 长度小于等于 `16383` 字节的字节数组  |
| `10______ aaaaaaaaa bbbbbbbb cccccccc` | `5` 字节 | 长度小于等于 `4294967295` 的字节数组 |

整数编码

| 编码       | 编码长度 | `content`属性保存的值                                        |
| ---------- | -------- | ------------------------------------------------------------ |
| `11000000` | `1` 字节 | `int16_t`类型的整数                                          |
| `11010000` | `1` 字节 | `int32_t`类型的整数                                          |
| `11100000` | `1` 字节 | `int64_t`类型的整数                                          |
| `11110000` | `1`字节  | `24`位有符号整数                                             |
| `11111110` | `1`字节  | `8`位有符号整数                                              |
| `1111xxxx` | `1`字节  | 使用这一编码的节点没有 `content`属性，因为编码本身的 `xxxx`四个位已经保存了一个介于 `0` 和 `12` 之间的值，所以它无须 `content` 属性 |

#### content

节点的 `content`属性 负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的 `encoding` 属性决定。

保存字节数组的示例：

- 编码的最高两位 `00` 表示节点保存的是一个字节数组；
- 编码的后六位 `001011` 记录了字节数组的长度 `11`；
- `content` 属性保存着节点的值 `hello world`。

![ziplist_4](Redis设计与实现-压缩列表\ziplist_4.png)

保存整数值的示例：

- 编码 `11000000` 表示节点保存的是一个 `int16_t`类型的整数值；
- `content` 属性保存着节点的值 `10086`。

![ziplist_5](Redis设计与实现-压缩列表\ziplist_5.png)

### 连锁更新

前文提到每个节点的 `previous_entry_length` 属性都记录了前一节点的长度：

- 如果前一节点的长度小于 `254` 字节，那么 `previous_entry_length` 属性需要用 `1` 字节长的空间来保存这个长度值。
- 如果前一节点的长度大于等于 `254` 字节，那么  `previous_entry_length` 属性需要用 `5` 字节长的空间来保存这个长度值。

当出现这种情况时：在一个压缩列表中，有多个连续的、长度介于 `250` 字节到 `253` 字节之间的节点 `e1` 至 `eN`；

因为这连续部分节点的长度都是小于 `254`字节，所以记录这些节点的长度只需要 `1` 字节长的 `previous_entry_length`属性，这时，如果将一个长度大于等于 `254` 字节的新节点 设置为表头节点，也就是插入 `e1` 之前，那么，就比较麻烦了，因为 `e1 ` 的 `previous_entry_length`属性仅一个字节，没办法保存新节点的长度，这个时候就需要程序对压缩列表执行空间重分配操作，并将 `e1`节点的`previous_entry_length`属性长度从一个字节扩展到五个字节长。同时后面的节点 `e2` 也出现了同样的情况，需要扩展，然后后续节点需要依次扩展，程序就需要不断的对压缩列表进行空间重分配操作，直到能保存为止。这种情况被称为“连锁更新”。

下图展示了这一过程：

![ziplist_6](Redis设计与实现-压缩列表\ziplist_6.png)

此外，除了新增节点会出现连锁更新之外，删除节点也会出现连锁更新。

连锁更新在最坏的情况下需要对压缩列表执行 `N`次空间重分配操作，而每次空间空分配的最坏复杂度是O(N)，所以连锁更新的最坏复杂度为O(N^2)。

尽管连锁更新的复杂度较高，但是真正造成性能问题的几率是很低的：

- 首先，压缩列表中恰好有多个连续的、长度介于 `250` 字节至 `253` 字节之间的节点，连锁更新才会被引发。
- 其次，即使出现了连锁更新，更新的节点数量不多，就不会对性能造成任何影响。

因此， `ziplistPush` 等命令的平均复杂度仅为 O(N)，在实际使用中，不需要担心连锁更新会影响到压缩列表的性能。

### 压缩列表所有的API

| 函数                 | 作用                                                         | 算法复杂度                                                   |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `ziplistNew`         | 创建一个新的压缩列表。                                       | O(1)                                                         |
| `ziplistPush`        | 创建一个包含给定值的新节点，并将这个新节点添加到压缩列表的表头或者表尾。 | 平均O(N)，最坏O(N^2)。                                       |
| `ziplistInsert`      | 将包含给定值的新节点插入到给定节点之后。                     | 平均O(N)，最坏O(N^2)。                                       |
| `ziplistIndex`       | 返回压缩列表给定索引上的节点。                               | O(N)                                                         |
| `ziplistFind`        | 在压缩列表中查找并返回包含了给定值的节点。                   | 因为节点的值可能是一个字节数组，  所以检查节点值和给定值是否相同的复杂度为 O(N)， 而查找整个列表的复杂度则为 O(N^2 。 |
| `ziplistNext`        | 返回给定节点的下一个节点。                                   | O(1)                                                         |
| `ziplistPrev`        | 返回给定节点的前一个节点。                                   | O(1)                                                         |
| `ziplistGet`         | 获取给定节点所保存的值。                                     | O(1)                                                         |
| `ziplistDelete`      | 从压缩列表中删除给定的节点。                                 | 平均O(N)，最坏O(N^2)。                                       |
| `ziplistDeleteRange` | 删除压缩列表在给定索引上的连续多个节点。                     | 平均O(N)，最坏O(N^2)。                                       |
| `ziplistBlobLen`     | 返回压缩列表目前占用的内存字节数。                           | O(1)                                                         |
| `ziplistLen`         | 返回压缩列表目前包含的节点数量。                             | 节点数量小于 `65535`时 O(1)，大于 `65535`时O(N)。            |

其中 `ziplistPush` 、 `ziplistInsert` 、 `ziplistDelete` 和 `ziplistDeleteRange` 四个函数都有可能会引发连锁更新， 所以它们的最坏复杂度都是 O(N^2)。